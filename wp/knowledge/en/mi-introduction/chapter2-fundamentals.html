<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Theory and Practice of Data-Driven Materials Development">
    <title>Chapter 2: MI Fundamentals - Concepts, Methods & Ecosystem - MI Knowledge Hub</title>

    <!-- CSS Styling -->
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --bg-color: #ffffff;
            --text-color: #333333;
            --border-color: #e0e0e0;
            --code-bg: #f5f5f5;
            --link-color: #3498db;
            --link-hover: #2980b9;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem 1.5rem;
        }

        /* Header */
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header .container {
            padding: 0 1.5rem;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .meta {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
            font-size: 0.9rem;
            opacity: 0.95;
            margin-top: 1rem;
        }

        .meta span {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
        }

        /* Typography */
        h2 {
            font-size: 1.75rem;
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--secondary-color);
            color: var(--primary-color);
        }

        h3 {
            font-size: 1.4rem;
            margin-top: 2rem;
            margin-bottom: 0.8rem;
            color: var(--primary-color);
        }

        h4 {
            font-size: 1.2rem;
            margin-top: 1.5rem;
            margin-bottom: 0.6rem;
            color: var(--primary-color);
        }

        p {
            margin-bottom: 1.2rem;
        }

        a {
            color: var(--link-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--link-hover);
            text-decoration: underline;
        }

        /* Lists */
        ul, ol {
            margin-left: 2rem;
            margin-bottom: 1.2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        /* Code blocks */
        code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        pre {
            background: var(--code-bg);
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
        }

        pre code {
            background: none;
            padding: 0;
            font-size: 0.9rem;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
            overflow-x: auto;
            display: block;
        }

        thead {
            display: table;
            width: 100%;
            table-layout: fixed;
        }

        tbody {
            display: table;
            width: 100%;
            table-layout: fixed;
        }

        th, td {
            padding: 0.8rem;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background: var(--primary-color);
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--secondary-color);
            padding-left: 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: #666;
        }

        /* Images */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 1rem 0;
        }

        /* Mermaid diagrams */
        .mermaid {
            text-align: center;
            margin: 2rem 0;
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        /* Details/Summary (for exercises) */
        details {
            margin: 1rem 0;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--primary-color);
            padding: 0.5rem;
        }

        summary:hover {
            color: var(--secondary-color);
        }

        /* Footer */
        footer {
            margin-top: 4rem;
            padding: 2rem 0;
            border-top: 2px solid var(--border-color);
            text-align: center;
            color: #666;
            font-size: 0.9rem;
        }

        /* Navigation buttons */
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin: 3rem 0;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .nav-button {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            background: var(--secondary-color);
            color: white;
            border-radius: 6px;
            text-decoration: none;
            transition: all 0.3s;
            font-weight: 600;
        }

        .nav-button:hover {
            background: var(--link-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 1.6rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            pre {
                padding: 1rem;
                font-size: 0.85rem;
            }

            table {
                font-size: 0.9rem;
            }
        }
    </style>

    <!-- Mermaid for diagrams -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</head>
<body>
    <header>
        <div class="container">
            <h1>Chapter 2: MI Fundamentals - Concepts, Methods & Ecosystem</h1>
            <div class="meta">
                <span>📖 Reading Time: 20-25 minutes</span>
                <span>📊 Level: beginner-intermediate</span>
            </div>
        </div>
    </header>

    <main class="container">
        <h1 id="chapter-2-mi-fundamentals-concepts-methods-ecosystem">Chapter 2: MI Fundamentals - Concepts, Methods &amp; Ecosystem</h1>
<h2 id="learning-objectives">Learning Objectives</h2>
<p>By reading this chapter, you will be able to:<br />
- Explain the definition of MI and its differences from related fields (computational materials science, cheminformatics, etc.)<br />
- Understand the characteristics and use cases of major materials databases (Materials Project, AFLOW, OQMD, JARVIS)<br />
- Explain the 5-step MI workflow in detail (from problem formulation to validation)<br />
- Understand the types and importance of materials descriptors (composition-based, structure-based, property-based)<br />
- Correctly use 20 specialized terms frequently used in the MI field</p>
<hr />
<h2 id="21-what-is-mi-definition-and-related-fields">2.1 What is MI: Definition and Related Fields</h2>
<h3 id="211-etymology-and-history-of-materials-informatics">2.1.1 Etymology and History of Materials Informatics</h3>
<p>The term <strong>Materials Informatics (MI)</strong> began to be used in the early 2000s. It gained worldwide attention particularly with the launch of the <strong>U.S. Materials Genome Initiative (MGI) in 2011</strong> [1].</p>
<p><strong>MGI Goals:</strong><br />
- Reduce new materials development time to half of traditional approaches<br />
- Significantly reduce development costs<br />
- Accelerate through integration of computation, experiment, and data</p>
<p>This initiative was expected to have the potential to fundamentally transform materials science, just as the Human Genome Project transformed biology.</p>
<h3 id="212-definition">2.1.2 Definition</h3>
<p><strong>Materials Informatics (MI)</strong> is an academic field that combines materials science with data science. It is a methodology that accelerates the discovery of new materials and prediction of material properties by leveraging large amounts of materials data and information science technologies such as machine learning.</p>
<p><strong>Concise Definition:</strong></p>
<blockquote>
<p>"Science that speeds up materials development through the power of data and AI"</p>
</blockquote>
<p><strong>Core Elements:</strong><br />
1. <strong>Data</strong>: Experimental data, computational data, knowledge from literature<br />
2. <strong>Computation</strong>: First-principles calculations, molecular dynamics simulations<br />
3. <strong>Machine Learning</strong>: Predictive models, optimization algorithms<br />
4. <strong>Experimental Validation</strong>: Verification of predictions and data addition</p>
<h3 id="213-comparison-with-related-fields">2.1.3 Comparison with Related Fields</h3>
<p>MI is related to multiple fields, but each has a different focus.</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Subject</th>
<th>Main Methods</th>
<th>Objective</th>
<th>Relationship to MI</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Computational Materials Science</strong></td>
<td>Physical/chemical phenomena in materials</td>
<td>DFT, molecular dynamics</td>
<td>Theoretical prediction of material properties</td>
<td>MI utilizes this data</td>
</tr>
<tr>
<td><strong>Cheminformatics</strong></td>
<td>Compounds, small molecules</td>
<td>QSAR, molecular descriptors</td>
<td>Drug design, molecular property prediction</td>
<td>Shares descriptor concepts</td>
</tr>
<tr>
<td><strong>Bioinformatics</strong></td>
<td>Biomolecules, DNA/proteins</td>
<td>Sequence analysis, structure prediction</td>
<td>Decoding genetic information</td>
<td>Shares data-driven approach</td>
</tr>
<tr>
<td><strong>Materials Informatics<br>(MI)</strong></td>
<td>Solid materials in general</td>
<td>Machine learning, Bayesian optimization</td>
<td>Discovery and design of new materials</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong>Uniqueness of MI:</strong><br />
- <strong>Inverse Design Approach</strong>: Design materials from target properties (traditional approach calculates properties from materials)<br />
- <strong>Diverse Material Types</strong>: Covers a wide range including metals, ceramics, semiconductors, polymers<br />
- <strong>Strong Experimental Collaboration</strong>: Emphasizes experimental validation, not just computation</p>
<h3 id="214-forward-design-vs-inverse-design">2.1.4 Forward Design vs Inverse Design</h3>
<p><strong>Traditional Materials Development (Forward Design):</strong></p>
<pre class="codehilite"><code>Material composition → Calculate/measure structure/properties → Evaluate results
</code></pre>

<ul>
<li>Researchers propose candidate materials</li>
<li>Repeated trial and error</li>
<li>Time-consuming</li>
</ul>
<p><strong>MI Approach (Inverse Design):</strong></p>
<pre class="codehilite"><code>Target properties → Predict candidate materials with ML → Experiment top candidates
</code></pre>

<ul>
<li>AI proposes optimal materials</li>
<li>Efficiently screens large numbers of candidates</li>
<li>Significant time reduction</li>
</ul>
<p><strong>Concrete Example of Inverse Design:</strong><br />
"I want a semiconductor material with a bandgap of 2.0 eV"<br />
→ MI system automatically generates candidate material list<br />
→ Researchers experimentally validate only the top 10</p>
<hr />
<h2 id="22-mi-glossary-essential-20-terms">2.2 MI Glossary: Essential 20 Terms</h2>
<p>Here is a compilation of specialized terms frequently used in learning MI. For beginners, correctly understanding these terms is the first step.</p>
<h3 id="data-model-related-1-7">Data &amp; Model Related (1-7)</h3>
<table>
<thead>
<tr>
<th>Term (English)</th>
<th>Term (Japanese)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. Descriptor</strong></td>
<td>記述子</td>
<td>Numerical representation of material features. Examples: electronegativity, atomic radius, lattice constant. Used as input to machine learning models.</td>
</tr>
<tr>
<td><strong>2. Feature Engineering</strong></td>
<td>特徴量エンジニアリング</td>
<td>Process of designing and selecting descriptors suitable for machine learning from raw data. Critical step that determines model performance.</td>
</tr>
<tr>
<td><strong>3. Screening</strong></td>
<td>スクリーニング</td>
<td>Efficiently selecting materials with target properties from a large number of candidates. Computational screening can evaluate thousands to tens of thousands in a short time.</td>
</tr>
<tr>
<td><strong>4. Overfitting</strong></td>
<td>過学習</td>
<td>Phenomenon where a model "memorizes" training data, resulting in poor prediction performance on unseen data. Requires special attention in materials science with limited data.</td>
</tr>
<tr>
<td><strong>5. Cross-validation</strong></td>
<td>交差検証</td>
<td>Method to evaluate model generalization performance. Divides data into K parts, using one for testing and the rest for training, repeating K times.</td>
</tr>
<tr>
<td><strong>6. Ensemble Methods</strong></td>
<td>アンサンブル法</td>
<td>Methods that achieve higher accuracy by combining predictions from multiple models. Examples: Random Forest, Gradient Boosting.</td>
</tr>
<tr>
<td><strong>7. Validation</strong></td>
<td>検証</td>
<td>Process of confirming whether prediction results match actual material properties through experiment or high-accuracy calculations. Critical step to ensure MI reliability.</td>
</tr>
</tbody>
</table>
<h3 id="computational-methods-related-8-13">Computational Methods Related (8-13)</h3>
<table>
<thead>
<tr>
<th>Term (English)</th>
<th>Term (Japanese)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>8. DFT</strong></td>
<td>密度汎関数理論</td>
<td>Density Functional Theory. Method to calculate electronic states of materials based on quantum mechanics. Can theoretically predict material properties (bandgap, formation energy, etc.).</td>
</tr>
<tr>
<td><strong>9. Active Learning</strong></td>
<td>能動学習</td>
<td>Learning method where the model suggests "which data to acquire next". Can improve models while minimizing experimental costs.</td>
</tr>
<tr>
<td><strong>10. Bayesian Optimization</strong></td>
<td>ベイズ最適化</td>
<td>Method to search for optimal materials while minimizing the number of experiments. Uses Gaussian processes to determine next experimental candidates.</td>
</tr>
<tr>
<td><strong>11. Transfer Learning</strong></td>
<td>転移学習</td>
<td>Method of applying a model trained on one material system to a related but different material system. Enables high-accuracy predictions even for new material systems with limited data.</td>
</tr>
<tr>
<td><strong>12. Graph Neural Networks (GNN)</strong></td>
<td>グラフニューラルネットワーク</td>
<td>Neural networks that treat crystal structures as graphs (atoms=nodes, bonds=edges) and directly learn structural information. Recently gaining attention.</td>
</tr>
<tr>
<td><strong>13. High-throughput Computation</strong></td>
<td>ハイスループット計算</td>
<td>Method to automatically perform first-principles calculations on large numbers of materials. Materials Project evaluates over 140,000 materials through high-throughput computation.</td>
</tr>
</tbody>
</table>
<h3 id="materials-science-related-14-20">Materials Science Related (14-20)</h3>
<table>
<thead>
<tr>
<th>Term (English)</th>
<th>Term (Japanese)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>14. Crystal Structure</strong></td>
<td>結晶構造</td>
<td>Structure where atoms are arranged in a regular pattern. Types include FCC (face-centered cubic), BCC (body-centered cubic), HCP (hexagonal close-packed), etc.</td>
</tr>
<tr>
<td><strong>15. Space Group</strong></td>
<td>空間群</td>
<td>230 mathematical groups that classify the symmetry of crystal structures. Closely related to material properties.</td>
</tr>
<tr>
<td><strong>16. Bandgap</strong></td>
<td>バンドギャップ</td>
<td>In semiconductors and insulators, the energy difference between the occupied valence band and empty conduction band. Important for solar cell and semiconductor device design.</td>
</tr>
<tr>
<td><strong>17. Formation Energy</strong></td>
<td>形成エネルギー</td>
<td>Energy change when a material is generated from its constituent elements. Negative values indicate stable materials.</td>
</tr>
<tr>
<td><strong>18. Phase Diagram</strong></td>
<td>状態図</td>
<td>Diagram showing which phase (solid, liquid, gas) a material exists in as a function of temperature, pressure, and composition. Essential for alloy design.</td>
</tr>
<tr>
<td><strong>19. Multi-objective Optimization</strong></td>
<td>多目的最適化</td>
<td>Method to simultaneously optimize multiple properties (e.g., lightweight and strength). Balances properties that typically have trade-off relationships.</td>
</tr>
<tr>
<td><strong>20. Pareto Front</strong></td>
<td>パレートフロント</td>
<td>In multi-objective optimization, the set of solutions that are not optimal in all objectives but cannot be improved in any objective without compromising another. Represents candidate optimal materials.</td>
</tr>
</tbody>
</table>
<p><strong>Key Points for Learning Terminology:</strong><br />
- First prioritize understanding 1-7 (Data &amp; Model related)<br />
- Learn 8-13 (Computational methods) in detail at intermediate level<br />
- Review 14-20 (Materials science) together with basic materials science knowledge</p>
<hr />
<h2 id="23-overview-of-materials-databases">2.3 Overview of Materials Databases</h2>
<p>Let's compare the four major materials databases that form the foundation of MI in detail.</p>
<h3 id="231-detailed-comparison-of-major-databases">2.3.1 Detailed Comparison of Major Databases</h3>
<table>
<thead>
<tr>
<th>Database Name</th>
<th>Number of Materials</th>
<th>Data Source</th>
<th>Main Property Data</th>
<th>Access Method</th>
<th>Advantages</th>
<th>Use Case Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Materials Project</strong></td>
<td>140,000+</td>
<td>DFT calculations (VASP)</td>
<td>Bandgap, formation energy, elastic constants, phase stability</td>
<td>Web UI, API (Python: <code>pymatgen</code>)</td>
<td>Largest scale, active community, rich tools</td>
<td>Battery materials, semiconductors, structural materials</td>
</tr>
<tr>
<td><strong>AFLOW</strong></td>
<td>3,500,000+</td>
<td>DFT calculations (VASP)</td>
<td>Crystal structures, electronic structures, thermodynamic stability</td>
<td>Web UI, API (RESTful)</td>
<td>Most crystal structure data, standardized naming conventions</td>
<td>Crystal structure exploration, novel structure prediction</td>
</tr>
<tr>
<td><strong>OQMD</strong></td>
<td>1,000,000+</td>
<td>DFT calculations (VASP)</td>
<td>Formation energy, stability, phase diagrams</td>
<td>Web UI, API (Python: <code>qmpy</code>)</td>
<td>Strong in phase diagram calculations, rich alloy data</td>
<td>Alloy design, phase stability evaluation</td>
</tr>
<tr>
<td><strong>JARVIS</strong></td>
<td>70,000+</td>
<td>DFT calculations (VASP)<br>Machine learning predictions</td>
<td>Optical properties, mechanical properties, topological properties</td>
<td>Web UI, API (Python: <code>jarvis-tools</code>)</td>
<td>Diverse properties, provides ML models</td>
<td>Optical materials, topological materials</td>
</tr>
</tbody>
</table>
<h3 id="232-how-to-use-different-databases">2.3.2 How to Use Different Databases</h3>
<p><strong>1. Materials Project</strong><br />
- <strong>When to use</strong>: Exploration of battery materials, semiconductors, general inorganic materials<br />
- <strong>Strengths</strong>:<br />
  - Intuitive Web UI, beginner-friendly<br />
  - Rich Python library (<code>pymatgen</code>)<br />
  - Active community with abundant information<br />
- <strong>Weaknesses</strong>: Lower coverage for some structure types</p>
<p><strong>2. AFLOW</strong><br />
- <strong>When to use</strong>: Exploration of novel crystal structures, structural similarity search<br />
- <strong>Strengths</strong>:<br />
  - Most crystal structures (3.5 million types)<br />
  - Standardized crystal structure description (AFLOW prototype)<br />
  - Fast structural similarity search<br />
- <strong>Weaknesses</strong>: Fewer types of property data than Materials Project</p>
<p><strong>3. OQMD</strong><br />
- <strong>When to use</strong>: Phase diagram calculations for alloys, detailed phase stability evaluation<br />
- <strong>Strengths</strong>:<br />
  - Specialized in phase diagram calculations<br />
  - Rich multi-component alloy data<br />
  - Temperature-dependent evaluation possible<br />
- <strong>Weaknesses</strong>: Less user-friendly Web UI</p>
<p><strong>4. JARVIS</strong><br />
- <strong>When to use</strong>: Optical materials, topological materials, using ML models<br />
- <strong>Strengths</strong>:<br />
  - Integrated machine learning models<br />
  - Rich optical properties (permittivity, refractive index)<br />
  - Topological property calculations<br />
- <strong>Weaknesses</strong>: Fewer materials than others</p>
<h3 id="233-practical-examples-of-database-utilization">2.3.3 Practical Examples of Database Utilization</h3>
<p><strong>Scenario 1: Finding novel cathode materials for lithium-ion batteries</strong></p>
<ol>
<li>
<p><strong>Search in Materials Project</strong>:<br />
   - Conditions: Contains Li, voltage 3.5-4.5V, stable<br />
   - Candidates: 100 types found</p>
</li>
<li>
<p><strong>Select top 10 types</strong>:<br />
   - Evaluate based on balance of capacity, voltage, stability</p>
</li>
<li>
<p><strong>Confirm phase stability in OQMD</strong>:<br />
   - Check possibility of decomposition with temperature changes</p>
</li>
<li>
<p><strong>Experimental validation</strong>:<br />
   - Actually synthesize top 3 types</p>
</li>
</ol>
<p><strong>Scenario 2: Finding transparent conductive materials (for solar cells)</strong></p>
<ol>
<li>
<p><strong>Search in JARVIS</strong>:<br />
   - Conditions: Bandgap &gt; 3.0 eV (transparent), high electrical conductivity<br />
   - Candidates: 50 types</p>
</li>
<li>
<p><strong>Additional information from Materials Project</strong>:<br />
   - Confirm formation energy, thermal stability</p>
</li>
<li>
<p><strong>Search for similar structures in AFLOW</strong>:<br />
   - Find structures similar to promising materials found</p>
</li>
<li>
<p><strong>Experimental validation</strong></p>
</li>
</ol>
<h3 id="234-example-of-database-access">2.3.4 Example of Database Access</h3>
<p><strong>Materials Project API (Python) usage example:</strong></p>
<pre class="codehilite"><code class="language-python">from pymatgen.ext.matproj import MPRester

# Get API key: https://materialsproject.org
with MPRester(&quot;YOUR_API_KEY&quot;) as mpr:
    # Get LiCoO2 information
    data = mpr.get_data(&quot;mp-1234&quot;)  # material_id

    print(f&quot;Chemical formula: {data[0]['pretty_formula']}&quot;)
    print(f&quot;Bandgap: {data[0]['band_gap']} eV&quot;)
    print(f&quot;Formation energy: {data[0]['formation_energy_per_atom']} eV/atom&quot;)
</code></pre>

<p><strong>Important Points:</strong><br />
- Each database has a complementary relationship<br />
- Using multiple databases together is recommended, not just one<br />
- Important to compare results across different databases to ensure data reliability</p>
<hr />
<h2 id="24-mi-ecosystem-data-flow">2.4 MI Ecosystem: Data Flow</h2>
<p>MI is not a standalone technology but an ecosystem where multiple elements collaborate. The following diagram shows the data flow in MI.</p>
<pre class="codehilite"><code class="language-mermaid">graph TB
    subgraph &quot;Data Generation&quot;
        A[Experimental Data] --&gt; D[Materials Database]
        B[First-principles Calculation&lt;br&gt;DFT] --&gt; D
        C[Papers/Patents] --&gt; D
    end

    subgraph &quot;Data Processing&quot;
        D --&gt; E[Data Cleaning&lt;br&gt;Standardization]
        E --&gt; F[Descriptor Generation&lt;br&gt;Feature Engineering]
    end

    subgraph &quot;Machine Learning&quot;
        F --&gt; G[Model Training&lt;br&gt;Regression/Classification]
        G --&gt; H[Prediction/Screening&lt;br&gt;Thousands to tens of thousands]
    end

    subgraph &quot;Experimental Validation&quot;
        H --&gt; I[Candidate Selection&lt;br&gt;Top 10-100]
        I --&gt; J[Experimental Synthesis/Measurement]
        J --&gt; K{Prediction&lt;br&gt;Accurate?}
    end

    subgraph &quot;Continuous Improvement&quot;
        K --&gt;|Yes| L[Add as New Data]
        K --&gt;|No| M[Model Improvement/Retraining]
        L --&gt; D
        M --&gt; G
    end

    style D fill:#e3f2fd
    style F fill:#fff3e0
    style G fill:#f3e5f5
    style J fill:#e8f5e9
    style L fill:#fce4ec
</code></pre>

<p><strong>How to Read the Diagram:</strong><br />
1. <strong>Data Generation</strong>: Collect data from experiments, calculations, literature<br />
2. <strong>Data Processing</strong>: Convert raw data into formats suitable for machine learning<br />
3. <strong>Machine Learning</strong>: Train models and predict large numbers of candidates<br />
4. <strong>Experimental Validation</strong>: Experimentally verify promising candidates<br />
5. <strong>Continuous Improvement</strong>: Add results to data and improve models</p>
<p><strong>Importance of Feedback Loop:</strong><br />
- Accurate prediction → Add data to further improve model<br />
- Inaccurate prediction → Review model, change descriptors or learning methods<br />
- Model accuracy improves by repeating this cycle</p>
<hr />
<h2 id="25-basic-mi-workflow-detailed-version">2.5 Basic MI Workflow: Detailed Version</h2>
<p>Chapter 1 introduced a 4-step workflow, but here we expand to a more practical <strong>5-step</strong> approach.</p>
<h3 id="251-overview">2.5.1 Overview</h3>
<pre class="codehilite"><code class="language-mermaid">graph LR
    A[Step 0:&lt;br&gt;Problem Formulation] --&gt; B[Step 1:&lt;br&gt;Data Collection]
    B --&gt; C[Step 2:&lt;br&gt;Model Building]
    C --&gt; D[Step 3:&lt;br&gt;Prediction/Screening]
    D --&gt; E[Step 4:&lt;br&gt;Experimental Validation]
    E --&gt; F[Step 5:&lt;br&gt;Data Addition/Improvement]
    F -.Continuous Improvement.-&gt; B

    style A fill:#ffebee
    style B fill:#e3f2fd
    style C fill:#fff3e0
    style D fill:#f3e5f5
    style E fill:#e8f5e9
    style F fill:#fce4ec
</code></pre>

<h3 id="252-step-0-problem-formulation-most-important-often-overlooked">2.5.2 Step 0: Problem Formulation (Most Important, Often Overlooked)</h3>
<p><strong>What to do:</strong><br />
- Clearly define the problem to solve<br />
- Specify target properties and constraints<br />
- Set success criteria</p>
<p><strong>Concrete Example: Battery Material Development</strong></p>
<p><strong>Poor problem formulation:</strong></p>
<blockquote>
<p>"I want to find good battery materials"</p>
</blockquote>
<p><strong>Good problem formulation:</strong></p>
<blockquote>
<p>"Discover materials with the following properties as cathode materials for lithium-ion batteries:<br />
- Theoretical capacity: ≥200 mAh/g<br />
- Operating voltage: 3.5-4.5 V vs. Li/Li+<br />
- Cycle life: Capacity retention ≥80% after 500 cycles<br />
- Cost: ≤$50/kg (raw materials basis)<br />
- Safety: Thermal runaway temperature ≥200°C<br />
- Environmental constraint: Minimize Co usage (ideally Co-free)"</p>
</blockquote>
<p><strong>Problem Formulation Checklist:</strong><br />
- [ ] Are target properties quantitatively defined?<br />
- [ ] Are constraints (cost, environment, safety) clear?<br />
- [ ] Are success criteria measurable?<br />
- [ ] Is it experimentally verifiable?</p>
<p><strong>Time estimate:</strong> 1-2 weeks (including literature review and expert discussions)</p>
<p><strong>Common Failures:</strong><br />
- Vague goals that change repeatedly later<br />
- Ignore constraints and end up searching for infeasible materials<br />
- No success criteria, so exploration never ends</p>
<h3 id="253-step-1-data-collection">2.5.3 Step 1: Data Collection</h3>
<p><strong>What to do:</strong><br />
- Collect material information from existing experimental data and literature<br />
- Download relevant data from materials databases<br />
- Add data through first-principles calculations if necessary</p>
<p><strong>Priority of Data Sources:</strong><br />
1. <strong>Existing Databases</strong> (Most efficient)<br />
   - Materials Project, AFLOW, OQMD<br />
   - High reliability, immediately usable</p>
<ol start="2">
<li>
<p><strong>Papers/Patents</strong> (Manual work required)<br />
   - Google Scholar, Web of Science<br />
   - May contain experimental data</p>
</li>
<li>
<p><strong>Self-calculate/measure</strong> (Time-consuming)<br />
   - Generate new material data through DFT calculations<br />
   - Laboratory measurements</p>
</li>
</ol>
<p><strong>Concrete Example: Lithium-ion Battery Cathode Materials</strong></p>
<pre class="codehilite"><code class="language-python">from pymatgen.ext.matproj import MPRester
import pandas as pd

# Search for Li-containing oxides from Materials Project
with MPRester(&quot;YOUR_API_KEY&quot;) as mpr:
    # Search criteria
    criteria = {
        &quot;elements&quot;: {&quot;$all&quot;: [&quot;Li&quot;, &quot;O&quot;]},  # Must contain Li and O
        &quot;nelements&quot;: {&quot;$gte&quot;: 2, &quot;$lte&quot;: 4},  # 2-4 elements
        &quot;e_above_hull&quot;: {&quot;$lte&quot;: 0.05}  # Stable or metastable
    }

    # Properties to retrieve
    properties = [
        &quot;material_id&quot;,
        &quot;pretty_formula&quot;,
        &quot;formation_energy_per_atom&quot;,
        &quot;energy_above_hull&quot;,
        &quot;band_gap&quot;,
        &quot;density&quot;
    ]

    # Get data
    results = mpr.query(criteria, properties)

    # Convert to DataFrame
    df = pd.DataFrame(results)

    print(f&quot;Number of materials retrieved: {len(df)}&quot;)
    print(df.head())
</code></pre>

<p><strong>Expected Results:</strong><br />
- Data for hundreds to thousands of candidate materials<br />
- Basic properties of each material (composition, formation energy, bandgap, etc.)</p>
<p><strong>Time Estimate:</strong><br />
- Database use: Several hours to days<br />
- Literature review: 1-2 weeks<br />
- DFT calculations: Several weeks to months (depends on number of materials)</p>
<p><strong>Common Problems:</strong><br />
- Missing data (specific properties available only for some materials)<br />
- Data inconsistency (values differ between different databases)<br />
- Data bias (biased toward specific material systems)</p>
<p><strong>Solutions:</strong><br />
- Compare multiple databases to verify reliability<br />
- Consider imputation methods for missing values (mean, ML estimation, etc.)<br />
- Recognize data bias and clarify model applicability range</p>
<h3 id="254-step-2-model-building">2.5.4 Step 2: Model Building</h3>
<p><strong>What to do:</strong><br />
- Train machine learning models using collected data<br />
- Select appropriate descriptors (features)<br />
- Evaluate and optimize model performance</p>
<p><strong>Sub-steps:</strong></p>
<p><strong>2.1 Descriptor Design</strong></p>
<p>Need to convert materials into numerical vectors.</p>
<p><strong>Types of Descriptors:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Concrete Examples</th>
<th>Advantages</th>
<th>Disadvantages</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Composition-based</strong></td>
<td>Element electronegativity, atomic radius, atomic weight</td>
<td>Easy to calculate, interpretable</td>
<td>Ignores structural information</td>
</tr>
<tr>
<td><strong>Structure-based</strong></td>
<td>Lattice constants, space group, coordination number</td>
<td>Captures structure-property relationships</td>
<td>Requires crystal structure data</td>
</tr>
<tr>
<td><strong>Property-based</strong></td>
<td>Melting point, density, bandgap</td>
<td>Utilizes property correlations</td>
<td>Difficult to apply to unknown materials</td>
</tr>
</tbody>
</table>
<p><strong>Descriptor Example: Numerical Representation of LiCoO2</strong></p>
<pre class="codehilite"><code class="language-python"># Simple example: Composition-based descriptors
material = &quot;LiCoO2&quot;

# Fraction of each element
Li_fraction = 0.25  # 1/(1+1+2)
Co_fraction = 0.25
O_fraction = 0.50

# Element properties (from periodic table)
electronegativity_Li = 0.98
electronegativity_Co = 1.88
electronegativity_O = 3.44

# Weighted average
avg_electronegativity = (
    Li_fraction * electronegativity_Li +
    Co_fraction * electronegativity_Co +
    O_fraction * electronegativity_O
)  # = 2.38

# Vector representation
descriptor_vector = [
    Li_fraction, Co_fraction, O_fraction,  # Composition
    avg_electronegativity,  # Electronegativity
    # ... Add other properties
]
</code></pre>

<p><strong>In actual projects, use the <code>matminer</code> library:</strong></p>
<pre class="codehilite"><code class="language-python">from matminer.featurizers.composition import ElementProperty

# Automatically generate numerous descriptors
featurizer = ElementProperty.from_preset(&quot;magpie&quot;)
features = featurizer.featurize_dataframe(df, col_id=&quot;composition&quot;)
</code></pre>

<p><strong>2.2 Model Selection</strong></p>
<p><strong>Beginner-friendly Models:</strong><br />
- <strong>Linear Regression</strong>: Simple, interpretable<br />
- <strong>Decision Tree</strong>: Visualizable, captures non-linear relationships</p>
<p><strong>Intermediate Models:</strong><br />
- <strong>Random Forest</strong>: High accuracy, robust to overfitting<br />
- <strong>Gradient Boosting (XGBoost, LightGBM)</strong>: Highest accuracy</p>
<p><strong>Advanced Models:</strong><br />
- <strong>Neural Networks</strong>: Learn complex non-linear relationships<br />
- <strong>Graph Neural Networks (GNN)</strong>: Directly learn crystal structures</p>
<p><strong>2.3 Training and Evaluation</strong></p>
<pre class="codehilite"><code class="language-python">from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, r2_score

# Data split
X = features  # Descriptors
y = df['target_property']  # Example: voltage

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# Model training
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Prediction
y_pred = model.predict(X_test)

# Evaluation
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f&quot;MAE: {mae:.3f}&quot;)
print(f&quot;R²: {r2:.3f}&quot;)

# Cross-validation (more reliable evaluation)
cv_scores = cross_val_score(model, X, y, cv=5, scoring='neg_mean_absolute_error')
print(f&quot;CV MAE: {-cv_scores.mean():.3f} ± {cv_scores.std():.3f}&quot;)
</code></pre>

<p><strong>Performance Guidelines:</strong><br />
- <strong>R² &gt; 0.8</strong>: Good<br />
- <strong>R² &gt; 0.9</strong>: Excellent<br />
- <strong>R² &lt; 0.5</strong>: Model needs revision</p>
<p><strong>Time Estimate:</strong><br />
- Descriptor design: Several days to 1 week<br />
- Model training and optimization: 1-2 weeks</p>
<p><strong>Common Problems:</strong><br />
- Overfitting (high accuracy on training data but low on test data)<br />
- Poor descriptor selection (missing important features)</p>
<p><strong>Solutions:</strong><br />
- Verify generalization performance with cross-validation<br />
- Analyze feature importance and remove unnecessary descriptors<br />
- Introduce regularization (L1/L2)</p>
<h3 id="255-step-3-predictionscreening">2.5.5 Step 3: Prediction/Screening</h3>
<p><strong>What to do:</strong><br />
- Predict properties of unknown materials using trained model<br />
- Evaluate large numbers of candidate materials (thousands to tens of thousands) in a short time<br />
- Select promising top candidates</p>
<p><strong>Screening Flow:</strong></p>
<pre class="codehilite"><code>Candidate materials: 10,000 types (generated by calculations)
  ↓ (Predict with ML: minutes)
Rank by predicted values
  ↓
Select top 1,000 (close to target properties)
  ↓ (Detailed calculation/evaluation: hours to days)
Narrow down to top 100
  ↓
Materials to experiment: Top 10 (most promising candidates)
</code></pre>

<p><strong>Concrete Code Example:</strong></p>
<pre class="codehilite"><code class="language-python">import numpy as np

# Generate candidate material list (example: create candidates by varying composition)
# Actually use more systematic methods
candidate_compositions = [...]  # 10,000 items

# Calculate descriptors for each candidate
candidate_features = compute_descriptors(candidate_compositions)

# Predict with model
predicted_properties = model.predict(candidate_features)

# Rank (example: by highest voltage)
ranked_indices = np.argsort(predicted_properties)[::-1]

# Select top 100
top_100 = [candidate_compositions[i] for i in ranked_indices[:100]]

print(&quot;Top 10 candidates:&quot;)
for i, comp in enumerate(top_100[:10]):
    pred_val = predicted_properties[ranked_indices[i]]
    print(f&quot;{i+1}. {comp}: Predicted value = {pred_val:.2f}&quot;)
</code></pre>

<p><strong>Efficiency Example:</strong><br />
- <strong>Traditional</strong>: Evaluate 10,000 types experimentally → About 30 years (1 per day)<br />
- <strong>MI</strong>: Evaluate 10 types experimentally → About 2 weeks<br />
- <strong>Time reduction rate</strong>: 99.9%</p>
<p><strong>Time Estimate:</strong><br />
- Prediction calculation: Minutes to hours (depends on number of candidates)<br />
- Result analysis: Several days</p>
<p><strong>Cautions:</strong><br />
- Predictions are just predictions. Must validate experimentally<br />
- Prediction accuracy is low for materials outside model applicability range (materials very different from training data)<br />
- More reliable with uncertainty evaluation (Bayesian methods)</p>
<h3 id="256-step-4-experimental-validation">2.5.6 Step 4: Experimental Validation</h3>
<p><strong>What to do:</strong><br />
- Actually synthesize materials narrowed down by prediction<br />
- Measure properties and verify if predictions were correct<br />
- Analyze discrepancies between predictions and measurements</p>
<p><strong>Experimental Priority:</strong><br />
1. <strong>Materials with highest predicted values</strong> (Best case)<br />
2. <strong>Materials with moderate predicted values but low uncertainty</strong> (Safe choice)<br />
3. <strong>Materials with high predicted values but also high uncertainty</strong> (High risk, high return)</p>
<p><strong>Validation Checklist:</strong><br />
- [ ] Are synthesis conditions established?<br />
- [ ] Are measurement instruments available?<br />
- [ ] Does measurement accuracy meet target property requirements?<br />
- [ ] Reproducibility confirmation (multiple measurements)</p>
<p><strong>Time Estimate:</strong><br />
- Synthesis: Several days to weeks (depends on material)<br />
- Measurement: Several days to 1 week<br />
- Total: 2-3 months for top 10</p>
<p><strong>Judging Success and Failure:</strong></p>
<table>
<thead>
<tr>
<th>Result</th>
<th>Judgment</th>
<th>Next Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>Prediction matches measurement</td>
<td>Success</td>
<td>Add to data, explore further</td>
</tr>
<tr>
<td>Better than prediction</td>
<td>Great success</td>
<td>Analyze model to investigate why it underestimated</td>
</tr>
<tr>
<td>Worse than prediction</td>
<td>Partial failure</td>
<td>Review descriptors and model</td>
</tr>
<tr>
<td>Completely different</td>
<td>Failure</td>
<td>Possibly outside model applicability. Reconsider data and model</td>
</tr>
</tbody>
</table>
<p><strong>Important Points:</strong><br />
- Failures are also valuable data. Always add to database<br />
- Analyzing causes of prediction-measurement discrepancies improves models</p>
<h3 id="257-step-5-data-additionmodel-improvement">2.5.7 Step 5: Data Addition/Model Improvement</h3>
<p><strong>What to do:</strong><br />
- Add experimental results (both success and failure) to database<br />
- Retrain model with new data<br />
- Verify improved prediction accuracy</p>
<p><strong>Continuous Improvement Cycle:</strong></p>
<pre class="codehilite"><code>Initial model (R² = 0.75)
  ↓
Add 10 experimental results
  ↓
Model retraining (R² = 0.82)
  ↓
10 more experiments
  ↓
Model retraining (R² = 0.88)
  ↓
Finally discover optimal material
</code></pre>

<p><strong>Active Learning Application:</strong></p>
<p>In typical MI, materials with high predicted values are experimented on, but in <strong>active learning</strong>, the model suggests "materials with high uncertainty".</p>
<pre class="codehilite"><code class="language-python"># Estimate uncertainty with Random Forest
predictions = []
for tree in model.estimators_:
    pred = tree.predict(candidate_features)
    predictions.append(pred)

predictions = np.array(predictions)
uncertainty = predictions.std(axis=0)  # High std = high uncertainty

# Prioritize materials with high uncertainty for experiment
high_uncertainty_indices = np.argsort(uncertainty)[::-1]
next_experiment = candidate_compositions[high_uncertainty_indices[0]]
</code></pre>

<p><strong>Time Estimate:</strong> 1-2 weeks per cycle</p>
<p><strong>Termination Conditions:</strong><br />
- Found materials satisfying target properties<br />
- Prediction accuracy sufficiently high (R² &gt; 0.9)<br />
- Budget/time constraints</p>
<hr />
<h2 id="26-details-of-materials-descriptors">2.6 Details of Materials Descriptors</h2>
<h3 id="261-types-of-descriptors-and-concrete-examples">2.6.1 Types of Descriptors and Concrete Examples</h3>
<p><strong>1. Composition-based Descriptors</strong></p>
<p><strong>Characteristics:</strong><br />
- Calculable from chemical formula alone<br />
- Usable even when crystal structure is unknown<br />
- Low computational cost</p>
<p><strong>Concrete Examples:</strong></p>
<table>
<thead>
<tr>
<th>Descriptor</th>
<th>Description</th>
<th>Example (LiCoO2)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Average electronegativity</td>
<td>Weighted average of element electronegativities</td>
<td>2.38</td>
</tr>
<tr>
<td>Average atomic radius</td>
<td>Weighted average of element atomic radii</td>
<td>1.15 Å</td>
</tr>
<tr>
<td>Number of element types</td>
<td>Number of constituent elements</td>
<td>3 (Li, Co, O)</td>
</tr>
<tr>
<td>Average atomic weight</td>
<td>Weighted average of element atomic weights</td>
<td>30.8 g/mol</td>
</tr>
<tr>
<td>Electronegativity difference</td>
<td>Difference between max and min electronegativity</td>
<td>2.46 (O - Li)</td>
</tr>
</tbody>
</table>
<p><strong>2. Structure-based Descriptors</strong></p>
<p><strong>Characteristics:</strong><br />
- Utilize crystal structure information<br />
- Capture structure-property relationships<br />
- Require crystal structure data</p>
<p><strong>Concrete Examples:</strong></p>
<table>
<thead>
<tr>
<th>Descriptor</th>
<th>Description</th>
<th>Example (LiCoO2)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lattice constants</td>
<td>Unit cell lengths a, b, c</td>
<td>a=2.82 Å, c=14.05 Å (hexagonal)</td>
</tr>
<tr>
<td>Space group</td>
<td>Crystal symmetry</td>
<td>R-3m (166)</td>
</tr>
<tr>
<td>Coordination number</td>
<td>Number of neighboring atoms around an atom</td>
<td>Co: 6-coordinated (surrounded by oxygen)</td>
</tr>
<tr>
<td>Bond distance</td>
<td>Distance between adjacent atoms</td>
<td>Co-O: 1.93 Å</td>
</tr>
<tr>
<td>Density</td>
<td>Mass per unit volume</td>
<td>5.06 g/cm³</td>
</tr>
</tbody>
</table>
<p><strong>3. Property-based Descriptors</strong></p>
<p><strong>Characteristics:</strong><br />
- Predict unknown properties from known properties<br />
- Utilize property correlations<br />
- Difficult to apply to unknown materials</p>
<p><strong>Concrete Examples:</strong></p>
<table>
<thead>
<tr>
<th>Descriptor</th>
<th>Description</th>
<th>Example (LiCoO2)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Melting point</td>
<td>Solid-to-liquid phase transition temperature</td>
<td>~1200 K</td>
</tr>
<tr>
<td>Bandgap</td>
<td>Energy gap in electronic structure</td>
<td>~2.7 eV (insulator)</td>
</tr>
<tr>
<td>Formation energy</td>
<td>Energy when generated from elements</td>
<td>-2.5 eV/atom (stable)</td>
</tr>
<tr>
<td>Elastic modulus</td>
<td>Material hardness/resistance to deformation</td>
<td>150 GPa</td>
</tr>
<tr>
<td>Thermal conductivity</td>
<td>Ease of heat transfer</td>
<td>5 W/(m·K)</td>
</tr>
</tbody>
</table>
<h3 id="262-automatic-descriptor-generation-using-matminer">2.6.2 Automatic Descriptor Generation (Using Matminer)</h3>
<pre class="codehilite"><code class="language-python">from matminer.featurizers.composition import ElementProperty, Stoichiometry
from matminer.featurizers.structure import DensityFeatures
from pymatgen.core import Composition

# Automatic generation of composition-based descriptors
comp = Composition(&quot;LiCoO2&quot;)

# Example 1: Element property-based descriptors (73 types)
element_featurizer = ElementProperty.from_preset(&quot;magpie&quot;)
element_features = element_featurizer.featurize(comp)

print(f&quot;Number of generated descriptors: {len(element_features)}&quot;)
print(f&quot;Example descriptors: {element_features[:5]}&quot;)

# Example 2: Composition ratio-based descriptors
stoich_featurizer = Stoichiometry()
stoich_features = stoich_featurizer.featurize(comp)

print(f&quot;Composition ratio descriptors: {stoich_features}&quot;)
</code></pre>

<p><strong>Descriptors Generated by Matminer (partial list):</strong><br />
- Average electronegativity, atomic radius, atomic weight<br />
- Element position on periodic table (group, period)<br />
- Electronic configuration (s-orbital electrons, p-orbital electrons, etc.)<br />
- Average and variance of oxidation states<br />
- Number of valence electrons</p>
<h3 id="263-descriptor-selection-and-feature-engineering">2.6.3 Descriptor Selection and Feature Engineering</h3>
<p><strong>Not all descriptors are useful:</strong><br />
- Irrelevant descriptors → Become noise and degrade model performance<br />
- Redundant descriptors → Waste of computational cost</p>
<p><strong>Descriptor Selection Methods:</strong></p>
<p><strong>1. Feature Importance</strong></p>
<pre class="codehilite"><code class="language-python">import matplotlib.pyplot as plt
import pandas as pd

# Random Forest feature importance
importances = model.feature_importances_
feature_names = X.columns

# Sort by importance
indices = np.argsort(importances)[::-1]

# Visualize top 20
plt.figure(figsize=(10, 6))
plt.bar(range(20), importances[indices[:20]])
plt.xticks(range(20), [feature_names[i] for i in indices[:20]], rotation=90)
plt.xlabel(&quot;Feature&quot;)
plt.ylabel(&quot;Importance&quot;)
plt.title(&quot;Feature Importance Top 20&quot;)
plt.tight_layout()
plt.show()
</code></pre>

<p><strong>2. Correlation Analysis</strong></p>
<pre class="codehilite"><code class="language-python"># Correlation matrix between features
correlation_matrix = X.corr()

# Remove feature pairs with high correlation (&gt;0.9)
high_corr_pairs = []
for i in range(len(correlation_matrix.columns)):
    for j in range(i+1, len(correlation_matrix.columns)):
        if abs(correlation_matrix.iloc[i, j]) &gt; 0.9:
            high_corr_pairs.append((correlation_matrix.columns[i],
                                   correlation_matrix.columns[j]))

print(f&quot;High correlation pairs: {len(high_corr_pairs)}&quot;)
</code></pre>

<p><strong>3. Recursive Feature Elimination (RFE)</strong></p>
<pre class="codehilite"><code class="language-python">from sklearn.feature_selection import RFE

# Select best 50 features
selector = RFE(model, n_features_to_select=50, step=1)
selector.fit(X_train, y_train)

selected_features = X.columns[selector.support_]
print(f&quot;Selected features: {list(selected_features)}&quot;)
</code></pre>

<hr />
<h2 id="27-summary">2.7 Summary</h2>
<h3 id="what-we-learned-in-this-chapter">What We Learned in This Chapter</h3>
<ol>
<li>
<p><strong>Definition and Positioning of MI</strong><br />
   - Fusion of materials science and data science<br />
   - Efficiency through inverse design approach<br />
   - Differences from computational materials science and cheminformatics</p>
</li>
<li>
<p><strong>20 MI Terms</strong><br />
   - Data/model related (descriptors, feature engineering, overfitting, etc.)<br />
   - Computational methods related (DFT, Bayesian optimization, GNN, etc.)<br />
   - Materials science related (crystal structure, bandgap, phase diagram, etc.)</p>
</li>
<li>
<p><strong>Materials Databases</strong><br />
   - Materials Project: Largest scale, beginner-friendly<br />
   - AFLOW: Most crystal structure data<br />
   - OQMD: Strong in phase diagram calculations<br />
   - JARVIS: Integrated machine learning models<br />
   - Using multiple databases together is recommended</p>
</li>
<li>
<p><strong>MI Ecosystem</strong><br />
   - Cycle of data generation → processing → machine learning → experimental validation → improvement<br />
   - Feedback loop is important</p>
</li>
<li>
<p><strong>MI 5-Step Workflow</strong><br />
   - Step 0: Problem formulation (most important)<br />
   - Step 1: Data collection (databases, literature, computation)<br />
   - Step 2: Model building (descriptor design, training, evaluation)<br />
   - Step 3: Prediction/screening (efficiently evaluate large candidates)<br />
   - Step 4: Experimental validation (synthesis/measurement of top candidates)<br />
   - Step 5: Data addition/improvement (continuous improvement cycle)</p>
</li>
<li>
<p><strong>Details of Materials Descriptors</strong><br />
   - Three types: composition-based, structure-based, property-based<br />
   - Automatic generation with Matminer<br />
   - Importance of feature selection</p>
</li>
</ol>
<h3 id="to-the-next-chapter">To the Next Chapter</h3>
<p>In Chapter 3, we'll put this knowledge into practice. Using actual Python code, you'll experience the entire flow from data acquisition from materials databases, descriptor generation, machine learning model building, to prediction.</p>
<hr />
<h2 id="exercise-problems">Exercise Problems</h2>
<h3 id="problem-1-difficulty-easy">Problem 1 (Difficulty: easy)</h3>
<p>Select 5 terms from the MI glossary and explain them in your own words.</p>
<details>
<summary>Sample Answer</summary>

**1. Descriptor**
Numerical representation of material features so they can be input into machine learning models. Examples include element electronegativity and atomic radius.

**2. Screening**
Efficiently narrowing down materials with target properties from a large number of candidates. MI can evaluate thousands to tens of thousands computationally in a short time.

**3. Overfitting**
Phenomenon where a machine learning model memorizes training data, resulting in poor prediction performance on new data. Can be detected with cross-validation.

**4. Bandgap**
In semiconductors, the energy difference between the occupied valence band and empty conduction band. Important metric for solar cell design.

**5. Bayesian Optimization**
Method to search for optimal materials while minimizing the number of experiments. AI suggests which material to experiment on next.

</details>

<h3 id="problem-2-difficulty-medium">Problem 2 (Difficulty: medium)</h3>
<p>Regarding the use of Materials Project vs AFLOW, answer which to use for the following scenarios with reasons.</p>
<p><strong>Scenario A</strong>: Want to search for novel lithium-ion battery cathode materials. Need bandgap and formation energy data.</p>
<p><strong>Scenario B</strong>: Want to find novel materials with similar crystal structures to existing materials. Need structural similarity search.</p>
<details>
<summary>Sample Answer</summary>

**Scenario A: Use Materials Project**

**Reasons:**
- Materials Project has over 140,000 material data with both bandgap and formation energy available
- Rich tools specialized for battery materials research (voltage, capacity calculations, etc.)
- Well-developed Python library (pymatgen) for easy data acquisition
- Intuitive Web UI, user-friendly even for beginners

**Scenario B: Use AFLOW**

**Reasons:**
- AFLOW has the most crystal structure data with 3.5 million types
- Fast and accurate structural similarity search functionality
- Easy to search for similar structures due to standardized structure description via AFLOW prototype
- Rich tools specialized for structure exploration

**Summary:**
Materials Project is suitable when emphasizing property data, AFLOW when emphasizing structure exploration. In actual projects, often both are used together.

</details>

<h3 id="problem-3-difficulty-medium">Problem 3 (Difficulty: medium)</h3>
<p>Explain why Step 0 (problem formulation) in the MI workflow is most important, with concrete examples.</p>
<details>
<summary>Hint</summary>

When problem formulation is vague, it affects all subsequent steps. Consider the importance of clarifying target properties, constraints, and success criteria.

</details>

<details>
<summary>Sample Answer</summary>

**Importance of Problem Formulation:**

When problem formulation is insufficient, the following problems occur.

**Bad Example:**
> "I want to find high-performance catalyst materials"

**Problems:**
- "High-performance" is not defined (reaction rate? selectivity? durability?)
- No constraints (cost, toxicity, availability)
- Success criteria unclear (how long to continue exploration?)

**Results:**
1. Waste time in data collection (collect even unrelated data)
2. Model optimizes wrong objectives
3. Realize at experimental stage that "actually a different property was important" and restart

**Good Example:**
> "Discover materials with the following properties as catalyst materials for hydrogen production:
> - Reaction rate: ≥100 mol H2/(m²·h)
> - Selectivity: ≥95% (suppress byproducts other than hydrogen)
> - Durability: Activity maintained at ≥80% after 1000 hours continuous operation
> - Cost: ≤$100/kg
> - Constraint: Minimize use of precious metals like Pt, Pd"

**Effects:**
1. Data collection is clear (prioritize reaction rate, selectivity, durability data)
2. Model optimizes correct objectives
3. Success criteria are clear, easy to evaluate project progress
4. Easy to prioritize experiments

**Value of Time Investment:**
Spending 1-2 weeks on problem formulation can significantly reduce the risk of wasting months to years of subsequent work.

</details>

<h3 id="problem-4-difficulty-hard">Problem 4 (Difficulty: hard)</h3>
<p>There are three types of material descriptors: composition-based, structure-based, and property-based. List the advantages and disadvantages of each, and explain in what situations each should be used.</p>
<details>
<summary>Hint</summary>

Consider the trade-offs between computational cost, required data, and prediction accuracy for each descriptor.

</details>

<details>
<summary>Sample Answer</summary>

**Composition-based Descriptors**

**Advantages:**
- Calculable from chemical formula alone (no crystal structure needed)
- Low computational cost (seconds)
- Applicable to unknown materials

**Disadvantages:**
- Ignores structural information (properties change even with same composition if structure differs)
- Prediction accuracy may be lower than structure-based

**Use in:**
- Many materials with unknown crystal structures
- Need for fast screening (tens of thousands)
- Early project stages (rough screening)

**Structure-based Descriptors**

**Advantages:**
- Captures structure-property relationships (more accurate predictions)
- Can distinguish different structures with same composition

**Disadvantages:**
- Requires crystal structure data (determined experimentally or by DFT calculation)
- High computational cost
- Need to predict structure for unknown materials

**Use in:**
- Crystal structure data available
- Need high accuracy (narrowing down final candidates)
- Want to understand structure-property correlations

**Property-based Descriptors**

**Advantages:**
- Utilizes property correlations (e.g., materials with high melting points tend to have high hardness)
- High accuracy for known materials

**Disadvantages:**
- Difficult to apply to unknown materials (need other properties to predict target property)
- Unclear causal relationships (why are those properties related)

**Use in:**
- Estimating properties of known materials from other properties
- Material systems with abundant experimental data
- Research exploring property correlations

**Practical Use Strategy:**

1. **Initial Screening (tens of thousands)**: Composition-based descriptors
   - Rapidly narrow down to about 1,000 candidates

2. **Intermediate Screening (1,000)**: Structure-based descriptors
   - More accurately narrow down to 100

3. **Final Selection (100)**: Property-based descriptors (if available)
   - Utilize known properties to determine final 10

4. **Experimental Validation (10)**

This staged approach balances computational cost and prediction accuracy.

</details>

<hr />
<h2 id="references">References</h2>
<ol>
<li>
<p><strong>Materials Genome Initiative (MGI)</strong> - White House Office of Science and Technology Policy (2011)<br />
   URL: https://www.mgi.gov<br />
<em>U.S. materials development acceleration project launched in 2011. Triggered worldwide spread of MI.</em></p>
</li>
<li>
<p>Ramprasad, R., Batra, R., Pilania, G., Mannodi-Kanakkithodi, A., &amp; Kim, C. (2017). "Machine learning in materials informatics: recent applications and prospects." <em>npj Computational Materials</em>, 3(1), 54.<br />
   DOI: <a href="https://doi.org/10.1038/s41524-017-0056-5">10.1038/s41524-017-0056-5</a></p>
</li>
<li>
<p>Jain, A., Ong, S. P., Hautier, G., Chen, W., Richards, W. D., et al. (2013). "Commentary: The Materials Project: A materials genome approach to accelerating materials innovation." <em>APL Materials</em>, 1(1), 011002.<br />
   DOI: <a href="https://doi.org/10.1063/1.4812323">10.1063/1.4812323</a><br />
   Materials Project: https://materialsproject.org</p>
</li>
<li>
<p>Curtarolo, S., Setyawan, W., Hart, G. L., Jahnatek, M., Chepulskii, R. V., et al. (2012). "AFLOW: An automatic framework for high-throughput materials discovery." <em>Computational Materials Science</em>, 58, 218-226.<br />
   DOI: <a href="https://doi.org/10.1016/j.commatsci.2012.02.005">10.1016/j.commatsci.2012.02.005</a><br />
   AFLOW: http://www.aflowlib.org</p>
</li>
<li>
<p>Saal, J. E., Kirklin, S., Aykol, M., Meredig, B., &amp; Wolverton, C. (2013). "Materials Design and Discovery with High-Throughput Density Functional Theory: The Open Quantum Materials Database (OQMD)." <em>JOM</em>, 65(11), 1501-1509.<br />
   DOI: <a href="https://doi.org/10.1007/s11837-013-0755-4">10.1007/s11837-013-0755-4</a><br />
   OQMD: http://oqmd.org</p>
</li>
<li>
<p>Choudhary, K., Garrity, K. F., Reid, A. C. E., DeCost, B., Biacchi, A. J., et al. (2020). "The joint automated repository for various integrated simulations (JARVIS) for data-driven materials design." <em>npj Computational Materials</em>, 6(1), 173.<br />
   DOI: <a href="https://doi.org/10.1038/s41524-020-00440-1">10.1038/s41524-020-00440-1</a><br />
   JARVIS: https://jarvis.nist.gov</p>
</li>
</ol>
<hr />
<p><strong>Author Information</strong></p>
<p>This article was created as part of the MI Knowledge Hub project under Dr. Yusuke Hashimoto at Tohoku University.</p>
<p><strong>Update History</strong><br />
- 2025-10-16: v3.0 Initial version created<br />
  - Expanded Section 2 from v2.1 (approximately 2,000 words) to 4,000-5,000 words<br />
  - Added 20-term glossary<br />
  - Added detailed materials database comparison table<br />
  - Added MI ecosystem diagram (Mermaid)<br />
  - Added detailed explanation of 5-step workflow<br />
  - Added deep-dive section on materials descriptors<br />
  - Added 4 exercise problems (difficulty: 1 easy, 2 medium, 1 hard)</p>

        <div class="nav-buttons">
            <a href="index.html" class="nav-button">← Back to Series Index</a>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 MI Knowledge Hub - Dr. Yusuke Hashimoto, Tohoku University</p>
            <p>Licensed under CC BY 4.0</p>
        </div>
    </footer>
</body>
</html>
