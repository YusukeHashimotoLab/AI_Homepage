<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第2章：GNNの基礎理論 - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第2章：GNNの基礎理論</h1>
            <p class="subtitle">メッセージパッシングから材料科学特化GNNまで</p>
            <div class="meta">
                <span class="meta-item">📖 読了時間: 25-30分</span>
                <span class="meta-item">📊 難易度: 中級</span>
                <span class="meta-item">💻 コード例: 10個</span>
                <span class="meta-item">📝 演習問題: 3問</span>
            </div>
        </div>
    </header>

    <main class="container">
        <div class="learning-objectives">
            <h2>学習目標</h2>
            <p>この章を読むことで、以下を習得できます：</p>
            <ul>
                <li>グラフの数学的定義と表現方法を理解する</li>
                <li>メッセージパッシングの3ステップ（集約→更新→出力）を説明できる</li>
                <li>GCN、GAT、GraphSAGEの原理と違いを理解する</li>
                <li>材料科学特化GNN（SchNet、DimeNet）の特徴を知る</li>
                <li>シンプルなGNNをPyTorchで実装できる</li>
                <li>等変GNNの重要性を理解する</li>
            </ul>
        </div>

        <h2>2.1 グラフの数学的定義</h2>

        <h3>グラフの基本要素</h3>
        <blockquote>
            <p>グラフ G = (V, E) は、頂点集合 V と辺集合 E ⊆ V × V からなる。</p>
        </blockquote>

        <p><strong>記法</strong>:</p>
        <ul>
            <li>n = |V|: 頂点数</li>
            <li>m = |E|: 辺数</li>
            <li>𝒩(v): 頂点 v の隣接頂点集合</li>
        </ul>

        <h3>隣接行列（Adjacency Matrix）</h3>
        <p><strong>Pythonでの実装</strong>:</p>
        <pre><code class="language-python">import numpy as np

# 例：三角形グラフ（3頂点、3辺）
n = 3
A = np.array([
    [0, 1, 1],  # 頂点0: 1, 2に接続
    [1, 0, 1],  # 頂点1: 0, 2に接続
    [1, 1, 0]   # 頂点2: 0, 1に接続
])

print("隣接行列:")
print(A)
print(f"\n頂点数: {n}")
print(f"辺数: {A.sum() // 2}")  # 無向グラフは2で割る</code></pre>

        <h2>2.2 メッセージパッシングの仕組み</h2>

        <h3>Message Passing Neural Network (MPNN)</h3>
        <p>GNNの<strong>統一フレームワーク</strong>です（Gilmer et al., 2017）。</p>

        <p><strong>アルゴリズム</strong>:</p>
        <pre><code class="language-mermaid">graph LR
    A[入力: 頂点特徴 X] --> B[ステップ1: メッセージ生成]
    B --> C[ステップ2: 集約 Aggregation]
    C --> D[ステップ3: 更新 Update]
    D --> E{繰り返し?}
    E -->|Yes| B
    E -->|No| F[出力: 新しい特徴]

    style A fill:#e3f2fd
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#e8f5e9
    style F fill:#ffebee</code></pre>

        <h3>ステップ1: メッセージ生成（Message）</h3>
        <pre><code class="language-python">import torch
import torch.nn as nn

class MessageFunction(nn.Module):
    def __init__(self, in_dim, out_dim):
        super().__init__()
        self.W = nn.Linear(in_dim, out_dim)

    def forward(self, h_j):
        """
        隣接頂点からメッセージを生成

        Parameters:
        -----------
        h_j : Tensor (num_neighbors, in_dim)
            隣接頂点の特徴量

        Returns:
        --------
        messages : Tensor (num_neighbors, out_dim)
            生成されたメッセージ
        """
        return self.W(h_j)</code></pre>

        <h3>ステップ2: 集約（Aggregation）</h3>
        <p><strong>代表的な集約関数</strong>:</p>
        <table>
            <thead>
                <tr>
                    <th>集約方法</th>
                    <th>数式</th>
                    <th>特徴</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Sum</strong></td>
                    <td>Σ m_ij</td>
                    <td>順序不変、次数に敏感</td>
                </tr>
                <tr>
                    <td><strong>Mean</strong></td>
                    <td>(1/|𝒩(i)|) Σ m_ij</td>
                    <td>次数正規化</td>
                </tr>
                <tr>
                    <td><strong>Max</strong></td>
                    <td>max m_ij</td>
                    <td>最も強い特徴を保持</td>
                </tr>
                <tr>
                    <td><strong>Attention</strong></td>
                    <td>Σ α_ij m_ij</td>
                    <td>重要度で重み付け</td>
                </tr>
            </tbody>
        </table>

        <h2>2.3 代表的なGNNアーキテクチャ</h2>

        <h3>Graph Convolutional Network (GCN)</h3>
        <p><strong>論文</strong>: Kipf & Welling (2017), <em>ICLR</em></p>
        <p><strong>核心アイデア</strong>: グラフのスペクトル畳み込み</p>

        <pre><code class="language-python">import torch
import torch.nn as nn
import torch.nn.functional as F

class GCNLayer(nn.Module):
    def __init__(self, in_features, out_features):
        super().__init__()
        self.linear = nn.Linear(in_features, out_features)

    def forward(self, X, A):
        """
        Parameters:
        -----------
        X : Tensor (num_nodes, in_features)
            頂点特徴行列
        A : Tensor (num_nodes, num_nodes)
            隣接行列

        Returns:
        --------
        H : Tensor (num_nodes, out_features)
            更新された特徴量
        """
        # 自己ループの追加
        A_tilde = A + torch.eye(A.size(0), device=A.device)

        # 次数行列
        D_tilde = torch.diag(A_tilde.sum(dim=1))

        # 正規化: D^(-1/2) * A * D^(-1/2)
        D_inv_sqrt = torch.diag(1.0 / torch.sqrt(D_tilde.diagonal()))
        A_norm = D_inv_sqrt @ A_tilde @ D_inv_sqrt

        # グラフ畳み込み
        H = A_norm @ X
        H = self.linear(H)
        return F.relu(H)</code></pre>

        <p><strong>特徴</strong>:</p>
        <ul>
            <li>✅ シンプルで高速</li>
            <li>✅ 過剰平滑化（over-smoothing）に注意</li>
            <li>✅ 固定的な重み（全隣接頂点が同じ扱い）</li>
        </ul>

        <h3>Graph Attention Network (GAT)</h3>
        <p><strong>論文</strong>: Veličković et al. (2018), <em>ICLR</em></p>
        <p><strong>核心アイデア</strong>: Attentionで重要な隣接頂点を重視</p>

        <p><strong>特徴</strong>:</p>
        <ul>
            <li>✅ 動的な重み（重要な隣接頂点を自動学習）</li>
            <li>✅ 解釈可能性（Attention係数の可視化）</li>
            <li>❌ 計算コストが高い（GCNの約2倍）</li>
        </ul>

        <h3>GraphSAGE（SAmple and aggreGatE）</h3>
        <p><strong>論文</strong>: Hamilton et al. (2017), <em>NeurIPS</em></p>
        <p><strong>核心アイデア</strong>: ミニバッチ学習のためのサンプリング</p>

        <p><strong>特徴</strong>:</p>
        <ul>
            <li>✅ スケーラブル（大規模グラフに対応）</li>
            <li>✅ ミニバッチ訓練が可能</li>
            <li>✅ 帰納的学習（新しい頂点への汎化）</li>
        </ul>

        <h3>3つのGNNの比較</h3>
        <pre><code class="language-mermaid">flowchart TD
    A[GNN選択] --> B{データサイズ}
    B -->|小規模<br/>10k頂点| C[GCN]
    B -->|中規模<br/>10k-100k| D[GAT]
    B -->|大規模<br/>100k+| E[GraphSAGE]

    C --> F[シンプル、高速]
    D --> G[高精度、解釈性]
    E --> H[スケーラブル]

    style A fill:#e3f2fd
    style C fill:#fff3e0
    style D fill:#f3e5f5
    style E fill:#e8f5e9</code></pre>

        <table>
            <thead>
                <tr>
                    <th>手法</th>
                    <th>計算量</th>
                    <th>精度</th>
                    <th>スケーラビリティ</th>
                    <th>解釈性</th>
                    <th>推奨用途</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>GCN</strong></td>
                    <td>O(m·d²)</td>
                    <td>中</td>
                    <td>低</td>
                    <td>中</td>
                    <td>小規模、プロトタイピング</td>
                </tr>
                <tr>
                    <td><strong>GAT</strong></td>
                    <td>O(m·d²+n·d)</td>
                    <td>高</td>
                    <td>中</td>
                    <td>高</td>
                    <td>中規模、高精度要求</td>
                </tr>
                <tr>
                    <td><strong>GraphSAGE</strong></td>
                    <td>O(k·s·d²)</td>
                    <td>中〜高</td>
                    <td>高</td>
                    <td>中</td>
                    <td>大規模、実時間予測</td>
                </tr>
            </tbody>
        </table>

        <h2>2.4 材料科学特化GNN</h2>

        <h3>SchNet（Continuous-filter Convolutional NN）</h3>
        <p><strong>論文</strong>: Schütt et al. (2017), <em>NeurIPS</em></p>
        <p><strong>対象</strong>: 分子・材料の<strong>量子化学特性</strong>予測</p>

        <p><strong>核心アイデア</strong>:</p>
        <ol>
            <li><strong>連続フィルタ</strong>: 離散グラフではなく3D空間での畳み込み</li>
            <li><strong>距離依存</strong>: 原子間距離を明示的にモデル化</li>
        </ol>

        <p><strong>アーキテクチャ</strong>:</p>
        <pre><code class="language-mermaid">graph LR
    A[原子特徴] --> B[埋め込み層]
    B --> C[相互作用ブロック 1]
    C --> D[相互作用ブロック 2]
    D --> E[相互作用ブロック 3]
    E --> F[出力層]

    G[原子間距離] --> C
    G --> D
    G --> E

    style A fill:#e3f2fd
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#e8f5e9
    style E fill:#ffebee
    style F fill:#fff9c4
    style G fill:#e1bee7</code></pre>

        <p><strong>適用例</strong>:</p>
        <ul>
            <li>QM9データセット（分子特性予測）</li>
            <li>MD17（分子動力学）</li>
            <li>OC20（触媒吸着エネルギー）</li>
        </ul>

        <p><strong>性能</strong>:</p>
        <pre><code>QM9 HOMO-LUMO gap:
- DFT計算: 24時間/分子
- SchNet: 0.01秒/分子（MAE=0.04 eV）</code></pre>

        <h3>DimeNet（Directional Message Passing NN）</h3>
        <p><strong>論文</strong>: Klicpera et al. (2020), <em>ICLR</em></p>
        <p><strong>拡張</strong>: <strong>結合角</strong>も考慮</p>

        <p><strong>核心アイデア</strong>:</p>
        <ul>
            <li>距離だけでなく<strong>角度情報</strong>も利用</li>
            <li>3体相互作用（triplet interaction）</li>
        </ul>

        <pre><code class="language-mermaid">graph TD
    A[原子 i] ---|d_ij| B[原子 j]
    B ---|d_jk| C[原子 k]
    A -.角度θ_ijk.-> C

    style A fill:#e3f2fd
    style B fill:#fff3e0
    style C fill:#f3e5f5</code></pre>

        <p><strong>性能</strong>:</p>
        <pre><code>QM9データセット:
- SchNet: MAE=0.041 eV
- DimeNet: MAE=0.033 eV（20%改善）

計算時間:
- SchNet: 0.01秒/分子
- DimeNet: 0.05秒/分子（5倍遅い）</code></pre>

        <h3>材料科学GNNの比較</h3>
        <table>
            <thead>
                <tr>
                    <th>手法</th>
                    <th>考慮する情報</th>
                    <th>精度</th>
                    <th>速度</th>
                    <th>推奨用途</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>SchNet</strong></td>
                    <td>距離</td>
                    <td>中</td>
                    <td>速い</td>
                    <td>分子特性予測</td>
                </tr>
                <tr>
                    <td><strong>DimeNet</strong></td>
                    <td>距離 + 角度</td>
                    <td>高</td>
                    <td>中</td>
                    <td>触媒、複雑な分子</td>
                </tr>
                <tr>
                    <td><strong>GemNet</strong></td>
                    <td>距離 + 角度 + 二面角</td>
                    <td>最高</td>
                    <td>遅い</td>
                    <td>結晶、高精度要求</td>
                </tr>
            </tbody>
        </table>

        <h2>2.7 本章のまとめ</h2>

        <h3>学んだこと</h3>
        <ol>
            <li><strong>グラフの数学的定義</strong>
                <ul>
                    <li>隣接行列、次数行列、ラプラシアン行列</li>
                    <li>頂点特徴量と辺特徴量</li>
                </ul>
            </li>
            <li><strong>メッセージパッシング</strong>
                <ul>
                    <li>3ステップ: メッセージ生成 → 集約 → 更新</li>
                    <li>集約関数: Sum、Mean、Max、Attention</li>
                </ul>
            </li>
            <li><strong>代表的GNNアーキテクチャ</strong>
                <ul>
                    <li>GCN: シンプル、高速</li>
                    <li>GAT: Attention、高精度</li>
                    <li>GraphSAGE: スケーラブル、ミニバッチ</li>
                </ul>
            </li>
            <li><strong>材料科学特化GNN</strong>
                <ul>
                    <li>SchNet: 距離依存、連続フィルタ</li>
                    <li>DimeNet: 角度情報も考慮</li>
                    <li>GemNet: 二面角まで考慮</li>
                </ul>
            </li>
        </ol>

        <h3>重要なポイント</h3>
        <ul>
            <li>メッセージパッシングはGNNの<strong>統一フレームワーク</strong></li>
            <li>集約関数の選択が性能に大きく影響</li>
            <li>材料科学では<strong>幾何学的情報</strong>（距離、角度）が重要</li>
            <li>等変性により<strong>物理法則を保証</strong></li>
            <li>過剰平滑化に注意（Residual Connectionで対策）</li>
        </ul>

        <div class="navigation">
            <a href="chapter-1.html" class="nav-button">← 前章: 第1章 なぜGNNが必要か</a>
            <a href="chapter-3.html" class="nav-button">次章: 第3章 PyTorch Geometric実践 →</a>
            <a href="index.html" class="nav-button">← シリーズ目次に戻る</a>
        </div>
    </main>

    <footer>
        <p><strong>作成者</strong>: AI Terakoya Content Team</p>
        <p><strong>監修</strong>: Dr. Yusuke Hashimoto（東北大学）</p>
        <p><strong>バージョン</strong>: 1.0 | <strong>作成日</strong>: 2025-10-17</p>
        <p><strong>ライセンス</strong>: Creative Commons BY 4.0</p>
        <p>© 2025 AI Terakoya. All rights reserved.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const mermaidCodeBlocks = document.querySelectorAll('pre.codehilite code.language-mermaid, pre code.language-mermaid');

            mermaidCodeBlocks.forEach(function(codeBlock) {
                const pre = codeBlock.parentElement;
                const mermaidCode = codeBlock.textContent;

                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = mermaidCode.trim();

                pre.parentNode.replaceChild(mermaidDiv, pre);
            });

            if (typeof mermaid !== 'undefined') {
                mermaid.initialize({
                    startOnLoad: true,
                    theme: 'default'
                });
                mermaid.init(undefined, document.querySelectorAll('.mermaid'));
            }
        });
    </script>
</body>
</html>
