<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Á¨¨3Á´†ÔºöPyTorch GeometricÂÆüË∑µ - ÂàÜÂ≠ê„ÉªÊùêÊñôÁâπÊÄß‰∫àÊ∏¨„ÅÆÂÆüË£Ö - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>Á¨¨3Á´†ÔºöPyTorch GeometricÂÆüË∑µ - ÂàÜÂ≠ê„ÉªÊùêÊñôÁâπÊÄß‰∫àÊ∏¨„ÅÆÂÆüË£Ö</h1>
            <p class="subtitle">ÂÆü„Éá„Éº„Çø„ÅßÂ≠¶„Å∂„Ç∞„É©„Éï„Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÅÆÊßãÁØâ„Å®Ë©ï‰æ°</p>
            <div class="meta">
                <span class="meta-item">üìñ Ë™≠‰∫ÜÊôÇÈñì: 20-25ÂàÜ</span>
                <span class="meta-item">üìä Èõ£ÊòìÂ∫¶: ‰∏≠Á¥ö</span>
                <span class="meta-item">üíª „Ç≥„Éº„Éâ‰æã: 0ÂÄã</span>
                <span class="meta-item">üìù ÊºîÁøíÂïèÈ°å: 0Âïè</span>
            </div>
        </div>
    </header>

    <main class="container">

<h1>Á¨¨3Á´†ÔºöPyTorch GeometricÂÆüË∑µ - ÂàÜÂ≠ê„ÉªÊùêÊñôÁâπÊÄß‰∫àÊ∏¨„ÅÆÂÆüË£Ö</h1>

<h2>Â≠¶ÁøíÁõÆÊ®ô</h2>

„Åì„ÅÆÁ´†„ÇíË™≠„ÇÄ„Åì„Å®„Åß„ÄÅ‰ª•‰∏ã„ÇíÁøíÂæó„Åß„Åç„Åæ„ÅôÔºö
- PyTorch GeometricÁí∞Â¢É„ÇíÊßãÁØâ„Åó„ÄÅGNN„É©„Ç§„Éñ„É©„É™„Çí‰Ωø„ÅÑ„Åì„Å™„Åõ„Çã
- QM9„Éá„Éº„Çø„Çª„ÉÉ„Éà„ÅßÂàÜÂ≠êÁâπÊÄß‰∫àÊ∏¨„É¢„Éá„É´„ÇíÂÆüË£Ö„Åß„Åç„Çã
- Materials Project„Éá„Éº„Çø„ÅßÁµêÊô∂ÁâπÊÄß‰∫àÊ∏¨„ÇíÂÆüË°å„Åß„Åç„Çã
- „É¢„Éá„É´Ë®ìÁ∑¥„ÅÆ„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ„ÇíÈÅ©Áî®„Åß„Åç„Çã
- ‰∫àÊ∏¨ÁµêÊûú„ÇíÂèØË¶ñÂåñ„Åó„ÄÅÊÄßËÉΩ„ÇíË©ï‰æ°„Åß„Åç„Çã

<strong>Ë™≠‰∫ÜÊôÇÈñì</strong>: 25-30ÂàÜ
<strong>„Ç≥„Éº„Éâ‰æã</strong>: 10ÂÄã
<strong>ÊºîÁøíÂïèÈ°å</strong>: 3Âïè

---

<h2>3.1 Áí∞Â¢ÉÊßãÁØâÔºöPyTorch Geometric„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´</h2>

<h3>3.1.1 PyTorch Geometric„Å®„ÅØ</h3>

<strong>PyTorch Geometric (PyG)</strong>„ÅØ„ÄÅPyTorch‰∏ä„ÅßÂãï‰Ωú„Åô„Çã„Ç∞„É©„Éï„Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÂ∞ÇÁî®„É©„Ç§„Éñ„É©„É™„Åß„Åô„ÄÇ

<strong>‰∏ª„Å™ÁâπÂæ¥</strong>:
- üöÄ <strong>È´òÈÄü</strong>: GPU„Å´„Çà„ÇãÂäπÁéáÁöÑ„Å™„Ç∞„É©„ÉïÂá¶ÁêÜ
- üì¶ <strong>Ë±äÂØå„Å™„É¢„Éá„É´</strong>: GCN„ÄÅGAT„ÄÅGraphSAGE„ÄÅSchNet„Å™„Å©30Á®ÆÈ°û‰ª•‰∏ä
- üß™ <strong>„Éá„Éº„Çø„Çª„ÉÉ„Éà</strong>: QM9„ÄÅZINC„ÄÅOGBÔºàOpen Graph BenchmarkÔºâ„ÅåÁµÑ„ÅøËæº„ÅøÊ∏à„Åø
- üõ†Ô∏è <strong>ÊüîËªüÊÄß</strong>: „Ç´„Çπ„Çø„É†„É¨„Ç§„É§„Éº„ÇÑ„É¢„Éá„É´„ÇíÁ∞°Âçò„Å´ÂÆüË£ÖÂèØËÉΩ

<h3>3.1.2 „Ç§„É≥„Çπ„Éà„Éº„É´ÊâãÈ†Ü</h3>

<strong>Option 1: CondaÁí∞Â¢ÉÔºàÊé®Â•®Ôºâ</strong>

<pre><code class="language-bash"><h1>1. Python 3.9‰ª•‰∏ä„ÅÆÁí∞Â¢É„Çí‰ΩúÊàê</h1>
conda create -n gnn-env python=3.10
conda activate gnn-env

<h1>2. PyTorch„Çí„Ç§„É≥„Çπ„Éà„Éº„É´ÔºàCUDAÁâàÊé®Â•®Ôºâ</h1>
<h1>CPUÁâà„ÅÆÂ†¥Âêà:</h1>
conda install pytorch torchvision torchaudio cpuonly -c pytorch

<h1>GPUÁâà„ÅÆÂ†¥ÂêàÔºàCUDA 11.8Ôºâ:</h1>
conda install pytorch torchvision torchaudio pytorch-cuda=11.8 -c pytorch -c nvidia

<h1>3. PyTorch Geometric„Çí„Ç§„É≥„Çπ„Éà„Éº„É´</h1>
conda install pyg -c pyg

<h1>4. ËøΩÂä†„É©„Ç§„Éñ„É©„É™</h1>
pip install rdkit matplotlib seaborn pandas scikit-learn</code></pre>

<strong>Option 2: pip„Åß„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´</strong>

<pre><code class="language-bash"><h1>1. ‰ªÆÊÉ≥Áí∞Â¢É„Çí‰ΩúÊàê</h1>
python -m venv gnn-env
source gnn-env/bin/activate  # macOS/Linux
<h1>gnn-env\Scripts\activate  # Windows</h1>

<h1>2. PyTorch„Çí„Ç§„É≥„Çπ„Éà„Éº„É´</h1>
pip install torch torchvision torchaudio

<h1>3. PyTorch Geometric„Çí„Ç§„É≥„Çπ„Éà„Éº„É´</h1>
pip install torch-geometric

<h1>4. ‰æùÂ≠ò„É©„Ç§„Éñ„É©„É™</h1>
pip install torch-scatter torch-sparse torch-cluster -f https://data.pyg.org/whl/torch-2.0.0+cpu.html

<h1>5. ËøΩÂä†„É©„Ç§„Éñ„É©„É™</h1>
pip install rdkit matplotlib seaborn pandas scikit-learn</code></pre>

<strong>Option 3: Google ColabÔºà„Ç§„É≥„Çπ„Éà„Éº„É´‰∏çË¶ÅÔºâ</strong>

<pre><code class="language-python"><h1>Google Colab„Åß„ÅØ‰ª•‰∏ã„ÇíÂÆüË°å</h1>
!pip install torch-geometric
!pip install rdkit</code></pre>

<h3>3.1.3 „Ç§„É≥„Çπ„Éà„Éº„É´Á¢∫Ë™ç</h3>

<pre><code class="language-python">import torch
import torch_geometric
from torch_geometric.data import Data
from rdkit import Chem
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

print("===== „Ç§„É≥„Çπ„Éà„Éº„É´Á¢∫Ë™ç =====")
print(f"PyTorch version: {torch.__version__}")
print(f"PyTorch Geometric version: {torch_geometric.__version__}")
print(f"CUDA available: {torch.cuda.is_available()}")
if torch.cuda.is_available():
    print(f"CUDA version: {torch.version.cuda}")
    print(f"GPU: {torch.cuda.get_device_name(0)}")

<h1>Á∞°Âçò„Å™„Ç∞„É©„Éï„Çí‰ΩúÊàê„Åó„Å¶„ÉÜ„Çπ„Éà</h1>
edge_index = torch.tensor([[0, 1, 1, 2],
                           [1, 0, 2, 1]], dtype=torch.long)
x = torch.tensor([[-1], [0], [1]], dtype=torch.float)
data = Data(x=x, edge_index=edge_index)

print(f"\n„ÉÜ„Çπ„Éà„Ç∞„É©„Éï‰ΩúÊàêÊàêÂäü!")
print(f"„Éé„Éº„ÉâÊï∞: {data.num_nodes}")
print(f"„Ç®„ÉÉ„Ç∏Êï∞: {data.num_edges}")
print("‚úÖ PyTorch GeometricÁí∞Â¢É„ÅÆÊßãÁØâÂÆå‰∫Ü!")</code></pre>

<strong>ÊúüÂæÖ„Åï„Çå„ÇãÂá∫Âäõ</strong>:
<pre><code>===== „Ç§„É≥„Çπ„Éà„Éº„É´Á¢∫Ë™ç =====
PyTorch version: 2.0.0
PyTorch Geometric version: 2.3.0
CUDA available: True
CUDA version: 11.8
GPU: NVIDIA GeForce RTX 3090

„ÉÜ„Çπ„Éà„Ç∞„É©„Éï‰ΩúÊàêÊàêÂäü!
„Éé„Éº„ÉâÊï∞: 3
„Ç®„ÉÉ„Ç∏Êï∞: 4
‚úÖ PyTorch GeometricÁí∞Â¢É„ÅÆÊßãÁØâÂÆå‰∫Ü!</code></pre>

<h3>3.1.4 „Éà„É©„Éñ„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞</h3>

| „Ç®„É©„Éº | ÂéüÂõ† | Ëß£Ê±∫ÊñπÊ≥ï |
|--------|------|----------|
| <code>ImportError: No module named 'torch_geometric'</code> | PyGÊú™„Ç§„É≥„Çπ„Éà„Éº„É´ | <code>pip install torch-geometric</code> |
| <code>OSError: [WinError 126] DLLË™≠„ÅøËæº„Åø„Ç®„É©„Éº</code> (Windows) | C++ÂÜçÈ†íÂ∏ÉÂèØËÉΩ„Éë„ÉÉ„Ç±„Éº„Ç∏‰∏çË∂≥ | Microsoft Visual C++ Redistributable„Çí„Ç§„É≥„Çπ„Éà„Éº„É´ |
| <code>RuntimeError: CUDA out of memory</code> | GPU „É°„É¢„É™‰∏çË∂≥ | „Éê„ÉÉ„ÉÅ„Çµ„Ç§„Ç∫„ÇíÂâäÊ∏õ„ÄÅCPUÁâàPyTorch‰ΩøÁî® |
| <code>ImportError: cannot import name 'Data'</code> | „Éê„Éº„Ç∏„Éß„É≥‰∏ç‰∏ÄËá¥ | PyTorch„Å®PyG„ÅÆ„Éê„Éº„Ç∏„Éß„É≥„ÇíÁ¢∫Ë™ç |

---

<h2>3.2 PyTorch Geometric„ÅÆÂü∫Êú¨Ôºö„Éá„Éº„ÇøÊßãÈÄ†„Å®DataLoader</h2>

<h3>3.2.1 Data„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÊßãÈÄ†</h3>

PyTorch Geometric„Åß„ÅØ„ÄÅ„Ç∞„É©„Éï„Çí<code>Data</code>„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅßË°®Áèæ„Åó„Åæ„Åô„ÄÇ

<pre><code class="language-python">from torch_geometric.data import Data
import torch

<h1>„Ç®„Çø„Éé„Éº„É´ÂàÜÂ≠ê (C2H5OH) „Çí„Ç∞„É©„Éï„ÅßË°®Áèæ</h1>
<h1>C: ÁÇ≠Á¥†Ôºà„Éé„Éº„Éâ0, 1Ôºâ</h1>
<h1>O: ÈÖ∏Á¥†Ôºà„Éé„Éº„Éâ2Ôºâ</h1>
<h1>H: Ê∞¥Á¥†Ôºà„Éé„Éº„Éâ3-7Ôºâ</h1>

<h1>„Éé„Éº„ÉâÁâπÂæ¥ÈáèÔºàÂéüÂ≠êÁï™Âè∑„Çí‰ΩøÁî®Ôºâ</h1>
x = torch.tensor([
    [6],   # C (ÁÇ≠Á¥†)
    [6],   # C (ÁÇ≠Á¥†)
    [8],   # O (ÈÖ∏Á¥†)
    [1],   # H (Ê∞¥Á¥†)
    [1],   # H (Ê∞¥Á¥†)
    [1],   # H (Ê∞¥Á¥†)
    [1],   # H (Ê∞¥Á¥†)
    [1],   # H (Ê∞¥Á¥†)
], dtype=torch.float)

<h1>„Ç®„ÉÉ„Ç∏„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÔºàÁµêÂêàÈñ¢‰øÇÔºâ</h1>
<h1>ÂêÑÁµêÂêà„ÅØÂèåÊñπÂêëÔºàÁÑ°Âêë„Ç∞„É©„ÉïÔºâ</h1>
edge_index = torch.tensor([
    [0, 1, 1, 0, 0, 2, 2, 0, 0, 3, 3, 0, 1, 4, 4, 1, 1, 5, 5, 1, 2, 6, 6, 2],
    [1, 0, 2, 2, 3, 0, 0, 3, 4, 1, 1, 4, 5, 1, 1, 5, 6, 2, 2, 6, 7, 2, 2, 7]
], dtype=torch.long)

<h1>„Ç®„ÉÉ„Ç∏ÁâπÂæ¥ÈáèÔºàÁµêÂêà„Çø„Ç§„Éó: 1=ÂçòÁµêÂêàÔºâ</h1>
edge_attr = torch.ones(edge_index.size(1), 1)

<h1>ÂàÜÂ≠ê„É¨„Éô„É´„ÅÆÁâπÂæ¥ÔºàÁõÆÁöÑÂ§âÊï∞Ôºâ</h1>
y = torch.tensor([[156.0]], dtype=torch.float)  # Ê≤∏ÁÇπ (¬∞C)

<h1>Data„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê</h1>
ethanol = Data(x=x, edge_index=edge_index, edge_attr=edge_attr, y=y)

print("===== „Ç®„Çø„Éé„Éº„É´ÂàÜÂ≠ê„ÅÆ„Ç∞„É©„ÉïË°®Áèæ =====")
print(f"„Éé„Éº„ÉâÊï∞ÔºàÂéüÂ≠êÊï∞Ôºâ: {ethanol.num_nodes}")
print(f"„Ç®„ÉÉ„Ç∏Êï∞ÔºàÁµêÂêàÊï∞√ó2Ôºâ: {ethanol.num_edges}")
print(f"„Éé„Éº„ÉâÁâπÂæ¥Èáè„ÅÆÂΩ¢Áä∂: {ethanol.x.shape}")
print(f"„Ç®„ÉÉ„Ç∏„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆÂΩ¢Áä∂: {ethanol.edge_index.shape}")
print(f"ÁõÆÁöÑÂ§âÊï∞ÔºàÊ≤∏ÁÇπÔºâ: {ethanol.y.item()} ¬∞C")

<h1>„Ç∞„É©„Éï„ÅÆÂü∫Êú¨Áµ±Ë®à</h1>
print(f"\n===== „Ç∞„É©„Éï„ÅÆÁµ±Ë®àÊÉÖÂ†± =====")
print(f"Âπ≥ÂùáÊ¨°Êï∞ÔºàÁµêÂêàÊï∞Ôºâ: {ethanol.num_edges / ethanol.num_nodes:.2f}")
print(f"Â≠§Á´ã„Éé„Éº„Éâ: {ethanol.contains_isolated_nodes()}")
print(f"Ëá™Â∑±„É´„Éº„Éó: {ethanol.contains_self_loops()}")</code></pre>

<strong>Âá∫Âäõ</strong>:
<pre><code>===== „Ç®„Çø„Éé„Éº„É´ÂàÜÂ≠ê„ÅÆ„Ç∞„É©„ÉïË°®Áèæ =====
„Éé„Éº„ÉâÊï∞ÔºàÂéüÂ≠êÊï∞Ôºâ: 8
„Ç®„ÉÉ„Ç∏Êï∞ÔºàÁµêÂêàÊï∞√ó2Ôºâ: 24
„Éé„Éº„ÉâÁâπÂæ¥Èáè„ÅÆÂΩ¢Áä∂: torch.Size([8, 1])
„Ç®„ÉÉ„Ç∏„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆÂΩ¢Áä∂: torch.Size([2, 24])
ÁõÆÁöÑÂ§âÊï∞ÔºàÊ≤∏ÁÇπÔºâ: 156.0 ¬∞C

===== „Ç∞„É©„Éï„ÅÆÁµ±Ë®àÊÉÖÂ†± =====
Âπ≥ÂùáÊ¨°Êï∞ÔºàÁµêÂêàÊï∞Ôºâ: 3.00
Â≠§Á´ã„Éé„Éº„Éâ: False
Ëá™Â∑±„É´„Éº„Éó: False</code></pre>

<h3>3.2.2 RDKit„Åã„Çâ„Ç∞„É©„Éï„Å∏„ÅÆÂ§âÊèõ</h3>

RDKit„ÅØSMILESÔºàÂàÜÂ≠ê„ÅÆÊñáÂ≠óÂàóË°®ÁèæÔºâ„Åã„ÇâÂàÜÂ≠ê„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê„Åß„Åç„Åæ„Åô„ÄÇ

<pre><code class="language-python">from rdkit import Chem
from rdkit.Chem import Draw
from torch_geometric.data import Data
import torch

def mol_to_graph(smiles):
    """
    SMILESÊñáÂ≠óÂàó„Åã„ÇâPyTorch Geometric„ÅÆData„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê

    Parameters:
    -----------
    smiles : str
        ÂàÜÂ≠ê„ÅÆSMILESË°®Áèæ

    Returns:
    --------
    data : torch_geometric.data.Data
        „Ç∞„É©„Éï„Éá„Éº„Çø
    """
    # SMILES„Åã„ÇâÂàÜÂ≠ê„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None

    # „Éé„Éº„ÉâÁâπÂæ¥ÈáèÔºàÂéüÂ≠ê„ÅÆÁâπÊÄßÔºâ
    atom_features = []
    for atom in mol.GetAtoms():
        # ÂéüÂ≠êÁï™Âè∑„Çí„ÉØ„É≥„Éõ„ÉÉ„Éà„Ç®„É≥„Ç≥„Éº„Éá„Ç£„É≥„Ç∞ÔºàC, N, O, F, „Åù„ÅÆ‰ªñÔºâ
        atom_type = [0] * 5
        if atom.GetAtomicNum() == 6:    # C
            atom_type[0] = 1
        elif atom.GetAtomicNum() == 7:  # N
            atom_type[1] = 1
        elif atom.GetAtomicNum() == 8:  # O
            atom_type[2] = 1
        elif atom.GetAtomicNum() == 9:  # F
            atom_type[3] = 1
        else:
            atom_type[4] = 1

        # ÂΩ¢ÂºèÈõªËç∑„Å®Ëä≥È¶ôÊóèÊÄß„ÇíËøΩÂä†
        formal_charge = atom.GetFormalCharge()
        is_aromatic = int(atom.GetIsAromatic())

        atom_features.append(atom_type + [formal_charge, is_aromatic])

    x = torch.tensor(atom_features, dtype=torch.float)

    # „Ç®„ÉÉ„Ç∏„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÔºàÁµêÂêàÈñ¢‰øÇÔºâ
    edge_indices = []
    for bond in mol.GetBonds():
        i = bond.GetBeginAtomIdx()
        j = bond.GetEndAtomIdx()
        edge_indices += [[i, j], [j, i]]  # ÁÑ°Âêë„Ç∞„É©„Éï„Å™„ÅÆ„ÅßÂèåÊñπÂêë

    edge_index = torch.tensor(edge_indices, dtype=torch.long).t().contiguous()

    data = Data(x=x, edge_index=edge_index)
    return data, mol

<h1>„ÉÜ„Çπ„Éà: „ÅÑ„Åè„Å§„Åã„ÅÆÂàÜÂ≠ê„Çí„Ç∞„É©„Éï„Å´Â§âÊèõ</h1>
smiles_list = [
    ("C", "„É°„Çø„É≥"),
    ("CCO", "„Ç®„Çø„Éé„Éº„É´"),
    ("c1ccccc1", "„Éô„É≥„Çº„É≥"),
    ("CC(=O)O", "ÈÖ¢ÈÖ∏"),
]

print("===== SMILES„Åã„Çâ„Ç∞„É©„Éï„Å∏„ÅÆÂ§âÊèõ =====")
for smiles, name in smiles_list:
    data, mol = mol_to_graph(smiles)
    print(f"\n{name} ({smiles}):")
    print(f"  „Éé„Éº„ÉâÊï∞: {data.num_nodes}")
    print(f"  „Ç®„ÉÉ„Ç∏Êï∞: {data.num_edges}")
    print(f"  „Éé„Éº„ÉâÁâπÂæ¥ÈáèÊ¨°ÂÖÉ: {data.x.shape[1]}")

<h1>ÂàÜÂ≠êÊßãÈÄ†„ÅÆÂèØË¶ñÂåñ</h1>
import matplotlib.pyplot as plt
from rdkit.Chem import Draw

fig, axes = plt.subplots(1, 4, figsize=(16, 4))
for i, (smiles, name) in enumerate(smiles_list):
    _, mol = mol_to_graph(smiles)
    img = Draw.MolToImage(mol, size=(300, 300))
    axes[i].imshow(img)
    axes[i].set_title(f"{name}\n{smiles}", fontsize=12)
    axes[i].axis('off')

plt.tight_layout()
plt.show()</code></pre>

<h3>3.2.3 DataLoader„ÅÆ‰ΩøÁî®</h3>

Ë§áÊï∞„ÅÆ„Ç∞„É©„Éï„Çí„Éê„ÉÉ„ÉÅÂá¶ÁêÜ„Åô„Çã„Å´„ÅØ<code>DataLoader</code>„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ

<pre><code class="language-python">from torch_geometric.data import Data, DataLoader
import torch

<h1>„Çµ„É≥„Éó„É´„Éá„Éº„Çø„Çª„ÉÉ„Éà„Çí‰ΩúÊàêÔºà10ÂÄã„ÅÆÂàÜÂ≠êÔºâ</h1>
dataset = []
for i in range(10):
    num_nodes = torch.randint(5, 15, (1,)).item()  # 5-14ÂéüÂ≠ê
    x = torch.randn(num_nodes, 7)  # „Éé„Éº„ÉâÁâπÂæ¥ÈáèÔºà7Ê¨°ÂÖÉÔºâ

    # „É©„É≥„ÉÄ„É†„Å™„Ç®„ÉÉ„Ç∏„ÇíÁîüÊàê
    edge_index = torch.randint(0, num_nodes, (2, num_nodes * 2))

    # ÁõÆÁöÑÂ§âÊï∞Ôºà‰æã: HOMO-LUMO„ÇÆ„É£„ÉÉ„ÉóÔºâ
    y = torch.randn(1)

    data = Data(x=x, edge_index=edge_index, y=y)
    dataset.append(data)

<h1>DataLoader„Çí‰ΩúÊàêÔºà„Éê„ÉÉ„ÉÅ„Çµ„Ç§„Ç∫=4Ôºâ</h1>
loader = DataLoader(dataset, batch_size=4, shuffle=True)

print("===== DataLoader„ÅÆ‰ΩøÁî® =====")
print(f"„Éá„Éº„Çø„Çª„ÉÉ„Éà„Çµ„Ç§„Ç∫: {len(dataset)}")
print(f"„Éê„ÉÉ„ÉÅÊï∞: {len(loader)}")

<h1>ÊúÄÂàù„ÅÆ„Éê„ÉÉ„ÉÅ„ÇíÁ¢∫Ë™ç</h1>
for batch in loader:
    print(f"\nÊúÄÂàù„ÅÆ„Éê„ÉÉ„ÉÅ:")
    print(f"  „Éê„ÉÉ„ÉÅÂÜÖ„ÅÆÂàÜÂ≠êÊï∞: {batch.num_graphs}")
    print(f"  Á∑è„Éé„Éº„ÉâÊï∞: {batch.num_nodes}")
    print(f"  Á∑è„Ç®„ÉÉ„Ç∏Êï∞: {batch.num_edges}")
    print(f"  „Éé„Éº„ÉâÁâπÂæ¥Èáè„ÅÆÂΩ¢Áä∂: {batch.x.shape}")
    print(f"  „Éê„ÉÉ„ÉÅ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ: {batch.batch}")
    print(f"  ÁõÆÁöÑÂ§âÊï∞„ÅÆÂΩ¢Áä∂: {batch.y.shape}")
    break</code></pre>

<strong>Âá∫Âäõ‰æã</strong>:
<pre><code>===== DataLoader„ÅÆ‰ΩøÁî® =====
„Éá„Éº„Çø„Çª„ÉÉ„Éà„Çµ„Ç§„Ç∫: 10
„Éê„ÉÉ„ÉÅÊï∞: 3

ÊúÄÂàù„ÅÆ„Éê„ÉÉ„ÉÅ:
  „Éê„ÉÉ„ÉÅÂÜÖ„ÅÆÂàÜÂ≠êÊï∞: 4
  Á∑è„Éé„Éº„ÉâÊï∞: 38
  Á∑è„Ç®„ÉÉ„Ç∏Êï∞: 76
  „Éé„Éº„ÉâÁâπÂæ¥Èáè„ÅÆÂΩ¢Áä∂: torch.Size([38, 7])
  „Éê„ÉÉ„ÉÅ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ: tensor([0, 0, 0, ..., 3, 3, 3])
  ÁõÆÁöÑÂ§âÊï∞„ÅÆÂΩ¢Áä∂: torch.Size([4, 1])</code></pre>

<strong>ÈáçË¶Å</strong>: <code>batch</code>„ÉÜ„É≥„ÇΩ„É´„ÅØÂêÑ„Éé„Éº„Éâ„Åå„Å©„ÅÆÂàÜÂ≠ê„Å´Â±û„Åô„Çã„Åã„ÇíÁ§∫„Åó„Åæ„ÅôÔºà0, 0, 0, 1, 1, 2, 2, 2, 3, ...Ôºâ„ÄÇ

---

<h2>3.3 QM9„Éá„Éº„Çø„Çª„ÉÉ„Éà„ÅßÂàÜÂ≠êÁâπÊÄß‰∫àÊ∏¨</h2>

<h3>3.3.1 QM9„Éá„Éº„Çø„Çª„ÉÉ„Éà„ÅÆÊ¶ÇË¶Å</h3>

<strong>QM9</strong>„ÅØ134,000ÂÄã„ÅÆÊúâÊ©üÂ∞èÂàÜÂ≠ê„ÅÆÈáèÂ≠êÂåñÂ≠¶Ë®àÁÆó„Éá„Éº„Çø„Çª„ÉÉ„Éà„Åß„Åô„ÄÇ

<strong>Âê´„Åæ„Çå„ÇãÁâπÊÄß</strong>:
- HOMOÔºàÊúÄÈ´òË¢´Âç†ËªåÈÅì„Ç®„Éç„É´„ÇÆ„ÉºÔºâ
- LUMOÔºàÊúÄ‰ΩéÈùûÂç†ËªåÈÅì„Ç®„Éç„É´„ÇÆ„ÉºÔºâ
- „Éê„É≥„Éâ„ÇÆ„É£„ÉÉ„ÉóÔºàHOMO-LUMO„ÇÆ„É£„ÉÉ„ÉóÔºâ
- ÂèåÊ•µÂ≠ê„É¢„Éº„É°„É≥„Éà
- ÂÜÖÈÉ®„Ç®„Éç„É´„ÇÆ„Éº
- „Ç®„É≥„Çø„É´„Éî„Éº„ÄÅËá™Áî±„Ç®„Éç„É´„ÇÆ„Éº„ÄÅÁÜ±ÂÆπÈáè„Å™„Å©

<h3>3.3.2 QM9„Éá„Éº„Çø„Çª„ÉÉ„Éà„ÅÆË™≠„ÅøËæº„Åø</h3>

<pre><code class="language-python">from torch_geometric.datasets import QM9
import torch

<h1>„Éá„Éº„Çø„Çª„ÉÉ„Éà„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÔºàÂàùÂõû„ÅÆ„Åø„ÄÅÁ¥Ñ1GBÔºâ</h1>
dataset = QM9(root='./data/QM9')

print("===== QM9„Éá„Éº„Çø„Çª„ÉÉ„Éà =====")
print(f"ÂàÜÂ≠êÊï∞: {len(dataset)}")
print(f"„Éé„Éº„ÉâÁâπÂæ¥ÈáèÊ¨°ÂÖÉ: {dataset.num_node_features}")
print(f"„Ç®„ÉÉ„Ç∏ÁâπÂæ¥ÈáèÊ¨°ÂÖÉ: {dataset.num_edge_features}")
print(f"ÁõÆÁöÑÂ§âÊï∞Êï∞: {dataset.num_classes}")

<h1>ÊúÄÂàù„ÅÆÂàÜÂ≠ê„ÇíÁ¢∫Ë™ç</h1>
data = dataset[0]
print(f"\nÊúÄÂàù„ÅÆÂàÜÂ≠ê:")
print(f"  ÂéüÂ≠êÊï∞: {data.num_nodes}")
print(f"  ÁµêÂêàÊï∞: {data.num_edges // 2}")
print(f"  „Éé„Éº„ÉâÁâπÂæ¥Èáè: {data.x.shape}")
print(f"  „Ç®„ÉÉ„Ç∏ÁâπÂæ¥Èáè: {data.edge_attr.shape}")
print(f"  ÁõÆÁöÑÂ§âÊï∞Ôºà19Á®ÆÈ°ûÔºâ: {data.y.shape}")

<h1>ÁõÆÁöÑÂ§âÊï∞„ÅÆ‰∏ÄÈÉ®„ÇíË°®Á§∫</h1>
target_names = ['mu', 'alpha', 'homo', 'lumo', 'gap', 'r2', 'zpve',
                'U0', 'U', 'H', 'G', 'Cv']
print(f"\n‰∏ªË¶Å„Å™ÁâπÊÄßÂÄ§:")
for i, name in enumerate(target_names):
    print(f"  {name}: {data.y[0, i].item():.4f}")</code></pre>

<h3>3.3.3 Graph Convolutional NetworkÔºàGCNÔºâ„ÅÆÂÆüË£Ö</h3>

<pre><code class="language-python">import torch
import torch.nn.functional as F
from torch_geometric.nn import GCNConv, global_mean_pool

class GCN_QM9(torch.nn.Module):
    """
    QM9ÂàÜÂ≠êÁâπÊÄß‰∫àÊ∏¨Áî®„ÅÆGraph Convolutional Network

    Architecture:
    - 3Â±§„ÅÆGCNConv
    - Global mean pooling
    - 2Â±§„ÅÆÂÖ®ÁµêÂêàÂ±§
    """
    def __init__(self, num_node_features, num_classes, hidden_channels=64):
        super(GCN_QM9, self).__init__()

        # GCNÂ±§
        self.conv1 = GCNConv(num_node_features, hidden_channels)
        self.conv2 = GCNConv(hidden_channels, hidden_channels)
        self.conv3 = GCNConv(hidden_channels, hidden_channels)

        # ÂÖ®ÁµêÂêàÂ±§
        self.lin1 = torch.nn.Linear(hidden_channels, hidden_channels // 2)
        self.lin2 = torch.nn.Linear(hidden_channels // 2, num_classes)

    def forward(self, x, edge_index, batch):
        """
        Parameters:
        -----------
        x : torch.Tensor (num_nodes, num_node_features)
            „Éé„Éº„ÉâÁâπÂæ¥Èáè
        edge_index : torch.Tensor (2, num_edges)
            „Ç®„ÉÉ„Ç∏„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
        batch : torch.Tensor (num_nodes,)
            „Éê„ÉÉ„ÉÅ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ

        Returns:
        --------
        out : torch.Tensor (batch_size, num_classes)
            ‰∫àÊ∏¨ÂÄ§
        """
        # GCNÂ±§1ÔºàÁï≥„ÅøËæº„Åø + Ê¥ªÊÄßÂåñ + „Éâ„É≠„ÉÉ„Éó„Ç¢„Ç¶„ÉàÔºâ
        x = self.conv1(x, edge_index)
        x = F.relu(x)
        x = F.dropout(x, p=0.2, training=self.training)

        # GCNÂ±§2
        x = self.conv2(x, edge_index)
        x = F.relu(x)
        x = F.dropout(x, p=0.2, training=self.training)

        # GCNÂ±§3
        x = self.conv3(x, edge_index)
        x = F.relu(x)

        # „Ç∞„É≠„Éº„Éê„É´„Éó„Éº„É™„É≥„Ç∞Ôºà„Éé„Éº„ÉâÁâπÂæ¥Èáè„ÇíÂàÜÂ≠ê„É¨„Éô„É´„Å´ÈõÜÁ¥ÑÔºâ
        x = global_mean_pool(x, batch)

        # ÂÖ®ÁµêÂêàÂ±§
        x = self.lin1(x)
        x = F.relu(x)
        x = F.dropout(x, p=0.3, training=self.training)

        x = self.lin2(x)
        return x

<h1>„É¢„Éá„É´„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„ÇπÂåñ</h1>
model = GCN_QM9(
    num_node_features=dataset.num_node_features,
    num_classes=1,  # HOMO-LUMO„ÇÆ„É£„ÉÉ„Éó„ÅÆ„Åø„Çí‰∫àÊ∏¨
    hidden_channels=64
)

print("===== GCN„É¢„Éá„É´ =====")
print(model)
print(f"\n„Éë„É©„É°„Éº„ÇøÊï∞: {sum(p.numel() for p in model.parameters()):,}")</code></pre>

<h3>3.3.4 „É¢„Éá„É´„ÅÆË®ìÁ∑¥</h3>

<pre><code class="language-python">from torch_geometric.loader import DataLoader
from sklearn.model_selection import train_test_split
import time

<h1>„Éá„Éº„Çø„Çª„ÉÉ„Éà„ÇíÂ∞è„Åï„Åè„Åô„ÇãÔºàÈ´òÈÄüÂåñ„ÅÆ„Åü„ÇÅ„ÄÅÂÆüÈöõ„Å´„ÅØÂÖ®„Éá„Éº„Çø„Çí‰ΩøÁî®Ôºâ</h1>
dataset = dataset[:10000]

<h1>HOMO-LUMO„ÇÆ„É£„ÉÉ„ÉóÔºàindex=4Ôºâ„ÅÆ„Åø„ÇíÁõÆÁöÑÂ§âÊï∞„Å´Ë®≠ÂÆö</h1>
for data in dataset:
    data.y = data.y[:, 4:5]  # shape: (1, 1)

<h1>„Éá„Éº„ÇøÂàÜÂâ≤Ôºà80% train, 10% val, 10% testÔºâ</h1>
train_dataset = dataset[:8000]
val_dataset = dataset[8000:9000]
test_dataset = dataset[9000:]

<h1>DataLoader„Çí‰ΩúÊàê</h1>
train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size=32, shuffle=False)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

<h1>„Éá„Éê„Ç§„ÇπË®≠ÂÆöÔºàGPUÂà©Áî®ÂèØËÉΩ„Å™„ÇâGPU„ÄÅ„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞CPUÔºâ</h1>
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = model.to(device)

<h1>ÊêçÂ§±Èñ¢Êï∞„Å®ÊúÄÈÅ©Âåñ„Ç¢„É´„Ç¥„É™„Ç∫„É†</h1>
criterion = torch.nn.MSELoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001, weight_decay=1e-5)

<h1>Ë®ìÁ∑¥Èñ¢Êï∞</h1>
def train(model, loader, optimizer, criterion, device):
    model.train()
    total_loss = 0

    for data in loader:
        data = data.to(device)
        optimizer.zero_grad()

        # È†Ü‰ºùÊí≠
        out = model(data.x, data.edge_index, data.batch)
        loss = criterion(out, data.y)

        # ÈÄÜ‰ºùÊí≠
        loss.backward()
        optimizer.step()

        total_loss += loss.item() * data.num_graphs

    return total_loss / len(loader.dataset)

<h1>Ê§úË®ºÈñ¢Êï∞</h1>
def evaluate(model, loader, criterion, device):
    model.eval()
    total_loss = 0

    with torch.no_grad():
        for data in loader:
            data = data.to(device)
            out = model(data.x, data.edge_index, data.batch)
            loss = criterion(out, data.y)
            total_loss += loss.item() * data.num_graphs

    return total_loss / len(loader.dataset)

<h1>Ë®ìÁ∑¥„É´„Éº„Éó</h1>
epochs = 50
train_losses = []
val_losses = []
best_val_loss = float('inf')

print("===== Ë®ìÁ∑¥ÈñãÂßã =====")
start_time = time.time()

for epoch in range(1, epochs + 1):
    train_loss = train(model, train_loader, optimizer, criterion, device)
    val_loss = evaluate(model, val_loader, criterion, device)

    train_losses.append(train_loss)
    val_losses.append(val_loss)

    # „Éô„Çπ„Éà„É¢„Éá„É´„Çí‰øùÂ≠ò
    if val_loss < best_val_loss:
        best_val_loss = val_loss
        torch.save(model.state_dict(), 'best_model_qm9.pt')

    if epoch % 10 == 0:
        print(f"Epoch {epoch:03d}, "
              f"Train Loss: {train_loss:.4f}, "
              f"Val Loss: {val_loss:.4f}")

training_time = time.time() - start_time
print(f"\nË®ìÁ∑¥ÂÆå‰∫Ü! ÊâÄË¶ÅÊôÇÈñì: {training_time:.2f}Áßí")

<h1>ÊúÄËâØ„É¢„Éá„É´„Çí„É≠„Éº„Éâ</h1>
model.load_state_dict(torch.load('best_model_qm9.pt'))

<h1>„ÉÜ„Çπ„Éà„Éá„Éº„Çø„ÅßË©ï‰æ°</h1>
test_loss = evaluate(model, test_loader, criterion, device)
test_mae = test_loss ** 0.5  # RMSE„ÇíMAE„ÅÆËøë‰ºº„Å®„Åó„Å¶‰ΩøÁî®

print(f"\n===== „ÉÜ„Çπ„ÉàÊÄßËÉΩ =====")
print(f"Test Loss (MSE): {test_loss:.4f}")
print(f"Test MAE (approx): {test_mae:.4f} eV")</code></pre>

<h3>3.3.5 Â≠¶ÁøíÊõ≤Á∑ö„ÅÆÂèØË¶ñÂåñ</h3>

<pre><code class="language-python">import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(train_losses, label='Train Loss', linewidth=2)
ax.plot(val_losses, label='Validation Loss', linewidth=2)
ax.set_xlabel('Epoch', fontsize=12)
ax.set_ylabel('Loss (MSE)', fontsize=12)
ax.set_title('GCNÂ≠¶ÁøíÊõ≤Á∑öÔºàQM9 HOMO-LUMO„ÇÆ„É£„ÉÉ„Éó‰∫àÊ∏¨Ôºâ', fontsize=14)
ax.legend(fontsize=11)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

<h1>‰∫àÊ∏¨ vs ÂÆüÊ∏¨„ÅÆ„Éó„É≠„ÉÉ„Éà</h1>
model.eval()
all_preds = []
all_targets = []

with torch.no_grad():
    for data in test_loader:
        data = data.to(device)
        out = model(data.x, data.edge_index, data.batch)
        all_preds.append(out.cpu().numpy())
        all_targets.append(data.y.cpu().numpy())

all_preds = np.concatenate(all_preds)
all_targets = np.concatenate(all_targets)

fig, ax = plt.subplots(figsize=(8, 8))
ax.scatter(all_targets, all_preds, alpha=0.6, s=10)
ax.plot([all_targets.min(), all_targets.max()],
        [all_targets.min(), all_targets.max()],
        'r--', lw=2, label='ÂÆåÂÖ®„Å™‰∫àÊ∏¨')
ax.set_xlabel('ÂÆüÊ∏¨ÂÄ§ (eV)', fontsize=12)
ax.set_ylabel('‰∫àÊ∏¨ÂÄ§ (eV)', fontsize=12)
ax.set_title('HOMO-LUMO„ÇÆ„É£„ÉÉ„Éó‰∫àÊ∏¨ÁµêÊûú', fontsize=14)
ax.legend(fontsize=11)
ax.grid(True, alpha=0.3)

<h1>R¬≤„Çπ„Ç≥„Ç¢„ÇíË®àÁÆó</h1>
from sklearn.metrics import r2_score
r2 = r2_score(all_targets, all_preds)
mae = np.mean(np.abs(all_targets - all_preds))

ax.text(0.05, 0.95, f'R¬≤ = {r2:.3f}\nMAE = {mae:.3f} eV',
        transform=ax.transAxes, fontsize=12, verticalalignment='top',
        bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

plt.tight_layout()
plt.show()

print(f"===== ÊúÄÁµÇÊÄßËÉΩ =====")
print(f"R¬≤ score: {r2:.4f}")
print(f"MAE: {mae:.4f} eV")</code></pre>

---

<h2>3.4 Materials Project„Éá„Éº„Çø„ÅßÁµêÊô∂ÁâπÊÄß‰∫àÊ∏¨</h2>

<h3>3.4.1 ÁµêÊô∂ÊßãÈÄ†„ÅÆ„Ç∞„É©„ÉïË°®Áèæ</h3>

ÁµêÊô∂„ÅØÂë®ÊúüÁöÑ„Å™ÊßãÈÄ†„ÇíÊåÅ„Å§„Åü„ÇÅ„ÄÅÂàÜÂ≠ê„Å®„ÅØÁï∞„Å™„ÇãÊâ±„ÅÑ„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ

<pre><code class="language-python">from pymatgen.core import Structure
from pymatgen.ext.matproj import MPRester
import torch
from torch_geometric.data import Data

def structure_to_graph(structure, cutoff=5.0):
    """
    pymatgen Structure„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí„Ç∞„É©„Éï„Å´Â§âÊèõ

    Parameters:
    -----------
    structure : pymatgen.core.Structure
        ÁµêÊô∂ÊßãÈÄ†
    cutoff : float
        „Ç®„ÉÉ„Ç∏„Çí‰ΩúÊàê„Åô„ÇãË∑ùÈõ¢„ÅÆ„Ç´„ÉÉ„Éà„Ç™„ÉïÔºà√ÖÔºâ

    Returns:
    --------
    data : torch_geometric.data.Data
        „Ç∞„É©„Éï„Éá„Éº„Çø
    """
    # „Éé„Éº„ÉâÁâπÂæ¥ÈáèÔºàÂéüÂ≠êÁï™Âè∑Ôºâ
    atomic_numbers = [site.specie.Z for site in structure]
    x = torch.tensor(atomic_numbers, dtype=torch.float).view(-1, 1)

    # „Ç®„ÉÉ„Ç∏„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Å®„Ç®„ÉÉ„Ç∏ÁâπÂæ¥ÈáèÔºàÂéüÂ≠êÈñìË∑ùÈõ¢Ôºâ
    edge_indices = []
    edge_attrs = []

    for i, site_i in enumerate(structure):
        for j, site_j in enumerate(structure):
            if i != j:
                distance = structure.get_distance(i, j)
                if distance < cutoff:
                    edge_indices.append([i, j])
                    edge_attrs.append([distance])

    edge_index = torch.tensor(edge_indices, dtype=torch.long).t().contiguous()
    edge_attr = torch.tensor(edge_attrs, dtype=torch.float)

    data = Data(x=x, edge_index=edge_index, edge_attr=edge_attr)
    return data

<h1>Materials Project„Åã„ÇâLiÂåñÂêàÁâ©„ÇíÂèñÂæóÔºà„Çµ„É≥„Éó„É´Ôºâ</h1>
<h1>Ê≥®ÊÑè: ÂÆüÈöõ„Å´„ÅØAPI„Ç≠„Éº„ÅåÂøÖË¶Å</h1>
<h1>API_KEY = "your_api_key_here"</h1>
<h1>with MPRester(API_KEY) as mpr:</h1>
<h1>    entries = mpr.query(</h1>
<h1>        criteria={"elements": {"$all": ["Li"]}, "nelements": 2},</h1>
<h1>        properties=["structure", "band_gap"]</h1>
<h1>    )</h1>

<h1>„Çµ„É≥„Éó„É´„Éá„Éº„ÇøÔºàLiClÁµêÊô∂Ôºâ</h1>
from pymatgen.core import Lattice, Structure

<h1>LiCl Â≤©Â°©ÂûãÊßãÈÄ†</h1>
lattice = Lattice.cubic(5.14)  # Ê†ºÂ≠êÂÆöÊï∞
species = ["Li", "Li", "Li", "Li", "Cl", "Cl", "Cl", "Cl"]
coords = [
    [0, 0, 0], [0.5, 0.5, 0], [0.5, 0, 0.5], [0, 0.5, 0.5],
    [0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5], [0.5, 0.5, 0.5]
]
structure = Structure(lattice, species, coords)

<h1>„Ç∞„É©„Éï„Å´Â§âÊèõ</h1>
data = structure_to_graph(structure, cutoff=4.0)

print("===== LiClÁµêÊô∂„ÅÆ„Ç∞„É©„ÉïË°®Áèæ =====")
print(f"„Éé„Éº„ÉâÊï∞ÔºàÂéüÂ≠êÊï∞Ôºâ: {data.num_nodes}")
print(f"„Ç®„ÉÉ„Ç∏Êï∞ÔºàË∑ùÈõ¢ < 4.0√Ö„ÅÆÂéüÂ≠ê„Éö„Ç¢Ôºâ: {data.num_edges}")
print(f"„Éé„Éº„ÉâÁâπÂæ¥Èáè: {data.x}")
print(f"\n„Ç®„ÉÉ„Ç∏ÁâπÂæ¥ÈáèÔºàË∑ùÈõ¢Ôºâ„ÅÆÁµ±Ë®à:")
print(f"  ÊúÄÂ∞èË∑ùÈõ¢: {data.edge_attr.min().item():.2f} √Ö")
print(f"  ÊúÄÂ§ßË∑ùÈõ¢: {data.edge_attr.max().item():.2f} √Ö")
print(f"  Âπ≥ÂùáË∑ùÈõ¢: {data.edge_attr.mean().item():.2f} √Ö")</code></pre>

<h3>3.4.2 ÁµêÊô∂ÁâπÊÄß‰∫àÊ∏¨„É¢„Éá„É´ÔºàCrystal Graph Convolutional NetworkÔºâ</h3>

<pre><code class="language-python">import torch
import torch.nn.functional as F
from torch_geometric.nn import GCNConv, global_add_pool

class CGCN(torch.nn.Module):
    """
    Crystal Graph Convolutional Network
    ÁµêÊô∂„ÅÆ„Éê„É≥„Éâ„ÇÆ„É£„ÉÉ„Éó„Çí‰∫àÊ∏¨
    """
    def __init__(self, num_node_features=1, hidden_channels=64):
        super(CGCN, self).__init__()

        # „Éé„Éº„ÉâÂüã„ÇÅËæº„ÅøÂ±§
        self.embedding = torch.nn.Linear(num_node_features, hidden_channels)

        # GCNÂ±§Ôºà„Ç®„ÉÉ„Ç∏ÁâπÂæ¥Èáè„ÇíËÄÉÊÖÆ„Åô„ÇãÂ†¥Âêà„ÅØSchNet„Å™„Å©„Çí‰ΩøÁî®Ôºâ
        self.conv1 = GCNConv(hidden_channels, hidden_channels)
        self.conv2 = GCNConv(hidden_channels, hidden_channels)
        self.conv3 = GCNConv(hidden_channels, hidden_channels)

        # ÂÖ®ÁµêÂêàÂ±§
        self.lin1 = torch.nn.Linear(hidden_channels, hidden_channels // 2)
        self.lin2 = torch.nn.Linear(hidden_channels // 2, 1)

    def forward(self, x, edge_index, edge_attr, batch):
        # „Éé„Éº„ÉâÂüã„ÇÅËæº„Åø
        x = self.embedding(x)
        x = F.relu(x)

        # GCNÂ±§
        x = self.conv1(x, edge_index)
        x = F.relu(x)
        x = F.dropout(x, p=0.2, training=self.training)

        x = self.conv2(x, edge_index)
        x = F.relu(x)
        x = F.dropout(x, p=0.2, training=self.training)

        x = self.conv3(x, edge_index)
        x = F.relu(x)

        # „Ç∞„É≠„Éº„Éê„É´„Éó„Éº„É™„É≥„Ç∞ÔºàÁµêÊô∂„É¨„Éô„É´„Å´ÈõÜÁ¥ÑÔºâ
        x = global_add_pool(x, batch)

        # ÂÖ®ÁµêÂêàÂ±§
        x = self.lin1(x)
        x = F.relu(x)
        x = self.lin2(x)

        return x

<h1>„É¢„Éá„É´„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„ÇπÂåñ</h1>
model_crystal = CGCN(num_node_features=1, hidden_channels=128)

print("===== Crystal Graph Convolutional Network =====")
print(model_crystal)
print(f"\n„Éë„É©„É°„Éº„ÇøÊï∞: {sum(p.numel() for p in model_crystal.parameters()):,}")</code></pre>

<h3>3.4.3 Ê®°Êì¨„Éá„Éº„Çø„Åß„ÅÆË®ìÁ∑¥„Éá„É¢</h3>

<pre><code class="language-python"><h1>Ê®°Êì¨„Éá„Éº„Çø„Çª„ÉÉ„Éà‰ΩúÊàêÔºàÂÆüÈöõ„ÅØMaterials Project„Éá„Éº„Çø„Çí‰ΩøÁî®Ôºâ</h1>
crystal_dataset = []

for i in range(200):
    num_atoms = torch.randint(4, 12, (1,)).item()
    x = torch.randint(1, 20, (num_atoms, 1)).float()  # ÂéüÂ≠êÁï™Âè∑

    # „É©„É≥„ÉÄ„É†„Å™„Ç®„ÉÉ„Ç∏ÔºàË∑ùÈõ¢„Åß„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Åó„Åü„Å®‰ªÆÂÆöÔºâ
    edge_index = torch.randint(0, num_atoms, (2, num_atoms * 4))
    edge_attr = torch.rand(num_atoms * 4, 1) * 5.0  # Ë∑ùÈõ¢ (0-5√Ö)

    # „Éê„É≥„Éâ„ÇÆ„É£„ÉÉ„ÉóÔºàÂéüÂ≠êÁï™Âè∑„ÅÆÈñ¢Êï∞„Å®„Åó„Å¶Ê®°Êì¨Ôºâ
    y = (x.mean() / 10.0 + torch.randn(1) * 0.5).clamp(0, 10)

    data = Data(x=x, edge_index=edge_index, edge_attr=edge_attr, y=y)
    crystal_dataset.append(data)

<h1>„Éá„Éº„ÇøÂàÜÂâ≤</h1>
train_crystals = crystal_dataset[:160]
test_crystals = crystal_dataset[160:]

train_loader_crystal = DataLoader(train_crystals, batch_size=16, shuffle=True)
test_loader_crystal = DataLoader(test_crystals, batch_size=16, shuffle=False)

<h1>Ë®ìÁ∑¥ÔºàÁ∞°Áï•ÁâàÔºâ</h1>
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model_crystal = model_crystal.to(device)
optimizer = torch.optim.Adam(model_crystal.parameters(), lr=0.001)
criterion = torch.nn.MSELoss()

print("===== ÁµêÊô∂„Éê„É≥„Éâ„ÇÆ„É£„ÉÉ„Éó‰∫àÊ∏¨Ë®ìÁ∑¥ =====")
for epoch in range(1, 51):
    model_crystal.train()
    total_loss = 0

    for data in train_loader_crystal:
        data = data.to(device)
        optimizer.zero_grad()
        out = model_crystal(data.x, data.edge_index, data.edge_attr, data.batch)
        loss = criterion(out, data.y)
        loss.backward()
        optimizer.step()
        total_loss += loss.item() * data.num_graphs

    if epoch % 10 == 0:
        train_loss = total_loss / len(train_crystals)
        print(f"Epoch {epoch:03d}, Train Loss: {train_loss:.4f}")

<h1>„ÉÜ„Çπ„ÉàË©ï‰æ°</h1>
model_crystal.eval()
test_preds = []
test_targets = []

with torch.no_grad():
    for data in test_loader_crystal:
        data = data.to(device)
        out = model_crystal(data.x, data.edge_index, data.edge_attr, data.batch)
        test_preds.append(out.cpu().numpy())
        test_targets.append(data.y.cpu().numpy())

test_preds = np.concatenate(test_preds)
test_targets = np.concatenate(test_targets)

test_mae = np.mean(np.abs(test_targets - test_preds))
test_r2 = r2_score(test_targets, test_preds)

print(f"\n===== „ÉÜ„Çπ„ÉàÊÄßËÉΩ =====")
print(f"MAE: {test_mae:.4f} eV")
print(f"R¬≤: {test_r2:.4f}")</code></pre>

---

<h2>3.5 „Éà„É¨„Éº„Éã„É≥„Ç∞„ÅÆ„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ</h2>

<h3>3.5.1 Â≠¶ÁøíÁéá„Çπ„Ç±„Ç∏„É•„Éº„É™„É≥„Ç∞</h3>

<pre><code class="language-python">from torch.optim.lr_scheduler import ReduceLROnPlateau

<h1>Â≠¶ÁøíÁéá„ÇíÂãïÁöÑ„Å´Ë™øÊï¥</h1>
scheduler = ReduceLROnPlateau(
    optimizer,
    mode='min',
    factor=0.5,     # Â≠¶ÁøíÁéá„ÇíÂçäÂàÜ„Å´
    patience=10,    # 10„Ç®„Éù„ÉÉ„ÇØÊîπÂñÑ„Å™„Åó„ÅßË™øÊï¥
    verbose=True
)

<h1>Ë®ìÁ∑¥„É´„Éº„ÉóÂÜÖ„Åß‰ΩøÁî®</h1>
for epoch in range(epochs):
    train_loss = train(model, train_loader, optimizer, criterion, device)
    val_loss = evaluate(model, val_loader, criterion, device)

    # Ê§úË®ºÊêçÂ§±„Å´Âü∫„Å•„ÅÑ„Å¶Â≠¶ÁøíÁéá„ÇíË™øÊï¥
    scheduler.step(val_loss)</code></pre>

<h3>3.5.2 Early Stopping</h3>

<pre><code class="language-python">class EarlyStopping:
    """
    Early Stopping„ÇØ„É©„Çπ
    Ê§úË®ºÊêçÂ§±„ÅåÊîπÂñÑ„Åó„Å™„Åè„Å™„Å£„Åü„ÇâË®ìÁ∑¥„ÇíÂÅúÊ≠¢
    """
    def __init__(self, patience=20, min_delta=0):
        self.patience = patience
        self.min_delta = min_delta
        self.counter = 0
        self.best_loss = None
        self.early_stop = False

    def __call__(self, val_loss):
        if self.best_loss is None:
            self.best_loss = val_loss
        elif val_loss > self.best_loss - self.min_delta:
            self.counter += 1
            if self.counter >= self.patience:
                self.early_stop = True
        else:
            self.best_loss = val_loss
            self.counter = 0

<h1>‰ΩøÁî®‰æã</h1>
early_stopping = EarlyStopping(patience=20)

for epoch in range(epochs):
    train_loss = train(model, train_loader, optimizer, criterion, device)
    val_loss = evaluate(model, val_loader, criterion, device)

    early_stopping(val_loss)
    if early_stopping.early_stop:
        print(f"Early stopping at epoch {epoch}")
        break</code></pre>

<h3>3.5.3 „Éá„Éº„ÇøÊã°ÂºµÔºà„Ç∞„É©„Éï„ÅÆÊëÇÂãïÔºâ</h3>

<pre><code class="language-python">import torch
from torch_geometric.utils import dropout_edge

def augment_graph(data, drop_edge_prob=0.1, noise_scale=0.01):
    """
    „Ç∞„É©„Éï„ÅÆ„Éá„Éº„ÇøÊã°Âºµ

    Parameters:
    -----------
    data : Data
        ÂÖÉ„ÅÆ„Ç∞„É©„Éï
    drop_edge_prob : float
        „Ç®„ÉÉ„Ç∏„Çí„Éâ„É≠„ÉÉ„Éó„Åô„ÇãÁ¢∫Áéá
    noise_scale : float
        „Éé„Éº„ÉâÁâπÂæ¥Èáè„Å´Âä†„Åà„Çã„Éé„Ç§„Ç∫„ÅÆ„Çπ„Ç±„Éº„É´

    Returns:
    --------
    augmented_data : Data
        Êã°Âºµ„Åï„Çå„Åü„Ç∞„É©„Éï
    """
    # „Ç®„ÉÉ„Ç∏„ÅÆ„Éâ„É≠„ÉÉ„Éó„Ç¢„Ç¶„Éà
    edge_index, edge_mask = dropout_edge(data.edge_index, p=drop_edge_prob)

    # „Éé„Éº„ÉâÁâπÂæ¥Èáè„Å´„Éé„Ç§„Ç∫„ÇíËøΩÂä†
    noise = torch.randn_like(data.x) * noise_scale
    x = data.x + noise

    augmented_data = Data(x=x, edge_index=edge_index, y=data.y)
    return augmented_data

<h1>‰ΩøÁî®‰æã</h1>
original = dataset[0]
augmented = augment_graph(original, drop_edge_prob=0.15)

print(f"ÂÖÉ„ÅÆ„Ç®„ÉÉ„Ç∏Êï∞: {original.num_edges}")
print(f"Êã°ÂºµÂæå„ÅÆ„Ç®„ÉÉ„Ç∏Êï∞: {augmented.num_edges}")</code></pre>

---

<h2>3.6 „É¢„Éá„É´ÊÄßËÉΩ„ÅÆË©ï‰æ°„Å®ÂèØË¶ñÂåñ</h2>

<h3>3.6.1 Ë©ï‰æ°ÊåáÊ®ô„ÅÆË®àÁÆó</h3>

<pre><code class="language-python">from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

def evaluate_regression(y_true, y_pred):
    """
    ÂõûÂ∏∞„É¢„Éá„É´„ÅÆË©ï‰æ°ÊåáÊ®ô„ÇíË®àÁÆó
    """
    mae = mean_absolute_error(y_true, y_pred)
    mse = mean_squared_error(y_true, y_pred)
    rmse = np.sqrt(mse)
    r2 = r2_score(y_true, y_pred)

    # Mean Absolute Percentage Error
    mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100

    return {
        'MAE': mae,
        'MSE': mse,
        'RMSE': rmse,
        'R¬≤': r2,
        'MAPE': mape
    }

<h1>‰ΩøÁî®‰æã</h1>
metrics = evaluate_regression(test_targets, test_preds)

print("===== Ë©ï‰æ°ÊåáÊ®ô =====")
for name, value in metrics.items():
    print(f"{name}: {value:.4f}")</code></pre>

<h3>3.6.2 ÊÆãÂ∑Æ„Éó„É≠„ÉÉ„Éà</h3>

<pre><code class="language-python">import matplotlib.pyplot as plt

def plot_residuals(y_true, y_pred):
    """
    ÊÆãÂ∑Æ„Éó„É≠„ÉÉ„Éà
    """
    residuals = y_true - y_pred

    fig, axes = plt.subplots(1, 2, figsize=(14, 5))

    # ÊÆãÂ∑Æ vs ‰∫àÊ∏¨ÂÄ§
    axes[0].scatter(y_pred, residuals, alpha=0.6, s=20)
    axes[0].axhline(y=0, color='r', linestyle='--', lw=2)
    axes[0].set_xlabel('‰∫àÊ∏¨ÂÄ§', fontsize=12)
    axes[0].set_ylabel('ÊÆãÂ∑ÆÔºàÂÆüÊ∏¨ - ‰∫àÊ∏¨Ôºâ', fontsize=12)
    axes[0].set_title('ÊÆãÂ∑Æ„Éó„É≠„ÉÉ„Éà', fontsize=14)
    axes[0].grid(True, alpha=0.3)

    # ÊÆãÂ∑Æ„ÅÆ„Éí„Çπ„Éà„Ç∞„É©„É†
    axes[1].hist(residuals, bins=30, alpha=0.7, edgecolor='black')
    axes[1].set_xlabel('ÊÆãÂ∑Æ', fontsize=12)
    axes[1].set_ylabel('È†ªÂ∫¶', fontsize=12)
    axes[1].set_title('ÊÆãÂ∑ÆÂàÜÂ∏É', fontsize=14)
    axes[1].axvline(x=0, color='r', linestyle='--', lw=2)
    axes[1].grid(True, alpha=0.3, axis='y')

    plt.tight_layout()
    plt.show()

<h1>‰ΩøÁî®‰æã</h1>
plot_residuals(test_targets, test_preds)</code></pre>

<h3>3.6.3 „É¢„Éá„É´ÊØîËºÉ</h3>

<pre><code class="language-python">import pandas as pd
import matplotlib.pyplot as plt

<h1>Ë§áÊï∞„É¢„Éá„É´„ÅÆÊÄßËÉΩ„ÇíÊØîËºÉ</h1>
models_performance = {
    'GCN (3Â±§)': {'MAE': 0.32, 'R¬≤': 0.88, 'Time': 45.2},
    'GAT (2Â±§)': {'MAE': 0.28, 'R¬≤': 0.91, 'Time': 62.8},
    'SchNet': {'MAE': 0.25, 'R¬≤': 0.93, 'Time': 89.5},
    'MPNN': {'MAE': 0.30, 'R¬≤': 0.90, 'Time': 55.1},
}

df = pd.DataFrame(models_performance).T

<h1>„Éó„É≠„ÉÉ„Éà</h1>
fig, axes = plt.subplots(1, 3, figsize=(16, 4))

<h1>MAEÊØîËºÉ</h1>
df['MAE'].plot(kind='bar', ax=axes[0], color='steelblue')
axes[0].set_ylabel('MAE (eV)', fontsize=12)
axes[0].set_title('Âπ≥ÂùáÁµ∂ÂØæË™§Â∑ÆÔºà‰Ωé„ÅÑ„Åª„Å©ËâØ„ÅÑÔºâ', fontsize=13)
axes[0].tick_params(axis='x', rotation=45)
axes[0].grid(True, alpha=0.3, axis='y')

<h1>R¬≤ÊØîËºÉ</h1>
df['R¬≤'].plot(kind='bar', ax=axes[1], color='forestgreen')
axes[1].set_ylabel('R¬≤ Score', fontsize=12)
axes[1].set_title('Ê±∫ÂÆö‰øÇÊï∞ÔºàÈ´ò„ÅÑ„Åª„Å©ËâØ„ÅÑÔºâ', fontsize=13)
axes[1].tick_params(axis='x', rotation=45)
axes[1].grid(True, alpha=0.3, axis='y')
axes[1].set_ylim(0.8, 1.0)

<h1>Ë®ìÁ∑¥ÊôÇÈñìÊØîËºÉ</h1>
df['Time'].plot(kind='bar', ax=axes[2], color='coral')
axes[2].set_ylabel('Ë®ìÁ∑¥ÊôÇÈñì (Áßí)', fontsize=12)
axes[2].set_title('Ë®àÁÆó„Ç≥„Çπ„Éà', fontsize=13)
axes[2].tick_params(axis='x', rotation=45)
axes[2].grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.show()</code></pre>

---

<h2>3.7 „Éà„É©„Éñ„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞</h2>

<h3>3.7.1 „Çà„Åè„ÅÇ„Çã„Ç®„É©„Éº„Å®Ëß£Ê±∫Á≠ñ</h3>

| „Ç®„É©„Éº | ÂéüÂõ† | Ëß£Ê±∫ÊñπÊ≥ï |
|--------|------|----------|
| <code>RuntimeError: CUDA out of memory</code> | GPU „É°„É¢„É™‰∏çË∂≥ | „Éê„ÉÉ„ÉÅ„Çµ„Ç§„Ç∫ÂâäÊ∏õ„ÄÅ„É¢„Éá„É´„ÅÆÂ∞èÂûãÂåñ„ÄÅCPU‰ΩøÁî® |
| <code>AssertionError: edge_index not contiguous</code> | „Ç®„ÉÉ„Ç∏„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆ„É°„É¢„É™ÈÖçÁΩÆ | <code>edge_index = edge_index.t().contiguous()</code> |
| <code>ValueError: too many values to unpack</code> | Data„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ±ûÊÄß‰∏çË∂≥ | <code>x</code>, <code>edge_index</code>, <code>batch</code>„ÅåÊ≠£„Åó„ÅèË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç |
| <code>RuntimeError: Expected all tensors on same device</code> | „ÉÜ„É≥„ÇΩ„É´„ÅÆ„Éá„Éê„Ç§„Çπ‰∏ç‰∏ÄËá¥ | <code>data = data.to(device)</code>„ÇíÁ¢∫Ë™ç |

<h3>3.7.2 „Éá„Éê„ÉÉ„Ç∞„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà</h3>

<pre><code class="language-python"><h1>„Éá„Éº„Çø„ÅÆÁ¢∫Ë™ç</h1>
print(f"„Éé„Éº„ÉâÊï∞: {data.num_nodes}")
print(f"„Ç®„ÉÉ„Ç∏Êï∞: {data.num_edges}")
print(f"Â≠§Á´ã„Éé„Éº„Éâ: {data.contains_isolated_nodes()}")
print(f"Ëá™Â∑±„É´„Éº„Éó: {data.contains_self_loops()}")

<h1>„ÉÜ„É≥„ÇΩ„É´„ÅÆÂΩ¢Áä∂Á¢∫Ë™ç</h1>
print(f"x.shape: {data.x.shape}")
print(f"edge_index.shape: {data.edge_index.shape}")
print(f"y.shape: {data.y.shape}")

<h1>„Éá„Éê„Ç§„Çπ„ÅÆÁ¢∫Ë™ç</h1>
print(f"x device: {data.x.device}")
print(f"edge_index device: {data.edge_index.device}")

<h1>„Ç®„ÉÉ„Ç∏„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆÁØÑÂõ≤Á¢∫Ë™ç</h1>
print(f"max edge index: {data.edge_index.max().item()}")
print(f"num_nodes: {data.num_nodes}")
assert data.edge_index.max().item() < data.num_nodes, "„Ç®„ÉÉ„Ç∏„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Åå„Éé„Éº„ÉâÊï∞„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô"</code></pre>

---

<h2>3.8 Êú¨Á´†„ÅÆ„Åæ„Å®„ÇÅ</h2>

<h3>Â≠¶„Çì„Å†„Åì„Å®</h3>

1. <strong>PyTorch GeometricÁí∞Â¢ÉÊßãÁØâ</strong>
   - Conda„ÄÅpip„ÄÅGoogle Colab„ÅÆ3„Å§„ÅÆÊñπÊ≥ï
   - „Éê„Éº„Ç∏„Éß„É≥‰∫íÊèõÊÄß„ÅÆÁ¢∫Ë™ç„Å®„Éà„É©„Éñ„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞

2. <strong>„Éá„Éº„ÇøÊßãÈÄ†„ÅÆÁêÜËß£</strong>
   - Data„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÊßãÈÄ†Ôºàx, edge_index, batchÔºâ
   - RDKit„Åã„Çâ„ÅÆ„Ç∞„É©„ÉïÂ§âÊèõ
   - DataLoader„Å´„Çà„Çã„Éê„ÉÉ„ÉÅÂá¶ÁêÜ

3. <strong>QM9„Éá„Éº„Çø„Çª„ÉÉ„Éà„Åß„ÅÆÂÆüË∑µ</strong>
   - 134,000ÂàÜÂ≠ê„ÅÆÈáèÂ≠êÂåñÂ≠¶„Éá„Éº„Çø„Çª„ÉÉ„Éà
   - GCN„É¢„Éá„É´„ÅÆÂÆüË£Ö„Å®Ë®ìÁ∑¥
   - HOMO-LUMO„ÇÆ„É£„ÉÉ„Éó‰∫àÊ∏¨ÔºàMAE < 0.5 eVÁõÆÊ®ôÔºâ

4. <strong>ÁµêÊô∂ÁâπÊÄß‰∫àÊ∏¨</strong>
   - Materials ProjectÁµêÊô∂„Éá„Éº„Çø„ÅÆ„Ç∞„É©„ÉïË°®Áèæ
   - Crystal Graph Convolutional Network
   - „Éê„É≥„Éâ„ÇÆ„É£„ÉÉ„Éó‰∫àÊ∏¨

5. <strong>Ë®ìÁ∑¥„ÅÆ„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ</strong>
   - Â≠¶ÁøíÁéá„Çπ„Ç±„Ç∏„É•„Éº„É™„É≥„Ç∞
   - Early Stopping
   - „Éá„Éº„ÇøÊã°ÂºµÔºà„Ç∞„É©„Éï„ÅÆÊëÇÂãïÔºâ

6. <strong>Ë©ï‰æ°„Å®ÂèØË¶ñÂåñ</strong>
   - MAE„ÄÅMSE„ÄÅR¬≤„Å™„Å©„ÅÆÊåáÊ®ô
   - ÊÆãÂ∑Æ„Éó„É≠„ÉÉ„Éà
   - „É¢„Éá„É´Èñì„ÅÆÊÄßËÉΩÊØîËºÉ

<h3>ÈáçË¶Å„Å™„Éù„Ç§„É≥„Éà</h3>

- ‚úÖ PyTorch Geometric„ÅØÊùêÊñô„ÉªÂàÜÂ≠ê„ÅÆGNNÂÆüË£Ö„Å´ÊúÄÈÅ©
- ‚úÖ QM9„ÅØÂàùÂ≠¶ËÄÖ„Å´ÊúÄÈÅ©„Å™ÂàÜÂ≠êÁâπÊÄß‰∫àÊ∏¨„Éô„É≥„ÉÅ„Éû„Éº„ÇØ
- ‚úÖ „Ç∞„É©„Éï„ÅÆÂâçÂá¶ÁêÜÔºàÂ≠§Á´ã„Éé„Éº„Éâ„ÄÅËá™Â∑±„É´„Éº„Éó„ÅÆÁ¢∫Ë™çÔºâ„ÅåÈáçË¶Å
- ‚úÖ „Éê„ÉÉ„ÉÅÂá¶ÁêÜ„Åß„ÅØ<code>batch</code>„ÉÜ„É≥„ÇΩ„É´„ÅåÂêÑ„Éé„Éº„Éâ„ÅÆÊâÄÂ±û„ÇíÁ§∫„Åô
- ‚úÖ Â≠¶ÁøíÁéá„Çπ„Ç±„Ç∏„É•„Éº„É™„É≥„Ç∞„Å®Early Stopping„ÅßÈÅéÂ≠¶Áøí„ÇíÈò≤Ê≠¢

<h3>Ê¨°„ÅÆÁ´†„Å∏</h3>

Á¨¨4Á´†„Åß„ÅØ„ÄÅÈ´òÂ∫¶„Å™GNNÊäÄË°ì„ÇíÂ≠¶„Å≥„Åæ„ÅôÔºö
- „Ç∞„É©„Éï„Éó„Éº„É™„É≥„Ç∞ÔºàÈöéÂ±§ÁöÑË°®ÁèæÔºâ
- „Ç®„ÉÉ„Ç∏ÁâπÂæ¥Èáè„ÅÆÊ¥ªÁî®
- 3DÂπæ‰ΩïÊÉÖÂ†±„ÅÆÁµÑËæº„ÅøÔºàSchNet„ÄÅDimeNetÔºâ
- Á≠âÂ§âGNNÔºàE(3)-equivariantÔºâ
- GNNExplainer„Å´„Çà„ÇãËß£ÈáàÂèØËÉΩÊÄß

<strong>[Á¨¨4Á´†ÔºöÈ´òÂ∫¶„Å™GNNÊäÄË°ì ‚Üí](./chapter-4.md)</strong>

---

<h2>ÊºîÁøíÂïèÈ°å</h2>

<h3>ÂïèÈ°å1ÔºàÈõ£ÊòìÂ∫¶ÔºöeasyÔºâ</h3>

PyTorch Geometric„ÅÆData„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´Âê´„Åæ„Çå„Çã‰∏ªË¶Å„Å™Â±ûÊÄß„Çí3„Å§Êåô„Åí„ÄÅ„Åù„Çå„Åû„Çå„ÅÆÂΩπÂâ≤„ÇíË™¨Êòé„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

<details>
<summary>„Éí„É≥„Éà</summary>

„Éé„Éº„Éâ„ÄÅ„Ç®„ÉÉ„Ç∏„ÄÅ„Éê„ÉÉ„ÉÅ„Å´Èñ¢„Åô„ÇãÊÉÖÂ†±„ÇíÊ†ºÁ¥ç„Åô„ÇãÂ±ûÊÄß„ÇíËÄÉ„Åà„Åæ„Åó„Çá„ÅÜ„ÄÇ

</details>

<details>
<summary>Ëß£Á≠î‰æã</summary>

<strong>‰∏ªË¶Å„Å™3„Å§„ÅÆÂ±ûÊÄß</strong>:

1. <strong><code>x</code> („Éé„Éº„ÉâÁâπÂæ¥Èáè)</strong>
   - ÂΩ¢Áä∂: <code>(num_nodes, num_node_features)</code>
   - ÂΩπÂâ≤: ÂêÑ„Éé„Éº„ÉâÔºàÂéüÂ≠êÔºâ„ÅÆÁâπÂæ¥Èáè„ÇíÊ†ºÁ¥ç
   - ‰æã: ÂéüÂ≠êÁï™Âè∑„ÄÅÈõªÊ∞óÈô∞ÊÄßÂ∫¶„ÄÅÂΩ¢ÂºèÈõªËç∑„Å™„Å©

2. <strong><code>edge_index</code> („Ç®„ÉÉ„Ç∏„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ)</strong>
   - ÂΩ¢Áä∂: <code>(2, num_edges)</code>
   - ÂΩπÂâ≤: „Ç∞„É©„Éï„ÅÆÊé•Á∂öÈñ¢‰øÇÔºàÈö£Êé•„É™„Çπ„ÉàÂΩ¢ÂºèÔºâ
   - ‰æã: <code>[[0, 1], [1, 2]]</code> ‚Üí „Éé„Éº„Éâ0„Å®„Éé„Éº„Éâ1„ÅåÊé•Á∂ö

3. <strong><code>batch</code> („Éê„ÉÉ„ÉÅ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ)</strong>
   - ÂΩ¢Áä∂: <code>(num_nodes,)</code>
   - ÂΩπÂâ≤: ÂêÑ„Éé„Éº„Éâ„Åå„Å©„ÅÆ„Ç∞„É©„Éï„Å´Â±û„Åô„Çã„Åã„ÇíÁ§∫„Åô
   - ‰æã: <code>[0, 0, 1, 1, 2]</code> ‚Üí „Éé„Éº„Éâ0,1„ÅØ„Ç∞„É©„Éï0„ÄÅ„Éé„Éº„Éâ2,3„ÅØ„Ç∞„É©„Éï1

<strong>ËøΩÂä†„ÅÆÈáçË¶Å„Å™Â±ûÊÄß</strong>:
- <code>edge_attr</code>: „Ç®„ÉÉ„Ç∏ÁâπÂæ¥ÈáèÔºàÁµêÂêà„Çø„Ç§„Éó„ÄÅË∑ùÈõ¢„Å™„Å©Ôºâ
- <code>y</code>: ÁõÆÁöÑÂ§âÊï∞ÔºàÂàÜÂ≠êÁâπÊÄß„ÄÅÁµêÊô∂ÁâπÊÄßÔºâ

</details>

---

<h3>ÂïèÈ°å2ÔºàÈõ£ÊòìÂ∫¶ÔºömediumÔºâ</h3>

QM9„Éá„Éº„Çø„Çª„ÉÉ„Éà„ÅßË®ìÁ∑¥„Åó„ÅüGCN„É¢„Éá„É´„ÅÆMAE„Åå0.8 eV„Åß„Åó„Åü„ÄÇÊÄßËÉΩ„ÇíÂêë‰∏ä„Åï„Åõ„Çã„Åü„ÇÅ„ÅÆ3„Å§„ÅÆÂÖ∑‰ΩìÁöÑ„Å™„Ç¢„Éó„É≠„Éº„ÉÅ„ÇíÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

<details>
<summary>„Éí„É≥„Éà</summary>

„É¢„Éá„É´„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„ÄÅ„Éè„Ç§„Éë„Éº„Éë„É©„É°„Éº„Çø„ÄÅ„Éá„Éº„ÇøÂâçÂá¶ÁêÜ„ÅÆ3„Å§„ÅÆË¶≥ÁÇπ„Åã„ÇâËÄÉ„Åà„Åæ„Åó„Çá„ÅÜ„ÄÇ

</details>

<details>
<summary>Ëß£Á≠î‰æã</summary>

<strong>„Ç¢„Éó„É≠„Éº„ÉÅ1: „É¢„Éá„É´„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„ÅÆÊîπÂñÑ</strong>

<pre><code class="language-python"><h1>GAT„É¨„Ç§„É§„Éº„Çí‰ΩøÁî®ÔºàÊ≥®ÊÑèÊ©üÊßã„ÅßÈáçË¶Å„Å™ÁµêÂêà„ÇíÂ≠¶ÁøíÔºâ</h1>
from torch_geometric.nn import GATConv

class ImprovedGNN(torch.nn.Module):
    def __init__(self, num_node_features, hidden_channels=128):
        super().__init__()
        # GAT„É¨„Ç§„É§„ÉºÔºà„Éò„ÉÉ„ÉâÊï∞=8Ôºâ
        self.conv1 = GATConv(num_node_features, hidden_channels, heads=8)
        self.conv2 = GATConv(hidden_channels * 8, hidden_channels, heads=8)
        self.conv3 = GATConv(hidden_channels * 8, hidden_channels, heads=1)
        # Â±§„ÇíÂ¢ó„ÇÑ„ÅôÔºà3Â±§ ‚Üí 4Â±§Ôºâ
        self.conv4 = GCNConv(hidden_channels, hidden_channels)</code></pre>

<strong>ÊúüÂæÖ„Åï„Çå„ÇãÊîπÂñÑ</strong>: MAE 0.8 eV ‚Üí 0.5-0.6 eV

---

<strong>„Ç¢„Éó„É≠„Éº„ÉÅ2: „Ç®„ÉÉ„Ç∏ÁâπÂæ¥Èáè„ÅÆÊ¥ªÁî®</strong>

<pre><code class="language-python"><h1>„Ç®„ÉÉ„Ç∏ÁâπÂæ¥ÈáèÔºàÁµêÂêà„Çø„Ç§„ÉóÔºâ„ÇíÁµÑ„ÅøËæº„ÇÄ</h1>
from torch_geometric.nn import NNConv

class EdgeFeaturesGNN(torch.nn.Module):
    def __init__(self, num_node_features, num_edge_features, hidden_channels=64):
        super().__init__()
        # NNConv: „Ç®„ÉÉ„Ç∏ÁâπÂæ¥Èáè„ÇíËÄÉÊÖÆ
        nn = torch.nn.Sequential(
            torch.nn.Linear(num_edge_features, hidden_channels * hidden_channels),
            torch.nn.ReLU()
        )
        self.conv1 = NNConv(num_node_features, hidden_channels, nn, aggr='mean')</code></pre>

<strong>ÊúüÂæÖ„Åï„Çå„ÇãÊîπÂñÑ</strong>: MAE 0.8 eV ‚Üí 0.6-0.7 eV

---

<strong>„Ç¢„Éó„É≠„Éº„ÉÅ3: „Éá„Éº„ÇøÊ≠£Ë¶èÂåñ„Å®Êã°Âºµ</strong>

<pre><code class="language-python"><h1>ÁõÆÁöÑÂ§âÊï∞„ÇíÊ®ôÊ∫ñÂåñ</h1>
y_mean = train_dataset.data.y.mean(dim=0)
y_std = train_dataset.data.y.std(dim=0)

for data in train_dataset:
    data.y = (data.y - y_mean) / y_std

<h1>„Éá„Éº„ÇøÊã°ÂºµÔºà„Ç∞„É©„Éï„ÅÆÊëÇÂãïÔºâ</h1>
def augment_graph(data):
    # „Ç®„ÉÉ„Ç∏„ÅÆ„Éâ„É≠„ÉÉ„Éó„Ç¢„Ç¶„Éà
    edge_index, _ = dropout_edge(data.edge_index, p=0.1)
    # „Éé„Ç§„Ç∫ËøΩÂä†
    x = data.x + torch.randn_like(data.x) * 0.01
    return Data(x=x, edge_index=edge_index, y=data.y)

<h1>Ë®ìÁ∑¥„Éá„Éº„Çø„Çí2ÂÄç„Å´</h1>
augmented_train = [augment_graph(data) for data in train_dataset]
train_dataset = train_dataset + augmented_train</code></pre>

<strong>ÊúüÂæÖ„Åï„Çå„ÇãÊîπÂñÑ</strong>: MAE 0.8 eV ‚Üí 0.7 eV

---

<strong>ÊúÄÈÅ©„Å™Êà¶Áï•</strong>: „Ç¢„Éó„É≠„Éº„ÉÅ1Ôºà„É¢„Éá„É´ÊîπÂñÑÔºâ„Å®„Ç¢„Éó„É≠„Éº„ÉÅ2Ôºà„Ç®„ÉÉ„Ç∏ÁâπÂæ¥ÈáèÔºâ„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„ÄÅMAE 0.4-0.5 eV„ÇíÁõÆÊåá„Åô„ÄÇ

</details>

---

<h3>ÂïèÈ°å3ÔºàÈõ£ÊòìÂ∫¶ÔºöhardÔºâ</h3>

‰ª•‰∏ã„ÅÆ„Ç≥„Éº„Éâ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇÂéüÂõ†„ÇíÁâπÂÆö„Åó„ÄÅ‰øÆÊ≠£„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

<pre><code class="language-python"><h1>„Ç®„É©„Éº„ÅåÁô∫Áîü„Åô„Çã„Ç≥„Éº„Éâ</h1>
model = GCN_QM9(num_node_features=11, num_classes=1)
device = torch.device('cuda')
model = model.to(device)

for data in train_loader:
    optimizer.zero_grad()
    out = model(data.x, data.edge_index, data.batch)
    loss = criterion(out, data.y)
    loss.backward()
    optimizer.step()</code></pre>

<strong>„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏</strong>:
<pre><code>RuntimeError: Expected all tensors to be on the same device, but found at least two devices, cuda:0 and cpu!</code></pre>

<details>
<summary>„Éí„É≥„Éà</summary>

„É¢„Éá„É´„Å®„Éá„Éº„Çø„ÅÆ„Éá„Éê„Ç§„Çπ„Åå‰∏ÄËá¥„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ

</details>

<details>
<summary>Ëß£Á≠î‰æã</summary>

<strong>ÂéüÂõ†</strong>:
„É¢„Éá„É´„ÅØ<code>cuda</code>„Éá„Éê„Ç§„Çπ„Å´ÁßªÂãï„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ<code>data</code>„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅØ<code>cpu</code>„ÅÆ„Åæ„Åæ„Åß„Åô„ÄÇPyTorch„Åß„ÅØ„ÄÅ„Åô„Åπ„Å¶„ÅÆ„ÉÜ„É≥„ÇΩ„É´„ÅåÂêå„Åò„Éá„Éê„Ç§„Çπ‰∏ä„Å´„ÅÇ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ

<strong>‰øÆÊ≠£„Ç≥„Éº„Éâ</strong>:

<pre><code class="language-python">model = GCN_QM9(num_node_features=11, num_classes=1)
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = model.to(device)

for data in train_loader:
    # „Éá„Éº„Çø„ÇíGPU„Å´ÁßªÂãïÔºàÈáçË¶ÅÔºÅÔºâ
    data = data.to(device)

    optimizer.zero_grad()
    out = model(data.x, data.edge_index, data.batch)
    loss = criterion(out, data.y)
    loss.backward()
    optimizer.step()</code></pre>

<strong>ÈáçË¶Å„Å™„Éù„Ç§„É≥„Éà</strong>:
1. <code>data = data.to(device)</code>„Åß„ÄÅ<code>data</code>ÂÜÖ„ÅÆ„Åô„Åπ„Å¶„ÅÆ„ÉÜ„É≥„ÇΩ„É´Ôºà<code>x</code>, <code>edge_index</code>, <code>batch</code>, <code>y</code>Ôºâ„Çí‰∏ÄÂ∫¶„Å´GPU„Å´ÁßªÂãï
2. <code>torch.cuda.is_available()</code>„ÅßGPU„ÅåÂà©Áî®ÂèØËÉΩ„ÅãÁ¢∫Ë™çÔºàCPU„ÅÆ„Åø„ÅÆÁí∞Â¢É„Åß„ÇÇ„Ç®„É©„Éº„ÇíÂõûÈÅøÔºâ
3. Ë®ìÁ∑¥„É´„Éº„Éó„ÅÆ<strong>ÊúÄÂàù</strong>„Åß„Éá„Éº„Çø„Çí„Éá„Éê„Ç§„Çπ„Å´ÁßªÂãï

<strong>„Éá„Éê„ÉÉ„Ç∞„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ</strong>:
<pre><code class="language-python"><h1>„Éá„Éê„Ç§„Çπ„ÅÆÁ¢∫Ë™ç</h1>
print(f"Model device: {next(model.parameters()).device}")
print(f"Data x device: {data.x.device}")
print(f"Data edge_index device: {data.edge_index.device}")</code></pre>

</details>

---

<h2>ÂèÇËÄÉÊñáÁåÆ</h2>

1. Fey, M., & Lenssen, J. E. (2019). "Fast Graph Representation Learning with PyTorch Geometric." *ICLR Workshop on Representation Learning on Graphs and Manifolds*.
   GitHub: https://github.com/pyg-team/pytorch_geometric
   *PyTorch GeometricÂÖ¨ÂºèË´ñÊñá„ÄÇ„É©„Ç§„Éñ„É©„É™„ÅÆË®≠Ë®àÊÄùÊÉ≥„Å®ÂÆüË£Ö„ÅÆË©≥Á¥∞„ÄÇ*

2. Ramakrishnan, R., et al. (2014). "Quantum chemistry structures and properties of 134 kilo molecules." *Scientific Data*, 1, 140022.
   DOI: [10.1038/sdata.2014.22](https://doi.org/10.1038/sdata.2014.22)
   *QM9„Éá„Éº„Çø„Çª„ÉÉ„ÉàÂÖ¨ÂºèË´ñÊñá„ÄÇ134,000ÂàÜÂ≠ê„ÅÆÈáèÂ≠êÂåñÂ≠¶Ë®àÁÆó„Éá„Éº„Çø„ÄÇ*

3. Xie, T., & Grossman, J. C. (2018). "Crystal Graph Convolutional Neural Networks for an Accurate and Interpretable Prediction of Material Properties." *Physical Review Letters*, 120(14), 145301.
   DOI: [10.1103/PhysRevLett.120.145301](https://doi.org/10.1103/PhysRevLett.120.145301)
   *Crystal Graph Convolutional NetworksÔºàCGCNÔºâ„ÅÆÂéüË´ñÊñá„ÄÇÁµêÊô∂ÁâπÊÄß‰∫àÊ∏¨„Å∏„ÅÆÂøúÁî®„ÄÇ*

4. Gilmer, J., et al. (2017). "Neural Message Passing for Quantum Chemistry." *ICML 2017*.
   URL: https://arxiv.org/abs/1704.01212
   *Message Passing Neural NetworksÔºàMPNNÔºâ„ÅÆÁêÜË´ñ„ÄÇQM9„Åß„ÅÆÈ´òÁ≤æÂ∫¶‰∫àÊ∏¨„ÇíÈÅîÊàê„ÄÇ*

5. PyTorch Geometric Documentation. (2024). "Introduction by Example."
   URL: https://pytorch-geometric.readthedocs.io/en/latest/get_started/introduction.html
   *PyTorch GeometricÂÖ¨Âºè„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´„ÄÇÂü∫Êú¨ÁöÑ„Å™‰Ωø„ÅÑÊñπ„Çí‰æãÁ§∫„ÄÇ*

6. RDKit Documentation. (2024). "Getting Started with the RDKit in Python."
   URL: https://www.rdkit.org/docs/GettingStartedInPython.html
   *RDKit„ÅÆÂÖ¨Âºè„Éâ„Ç≠„É•„É°„É≥„Éà„ÄÇSMILES„Åã„ÇâÂàÜÂ≠ê„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê„Åô„ÇãÊñπÊ≥ï„ÄÇ*

---

<strong>‰ΩúÊàêÊó•</strong>: 2025-10-17
<strong>„Éê„Éº„Ç∏„Éß„É≥</strong>: 1.0
<strong>„ÉÜ„É≥„Éó„É¨„Éº„Éà</strong>: chapter-template-v2.0
<strong>ËëóËÄÖ</strong>: GNNÂÖ•ÈñÄ„Ç∑„É™„Éº„Ç∫„Éó„É≠„Ç∏„Çß„ÇØ„Éà
<div class="navigation">
    <a href="chapter-2.html" class="nav-button">‚Üê Á¨¨2Á´†</a>
    <a href="index.html" class="nav-button">„Ç∑„É™„Éº„Ç∫ÁõÆÊ¨°„Å´Êàª„Çã</a>
    <a href="chapter-4.html" class="nav-button">Á¨¨4Á´† ‚Üí</a>
</div>
    </main>

    <footer>
        <p><strong>‰ΩúÊàêËÄÖ</strong>: AI Terakoya Content Team</p>
        <p><strong>Áõ£‰øÆ</strong>: Dr. Yusuke HashimotoÔºàÊù±ÂåóÂ§ßÂ≠¶Ôºâ</p>
        <p><strong>„Éê„Éº„Ç∏„Éß„É≥</strong>: 1.0 | <strong>‰ΩúÊàêÊó•</strong>: 2025-10-17</p>
        <p><strong>„É©„Ç§„Çª„É≥„Çπ</strong>: Creative Commons BY 4.0</p>
        <p>¬© 2025 AI Terakoya. All rights reserved.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const mermaidCodeBlocks = document.querySelectorAll('pre.codehilite code.language-mermaid, pre code.language-mermaid');

            mermaidCodeBlocks.forEach(function(codeBlock) {
                const pre = codeBlock.parentElement;
                const mermaidCode = codeBlock.textContent;

                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = mermaidCode.trim();

                pre.parentNode.replaceChild(mermaidDiv, pre);
            });

            if (typeof mermaid !== 'undefined') {
                mermaid.initialize({
                    startOnLoad: true,
                    theme: 'default'
                });
                mermaid.init(undefined, document.querySelectorAll('.mermaid'));
            }
        });
    </script>
</body>
</html>
