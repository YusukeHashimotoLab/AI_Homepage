<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第2章：DFT計算の自動化（VASP, Quantum ESPRESSO） - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第2章：DFT計算の自動化（VASP, Quantum ESPRESSO）</h1>
            
            <div class="meta">
                <span class="meta-item">📖 読了時間: 20-25分</span>
<span class="meta-item">📊 難易度: 中級〜上級</span>
            </div>
        </div>
    </header>

    <main class="container">
        <h1>第2章：DFT計算の自動化（VASP, Quantum ESPRESSO）</h1>

<h2>学習目標</h2>

<p>この章を読むことで、以下を習得できます：</p>

<ul>
<li>✅ ASEを使ってDFT計算を自動実行できる</li>
<li>✅ VASPとQuantum ESPRESSOの入力ファイルを自動生成できる</li>
<li>✅ pymatgenのInputSetで標準化された設定を使える</li>
<li>✅ エラーを検出して自動リスタートできる</li>
<li>✅ 構造最適化の収束判定を自動化できる</li>
</ul>

<p>---</p>

<h2>2.1 ASE（Atomic Simulation Environment）基礎</h2>

<h3>ASEとは</h3>

<strong>ASE（Atomic Simulation Environment）</strong>は、原子スケールシミュレーションのためのPythonライブラリです。

<strong>特徴</strong>:
<ul>
<li>✅ 多様な計算コード対応（VASP、QE、LAMMPS等）</li>
<li>✅ 構造生成・操作の統一インターフェース</li>
<li>✅ 計算結果の解析ツール</li>
<li>✅ MITライセンス（オープンソース）</li>
</ul>

<h3>インストール</h3>

<pre><code class="language-bash"><h1>conda環境を推奨</h1>
<p>conda create -n ht_computing python=3.10</p>
<p>conda activate ht_computing</p>

<h1>ASEインストール</h1>
<p>pip install ase</p>

<h1>追加パッケージ</h1>
<p>pip install numpy scipy matplotlib</p>
</code></pre>

<h3>基本的な構造生成</h3>

<pre><code class="language-python">from ase import Atoms
<p>from ase.build import bulk, molecule</p>
<p>import numpy as np</p>

<h1>例1: バルク結晶の生成</h1>
<p>si = bulk('Si', 'diamond', a=5.43)</p>
<p>print(f"Si結晶: {len(si)}原子")</p>
<p>print(f"格子定数: {si.cell.cellpar()}")</p>

<h1>例2: 分子の生成</h1>
<p>h2o = molecule('H2O')</p>
<p>print(f"H2O分子: {len(h2o)}原子")</p>

<h1>例3: カスタム構造</h1>
<h1>LiCoO2（層状構造）</h1>
<p>a = 2.82</p>
<p>c = 14.05</p>
<p>positions = [</p>
<p>[0, 0, 0],       # Li</p>
<p>[0, 0, 0.5*c],   # Co</p>
<p>[1/3, 2/3, 0.25*c],  # O</p>
<p>[2/3, 1/3, 0.75*c],  # O</p>
<p>]</p>
<p>atoms = Atoms('LiCoO2',</p>
<p>positions=positions,</p>
<p>cell=[a, a, c, 90, 90, 120],</p>
<p>pbc=True)</p>

<p>print(f"LiCoO2: {atoms.get_chemical_formula()}")</p>
</code></pre>

<strong>出力</strong>:
<pre><code class="language-">Si結晶: 2原子
<p>格子定数: [5.43 5.43 5.43 90.  90.  90. ]</p>
<p>H2O分子: 3原子</p>
<p>LiCoO2: LiCoO2</p>
</code></pre>

<h3>構造の可視化</h3>

<pre><code class="language-python">from ase.visualize import view

<h1>3D可視化（GUIが起動）</h1>
<p>view(si)</p>

<h1>ファイル保存</h1>
<p>from ase.io import write</p>

<h1>CIF形式で保存</h1>
<p>write('si_structure.cif', si)</p>

<h1>POSCAR形式（VASP用）</h1>
<p>write('POSCAR', si, format='vasp')</p>

<h1>XYZ形式</h1>
<p>write('structure.xyz', si)</p>
</code></pre>

<p>---</p>

<h2>2.2 VASP自動化</h2>

<h3>VASPインターフェース設定</h3>

<pre><code class="language-python">from ase.calculators.vasp import Vasp

<h1>VASP計算器の設定</h1>
<p>calc = Vasp(</p>
<p># 基本設定</p>
<p>xc='PBE',           # 交換相関汎関数</p>
<p>encut=520,          # エネルギーカットオフ（eV）</p>

<p># k-point設定</p>
<p>kpts=(8, 8, 8),     # Monkhorst-Pack格子</p>
<p>gamma=True,         # Γ点中心</p>

<p># 電子構造</p>
<p>ismear=0,           # Gaussianスミアリング</p>
<p>sigma=0.05,         # スミアリング幅（eV）</p>

<p># 収束判定</p>
<p>ediff=1e-5,         # エネルギー収束（eV）</p>

<p># 並列化</p>
<p>ncore=4,            # 並列効率向上</p>

<p># 出力制御</p>
<p>lwave=False,        # WAVECARを保存しない</p>
<p>lcharg=False,       # CHGCARを保存しない</p>
<p>)</p>
</code></pre>

<h3>構造最適化の自動化</h3>

<pre><code class="language-python">from ase.optimize import BFGS
<p>from ase.calculators.vasp import Vasp</p>
<p>from ase.io import read, write</p>
<p>import os</p>

<p>def relax_structure(atoms, output_dir='relaxation'):</p>
<p>"""</p>
<p>構造最適化を自動実行</p>

<p>Parameters:</p>
<p>-----------</p>
<p>atoms : ase.Atoms</p>
<p>最適化する構造</p>
<p>output_dir : str</p>
<p>出力ディレクトリ</p>

<p>Returns:</p>
<p>--------</p>
<p>relaxed_atoms : ase.Atoms</p>
<p>最適化後の構造</p>
<p>"""</p>
<p># 出力ディレクトリ作成</p>
<p>os.makedirs(output_dir, exist_ok=True)</p>
<p>os.chdir(output_dir)</p>

<p># VASP計算器設定</p>
<p>calc = Vasp(</p>
<p>xc='PBE',</p>
<p>encut=520,</p>
<p>kpts=(8, 8, 8),</p>
<p>ediff=1e-5,</p>
<p>ibrion=2,       # 構造最適化アルゴリズム</p>
<p>nsw=100,        # 最大イオンステップ数</p>
<p>isif=3,         # セル形状も最適化</p>
<p>ediffg=-0.01,   # 力の収束判定（eV/Å）</p>
<p>)</p>

<p>atoms.calc = calc</p>

<p># 最適化実行</p>
<p>print(f"構造最適化を開始: {atoms.get_chemical_formula()}")</p>

<p>try:</p>
<p># BFGSアルゴリズムで最適化</p>
<p>optimizer = BFGS(atoms, trajectory='optimization.traj')</p>
<p>optimizer.run(fmax=0.01)  # 最大力が0.01 eV/Å以下</p>

<p>print("構造最適化が完了しました")</p>
<p>print(f"最終エネルギー: {atoms.get_potential_energy():.3f} eV")</p>

<p># 最適化後の構造を保存</p>
<p>write('CONTCAR', atoms, format='vasp')</p>

<p>return atoms</p>

<p>except Exception as e:</p>
<p>print(f"エラーが発生しました: {e}")</p>
<p>return None</p>

<p>finally:</p>
<p>os.chdir('..')</p>

<h1>使用例</h1>
<p>si = bulk('Si', 'diamond', a=5.43)</p>
<p>relaxed_si = relax_structure(si, output_dir='si_relaxation')</p>
</code></pre>

<h3>INCARファイル自動生成</h3>

<pre><code class="language-python">def generate_incar(calculation_type='relax'):
<p>"""</p>
<p>計算タイプに応じたINCAR設定を生成</p>

<p>Parameters:</p>
<p>-----------</p>
<p>calculation_type : str</p>
<p>'relax', 'static', 'band', 'dos'のいずれか</p>

<p>Returns:</p>
<p>--------</p>
<p>incar_dict : dict</p>
<p>INCAR設定の辞書</p>
<p>"""</p>
<p># 共通設定</p>
<p>base_settings = {</p>
<p>'SYSTEM': 'Automated calculation',</p>
<p>'PREC': 'Accurate',</p>
<p>'ENCUT': 520,</p>
<p>'EDIFF': 1e-5,</p>
<p>'ISMEAR': 0,</p>
<p>'SIGMA': 0.05,</p>
<p>'LREAL': False,</p>
<p>'LWAVE': False,</p>
<p>'LCHARG': False,</p>
<p>}</p>

<p># 計算タイプ別設定</p>
<p>if calculation_type == 'relax':</p>
<p>specific = {</p>
<p>'IBRION': 2,      # CG法</p>
<p>'NSW': 100,       # 最大イオンステップ</p>
<p>'ISIF': 3,        # セル形状最適化</p>
<p>'EDIFFG': -0.01,  # 力の収束</p>
<p>}</p>

<p>elif calculation_type == 'static':</p>
<p>specific = {</p>
<p>'IBRION': -1,     # イオン緩和なし</p>
<p>'NSW': 0,</p>
<p>'LCHARG': True,   # 電荷密度を保存</p>
<p>}</p>

<p>elif calculation_type == 'band':</p>
<p>specific = {</p>
<p>'IBRION': -1,</p>
<p>'NSW': 0,</p>
<p>'ICHARG': 11,     # 電荷密度を読み込み</p>
<p>'LORBIT': 11,     # DOSとバンド</p>
<p>}</p>

<p>elif calculation_type == 'dos':</p>
<p>specific = {</p>
<p>'IBRION': -1,</p>
<p>'NSW': 0,</p>
<p>'ICHARG': 11,</p>
<p>'LORBIT': 11,</p>
<p>'NEDOS': 2001,    # DOS解像度</p>
<p>}</p>

<p>else:</p>
<p>raise ValueError(f"Unknown calculation type: {calculation_type}")</p>

<p># 設定を結合</p>
<p>incar_dict = {<strong>base_settings, </strong>specific}</p>

<p>return incar_dict</p>

<h1>使用例</h1>
<p>relax_incar = generate_incar('relax')</p>
<p>print("構造最適化用INCAR:")</p>
<p>for key, value in relax_incar.items():</p>
<p>print(f"{key} = {value}")</p>
</code></pre>

<h3>K-point自動設定</h3>

<pre><code class="language-python">from ase.dft.kpoints import monkhorst_pack
<p>import numpy as np</p>

<p>def auto_kpoints(atoms, kpt_density=1000):</p>
<p>"""</p>
<p>セルサイズに応じてk-point密度を自動設定</p>

<p>Parameters:</p>
<p>-----------</p>
<p>atoms : ase.Atoms</p>
<p>構造</p>
<p>kpt_density : float</p>
<p>k-point密度（1/Å³あたりのk-point数）</p>

<p>Returns:</p>
<p>--------</p>
<p>kpts : tuple</p>
<p>k-point格子（nx, ny, nz）</p>
<p>"""</p>
<p># セルの逆格子ベクトル長さ</p>
<p>cell = atoms.get_cell()</p>
<p>reciprocal_cell = cell.reciprocal()</p>
<p>lengths = np.linalg.norm(reciprocal_cell, axis=1)</p>

<p># k-point数を計算</p>
<p>kpts = []</p>
<p>for length in lengths:</p>
<p># k-point密度から必要な分割数を計算</p>
<p>n = max(1, int(np.ceil(kpt_density / length)))</p>
<p>kpts.append(n)</p>

<p>return tuple(kpts)</p>

<h1>使用例</h1>
<p>si = bulk('Si', 'diamond', a=5.43)</p>
<p>kpts = auto_kpoints(si, kpt_density=1000)</p>
<p>print(f"Si用k-point格子: {kpts}")  # 例: (12, 12, 12)</p>

<h1>大きなセル</h1>
<p>supercell = si * (2, 2, 2)</p>
<p>kpts_super = auto_kpoints(supercell, kpt_density=1000)</p>
<p>print(f"スーパーセル用k-point: {kpts_super}")  # 例: (6, 6, 6)</p>
</code></pre>

<p>---</p>

<h2>2.3 Quantum ESPRESSO自動化</h2>

<h3>QE計算器設定</h3>

<pre><code class="language-python">from ase.calculators.espresso import Espresso

<h1>Quantum ESPRESSO計算器</h1>
<p>calc_qe = Espresso(</p>
<p># 実行ファイルパス</p>
<p>command='pw.x -in PREFIX.pwi > PREFIX.pwo',</p>

<p># 擬ポテンシャル</p>
<p>pseudopotentials={</p>
<p>'Si': 'Si.pbe-n-kjpaw_psl.1.0.0.UPF',</p>
<p>'O': 'O.pbe-n-kjpaw_psl.1.0.0.UPF',</p>
<p>},</p>
<p>pseudo_dir='/path/to/pseudopotentials',</p>

<p># 入力パラメータ</p>
<p>input_data={</p>
<p>'control': {</p>
<p>'calculation': 'relax',</p>
<p>'restart_mode': 'from_scratch',</p>
<p>'prefix': 'pwscf',</p>
<p>'outdir': './tmp',</p>
<p>'pseudo_dir': '/path/to/pseudopotentials',</p>
<p>},</p>
<p>'system': {</p>
<p>'ecutwfc': 60,      # 波動関数カットオフ（Ry）</p>
<p>'ecutrho': 480,     # 電荷密度カットオフ</p>
<p>'occupations': 'smearing',</p>
<p>'smearing': 'gaussian',</p>
<p>'degauss': 0.01,</p>
<p>},</p>
<p>'electrons': {</p>
<p>'conv_thr': 1e-8,   # 収束判定</p>
<p>'mixing_beta': 0.7,</p>
<p>},</p>
<p>'ions': {</p>
<p>'ion_dynamics': 'bfgs',</p>
<p>},</p>
<p>},</p>

<p># k-point</p>
<p>kpts=(8, 8, 8),</p>
<p>koffset=(0, 0, 0),</p>
<p>)</p>
</code></pre>

<h3>QE入力ファイルテンプレート</h3>

<pre><code class="language-python">def generate_qe_input(atoms, calculation='relax'):
<p>"""</p>
<p>Quantum ESPRESSO入力ファイルを生成</p>

<p>Parameters:</p>
<p>-----------</p>
<p>atoms : ase.Atoms</p>
<p>計算する構造</p>
<p>calculation : str</p>
<p>'relax', 'scf', 'nscf', 'bands'</p>

<p>Returns:</p>
<p>--------</p>
<p>input_str : str</p>
<p>入力ファイル内容</p>
<p>"""</p>
<p>from ase.io.espresso import write_espresso_in</p>

<p># 計算タイプ別設定</p>
<p>if calculation == 'relax':</p>
<p>input_data = {</p>
<p>'control': {</p>
<p>'calculation': 'relax',</p>
<p>'restart_mode': 'from_scratch',</p>
<p>},</p>
<p>'system': {</p>
<p>'ecutwfc': 60,</p>
<p>'ecutrho': 480,</p>
<p>},</p>
<p>'electrons': {</p>
<p>'conv_thr': 1e-8,</p>
<p>},</p>
<p>'ions': {</p>
<p>'ion_dynamics': 'bfgs',</p>
<p>},</p>
<p>}</p>

<p>elif calculation == 'scf':</p>
<p>input_data = {</p>
<p>'control': {</p>
<p>'calculation': 'scf',</p>
<p>},</p>
<p>'system': {</p>
<p>'ecutwfc': 60,</p>
<p>'ecutrho': 480,</p>
<p>},</p>
<p>'electrons': {</p>
<p>'conv_thr': 1e-8,</p>
<p>},</p>
<p>}</p>

<p>elif calculation == 'bands':</p>
<p>input_data = {</p>
<p>'control': {</p>
<p>'calculation': 'bands',</p>
<p>},</p>
<p>'system': {</p>
<p>'ecutwfc': 60,</p>
<p>'ecutrho': 480,</p>
<p>'nbnd': 20,  # バンド数</p>
<p>},</p>
<p>'electrons': {</p>
<p>'conv_thr': 1e-8,</p>
<p>},</p>
<p>}</p>

<p># 入力ファイル書き込み</p>
<p>write_espresso_in(</p>
<p>'pw.in',</p>
<p>atoms,</p>
<p>input_data=input_data,</p>
<p>pseudopotentials={el: f"{el}.pbe.UPF" for el in set(atoms.get_chemical_symbols())},</p>
<p>kpts=(8, 8, 8),</p>
<p>)</p>

<p>with open('pw.in', 'r') as f:</p>
<p>input_str = f.read()</p>

<p>return input_str</p>

<h1>使用例</h1>
<p>si = bulk('Si', 'diamond', a=5.43)</p>
<p>qe_input = generate_qe_input(si, calculation='relax')</p>
<p>print(qe_input)</p>
</code></pre>

<p>---</p>

<h2>2.4 pymatgenによる高度な自動化</h2>

<h3>InputSetの活用</h3>

<p>pymatgenは、Materials Projectで使用されている標準化された計算設定を提供します。</p>

<pre><code class="language-python">from pymatgen.core import Structure
<p>from pymatgen.io.vasp.sets import MPRelaxSet, MPStaticSet</p>

<h1>構造を読み込み（CIFファイルから）</h1>
<p>structure = Structure.from_file("LiCoO2.cif")</p>

<h1>Materials Project標準の構造最適化設定</h1>
<p>relax_set = MPRelaxSet(structure)</p>

<h1>INCAR, KPOINTS, POTCARを自動生成</h1>
<p>relax_set.write_input("relax_calculation")</p>

<h1>ディレクトリ内容:</h1>
<h1>relax_calculation/</h1>
<h1>  ├── INCAR</h1>
<h1>  ├── POSCAR</h1>
<h1>  ├── KPOINTS</h1>
<h1>  └── POTCAR</h1>

<h1>静的計算設定（構造最適化後）</h1>
<p>static_set = MPStaticSet(structure)</p>
<p>static_set.write_input("static_calculation")</p>
</code></pre>

<h3>カスタムInputSet</h3>

<pre><code class="language-python">from pymatgen.io.vasp.sets import DictSet

<h1>カスタム設定</h1>
<p>custom_incar = {</p>
<p>"ENCUT": 600,      # デフォルトより高精度</p>
<p>"EDIFF": 1e-6,</p>
<p>"ISMEAR": -5,      # Tetrahedron法</p>
<p>"LORBIT": 11,</p>
<p>"LWAVE": False,</p>
<p>"LCHARG": True,</p>
<p>}</p>

<h1>カスタムInputSet作成</h1>
<p>custom_set = DictSet(</p>
<p>structure,</p>
<p>config_dict={</p>
<p>"INCAR": custom_incar,</p>
<p>"KPOINTS": {"reciprocal_density": 200},  # k-point密度</p>
<p>}</p>
<p>)</p>

<p>custom_set.write_input("custom_calculation")</p>
</code></pre>

<h3>エラー検出とリスタート</h3>

<pre><code class="language-python">from pymatgen.io.vasp.outputs import Vasprun, Outcar
<p>from pymatgen.io.vasp.sets import MPRelaxSet</p>
<p>import os</p>

<p>def check_convergence(directory):</p>
<p>"""</p>
<p>VASP計算の収束をチェック</p>

<p>Returns:</p>
<p>--------</p>
<p>status : str</p>
<p>'converged', 'not_converged', 'error'</p>
<p>"""</p>
<p>try:</p>
<p># vasprun.xmlを読み込み</p>
<p>vasprun = Vasprun(os.path.join(directory, "vasprun.xml"))</p>

<p>if vasprun.converged:</p>
<p>return 'converged'</p>
<p>else:</p>
<p>return 'not_converged'</p>

<p>except Exception as e:</p>
<p>print(f"エラー: {e}")</p>
<p>return 'error'</p>

<p>def auto_restart(directory, max_attempts=3):</p>
<p>"""</p>
<p>収束しない計算を自動リスタート</p>

<p>Parameters:</p>
<p>-----------</p>
<p>directory : str</p>
<p>計算ディレクトリ</p>
<p>max_attempts : int</p>
<p>最大リトライ回数</p>
<p>"""</p>
<p>for attempt in range(max_attempts):</p>
<p>status = check_convergence(directory)</p>

<p>if status == 'converged':</p>
<p>print("計算が収束しました")</p>
<p>return True</p>

<p>elif status == 'not_converged':</p>
<p>print(f"未収束。リトライ {attempt+1}/{max_attempts}")</p>

<p># 設定を緩和</p>
<p># 例: エネルギーカットオフを下げる、スミアリングを増やす</p>
<p>modify_incar(directory, {'ENCUT': 450, 'SIGMA': 0.1})</p>

<p># リスタート</p>
<p>restart_calculation(directory)</p>

<p>elif status == 'error':</p>
<p>print("致命的エラー。スキップします")</p>
<p>return False</p>

<p>print("最大リトライ回数に達しました")</p>
<p>return False</p>

<p>def modify_incar(directory, new_params):</p>
<p>"""INCARファイルを修正"""</p>
<p>from pymatgen.io.vasp.inputs import Incar</p>

<p>incar_file = os.path.join(directory, "INCAR")</p>
<p>incar = Incar.from_file(incar_file)</p>

<p># パラメータを更新</p>
<p>for key, value in new_params.items():</p>
<p>incar[key] = value</p>

<p># 保存</p>
<p>incar.write_file(incar_file)</p>
<p>print(f"INCARを更新: {new_params}")</p>

<p>def restart_calculation(directory):</p>
<p>"""計算を再実行"""</p>
<p>import subprocess</p>

<p># CONTCARをPOSCARにコピー</p>
<p>os.system(f"cp {directory}/CONTCAR {directory}/POSCAR")</p>

<p># VASP再実行</p>
<p>os.chdir(directory)</p>
<p>subprocess.run(["mpirun", "-np", "48", "vasp_std"])</p>
<p>os.chdir("..")</p>
</code></pre>

<p>---</p>

<h2>2.5 バッチ処理</h2>

<h3>複数材料の自動計算</h3>

<pre><code class="language-python">import os
<p>from pymatgen.core import Structure</p>
<p>from pymatgen.io.vasp.sets import MPRelaxSet</p>

<p>def batch_relax(structure_files, output_root='calculations'):</p>
<p>"""</p>
<p>複数の構造を一括で構造最適化</p>

<p>Parameters:</p>
<p>-----------</p>
<p>structure_files : list</p>
<p>CIFファイルのリスト</p>
<p>output_root : str</p>
<p>出力ルートディレクトリ</p>
<p>"""</p>
<p>os.makedirs(output_root, exist_ok=True)</p>

<p>for cif_file in structure_files:</p>
<p># 構造を読み込み</p>
<p>structure = Structure.from_file(cif_file)</p>
<p>formula = structure.composition.reduced_formula</p>

<p>print(f"処理中: {formula}")</p>

<p># 出力ディレクトリ</p>
<p>calc_dir = os.path.join(output_root, formula)</p>

<p># InputSet作成</p>
<p>relax_set = MPRelaxSet(structure)</p>
<p>relax_set.write_input(calc_dir)</p>

<p># ジョブスクリプト作成</p>
<p>create_job_script(calc_dir, formula)</p>

<p># ジョブ投入（SLURMの場合）</p>
<p>os.chdir(calc_dir)</p>
<p>os.system("sbatch job.sh")</p>
<p>os.chdir("../..")</p>

<p>print(f"  → ジョブ投入完了: {calc_dir}")</p>

<p>def create_job_script(directory, jobname):</p>
<p>"""SLURMジョブスクリプト作成"""</p>
<p>script = f"""#!/bin/bash</p>
<p>#SBATCH --job-name={jobname}</p>
<p>#SBATCH --nodes=1</p>
<p>#SBATCH --ntasks-per-node=48</p>
<p>#SBATCH --time=24:00:00</p>
<p>#SBATCH --partition=standard</p>

<p>module load vasp/6.3.0</p>

<p>mpirun -np 48 vasp_std</p>
<p>"""</p>

<p>with open(os.path.join(directory, "job.sh"), 'w') as f:</p>
<p>f.write(script)</p>

<h1>使用例</h1>
<p>cif_files = [</p>
<p>"LiCoO2.cif",</p>
<p>"LiNiO2.cif",</p>
<p>"LiMnO2.cif",</p>
<p>"LiFePO4.cif",</p>
<p>]</p>

<p>batch_relax(cif_files, output_root='battery_materials')</p>
</code></pre>

<p>---</p>

<h2>2.6 演習問題</h2>

<h3>問題1（難易度: easy）</h3>

<strong>問題</strong>: ASEを使ってNaCl（岩塩構造）の結晶を生成し、POSCARファイルに保存してください。格子定数は5.64 Åです。

<details>
<summary>ヒント</summary>

<code>ase.build.bulk</code>関数を使用。結晶構造は'rocksalt'を指定。

</details>

<details>
<summary>解答例</summary>

<pre><code class="language-python">from ase.build import bulk
<p>from ase.io import write</p>

<h1>NaCl結晶生成</h1>
<p>nacl = bulk('NaCl', 'rocksalt', a=5.64)</p>

<h1>POSCAR保存</h1>
<p>write('POSCAR_NaCl', nacl, format='vasp')</p>

<p>print(f"NaCl: {nacl.get_chemical_formula()}")</p>
<p>print(f"原子数: {len(nacl)}")</p>
<p>print(f"セルパラメータ: {nacl.cell.cellpar()}")</p>
</code></pre>

<strong>出力</strong>:
<pre><code class="language-">NaCl: NaCl
<p>原子数: 2</p>
<p>セルパラメータ: [5.64 5.64 5.64 90.  90.  90. ]</p>
</code></pre>

</details>

<h3>問題2（難易度: medium）</h3>

<strong>問題</strong>: pymatgenのMPRelaxSetを使って、Li₂O（Li2O.cif）の構造最適化用入力ファイルを生成してください。さらに、k-point密度を2000に変更してください。

<details>
<summary>ヒント</summary>

<code>MPRelaxSet</code>のuser_incar_settingsとuser_kpoints_settingsを使用。

</details>

<details>
<summary>解答例</summary>

<pre><code class="language-python">from pymatgen.core import Structure
<p>from pymatgen.io.vasp.sets import MPRelaxSet</p>

<h1>構造読み込み</h1>
<p>structure = Structure.from_file("Li2O.cif")</p>

<h1>k-point密度をカスタマイズ</h1>
<p>relax_set = MPRelaxSet(</p>
<p>structure,</p>
<p>user_kpoints_settings={"reciprocal_density": 2000}</p>
<p>)</p>

<h1>入力ファイル生成</h1>
<p>relax_set.write_input("li2o_relax")</p>

<p>print("入力ファイルを生成しました: li2o_relax/")</p>
<p>print(f"k-point設定:")</p>
<p>with open("li2o_relax/KPOINTS", 'r') as f:</p>
<p>print(f.read())</p>
</code></pre>

</details>

<h3>問題3（難易度: hard）</h3>

<strong>問題</strong>: 100個の酸化物（CIF形式）について、以下の条件で自動計算を設定してください：

<ol>
<li>Materials Project標準設定で構造最適化</li>
<li>k-point密度は1500</li>
<li>各材料ごとにディレクトリを作成</li>
<li>SLURMジョブスクリプトを自動生成</li>
<li>エラーハンドリング（読み込み失敗時はスキップ）</li>
</ol>

<details>
<summary>ヒント</summary>

<p>バッチ処理のコード例を参考に、エラーハンドリングを追加。</p>

</details>

<details>
<summary>解答例</summary>

<pre><code class="language-python">import os
<p>from pymatgen.core import Structure</p>
<p>from pymatgen.io.vasp.sets import MPRelaxSet</p>
<p>from glob import glob</p>

<p>def batch_process_oxides(cif_directory, output_root='oxide_calculations'):</p>
<p>"""</p>
<p>100個の酸化物を一括処理</p>
<p>"""</p>
<p># CIFファイルリスト</p>
<p>cif_files = glob(os.path.join(cif_directory, "*.cif"))</p>
<p>print(f"CIFファイル数: {len(cif_files)}")</p>

<p>os.makedirs(output_root, exist_ok=True)</p>

<p>success_count = 0</p>
<p>error_count = 0</p>

<p>for cif_file in cif_files:</p>
<p>try:</p>
<p># 構造読み込み</p>
<p>structure = Structure.from_file(cif_file)</p>
<p>formula = structure.composition.reduced_formula</p>

<p># 酸化物のみ処理</p>
<p>if 'O' not in structure.composition.elements:</p>
<p>print(f"スキップ（酸化物ではない）: {formula}")</p>
<p>continue</p>

<p>print(f"処理中 ({success_count+1}): {formula}")</p>

<p># 出力ディレクトリ</p>
<p>calc_dir = os.path.join(output_root, formula)</p>

<p># InputSet作成（k-point密度1500）</p>
<p>relax_set = MPRelaxSet(</p>
<p>structure,</p>
<p>user_kpoints_settings={"reciprocal_density": 1500}</p>
<p>)</p>
<p>relax_set.write_input(calc_dir)</p>

<p># ジョブスクリプト作成</p>
<p>create_slurm_script(calc_dir, formula)</p>

<p>success_count += 1</p>

<p>except Exception as e:</p>
<p>print(f"エラー: {cif_file} - {e}")</p>
<p>error_count += 1</p>
<p>continue</p>

<p>print(f"\n完了:")</p>
<p>print(f"  成功: {success_count}")</p>
<p>print(f"  失敗: {error_count}")</p>

<p>def create_slurm_script(directory, jobname):</p>
<p>"""SLURMジョブスクリプト"""</p>
<p>script = f"""#!/bin/bash</p>
<p>#SBATCH --job-name={jobname}</p>
<p>#SBATCH --nodes=1</p>
<p>#SBATCH --ntasks-per-node=48</p>
<p>#SBATCH --time=24:00:00</p>
<p>#SBATCH --partition=standard</p>
<p>#SBATCH --output=slurm-%j.out</p>
<p>#SBATCH --error=slurm-%j.err</p>

<h1>環境設定</h1>
<p>module load intel/2021.2</p>
<p>module load vasp/6.3.0</p>

<h1>VASP実行</h1>
<p>mpirun -np 48 vasp_std</p>

<h1>収束チェック</h1>
<p>if grep -q "reached required accuracy" OUTCAR; then</p>
<p>echo "収束成功"</p>
<p>exit 0</p>
<p>else</p>
<p>echo "収束失敗"</p>
<p>exit 1</p>
<p>fi</p>
<p>"""</p>

<p>with open(os.path.join(directory, "job.sh"), 'w') as f:</p>
<p>f.write(script)</p>

<h1>実行</h1>
<p>batch_process_oxides("oxide_cifs", output_root="oxide_ht_calculations")</p>
</code></pre>

<strong>出力例</strong>:
<pre><code class="language-">CIFファイル数: 100
<p>処理中 (1): Li2O</p>
<p>処理中 (2): Na2O</p>
<p>スキップ（酸化物ではない）: LiCl</p>
<p>処理中 (3): MgO</p>
<p>...</p>
<p>完了:</p>
<p>成功: 95</p>
<p>失敗: 5</p>
</code></pre>

</details>

<p>---</p>

<h2>2.7 まとめ</h2>

<p>この章では、ASEとpymatgenを使ったDFT計算の自動化を学びました。</p>

<strong>キーポイント</strong>:

<ol>
<li><strong>ASE</strong>: 統一インターフェースで多様な計算コードを操作</li>
<li><strong>VASP自動化</strong>: INCAR、KPOINTS、POTCARの自動生成</li>
<li><strong>QE自動化</strong>: 入力ファイルテンプレート</li>
<li><strong>pymatgen InputSet</strong>: Materials Project標準設定</li>
<li><strong>エラー処理</strong>: 収束チェックと自動リスタート</li>
<li><strong>バッチ処理</strong>: 複数材料の一括計算</li>
</ol>

<strong>次のステップ</strong>:

<p>第3章では、<strong>ジョブスケジューリングと並列化</strong>を学びます。SLURMスクリプトの作成、MPIによる大規模並列計算、1000材料規模の効率的な管理手法を習得します。</p>

<strong><a href="./chapter-3.md">第3章: ジョブスケジューリングと並列化 →</a></strong>

<p>---</p>

<h2>参考文献</h2>

<ol>
<li>Larsen, A. H., et al. (2017). "The atomic simulation environment—a Python library for working with atoms." <em>Journal of Physics: Condensed Matter</em>, 29(27), 273002.</li>
</ol>

<ol>
<li>Ong, S. P., et al. (2013). "Python Materials Genomics (pymatgen): A robust, open-source python library for materials analysis." <em>Computational Materials Science</em>, 68, 314-319.</li>
</ol>

<ol>
<li>Kresse, G., & Furthmüller, J. (1996). "Efficient iterative schemes for ab initio total-energy calculations using a plane-wave basis set." <em>Physical Review B</em>, 54(16), 11169.</li>
</ol>

<ol>
<li>Giannozzi, P., et al. (2009). "QUANTUM ESPRESSO: a modular and open-source software project for quantum simulations of materials." <em>Journal of Physics: Condensed Matter</em>, 21(39), 395502.</li>
</ol>

<p>---</p>

<strong>ライセンス</strong>: CC BY 4.0
<strong>作成日</strong>: 2025-10-17
<strong>作成者</strong>: Dr. Yusuke Hashimoto, Tohoku University


        <div class="navigation">
            <a href="chapter-1.html" class="nav-button">← 前章: 第1章</a>
<a href="chapter-3.html" class="nav-button">次章: 第3章 →</a>
        </div>
    </main>

    <footer>
        <p><strong>作成者</strong>: AI Terakoya Content Team</p>
        <p><strong>監修</strong>: Dr. Yusuke Hashimoto（東北大学）</p>
        <p><strong>バージョン</strong>: 1.0 | <strong>作成日</strong>: 2025-10-17</p>
        <p><strong>ライセンス</strong>: Creative Commons BY 4.0</p>
        <p>© 2025 AI Terakoya. All rights reserved.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const mermaidCodeBlocks = document.querySelectorAll('pre.codehilite code.language-mermaid, pre code.language-mermaid');

            mermaidCodeBlocks.forEach(function(codeBlock) {
                const pre = codeBlock.parentElement;
                const mermaidCode = codeBlock.textContent;

                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = mermaidCode.trim();

                pre.parentNode.replaceChild(mermaidDiv, pre);
            });

            if (typeof mermaid !== 'undefined') {
                mermaid.initialize({
                    startOnLoad: true,
                    theme: 'default'
                });
                mermaid.init(undefined, document.querySelectorAll('.mermaid'));
            }
        });
    </script>
</body>
</html>
