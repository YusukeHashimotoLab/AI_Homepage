<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>chapter-2 - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>chapter-2</h1>
            
            <div class="meta">
                
            </div>
        </div>
    </header>

    <main class="container">
        <h1>第2章: ロボティクス実験の基礎</h1>

<strong>学習時間: 25-30分</strong>

<p>---</p>

<h2>導入</h2>

<p>実験自動化の心臓部は、ロボットアーム、液体ハンドリングシステム、センサーネットワークです。本章では、これらの基礎技術をPythonプログラミングを通じて実践的に学びます。</p>

<p>OpenTrons OT-2液体ハンドリングロボットを中心に、実際に動くコード例を通じて、試薬の分注、プレートの移動、センサーデータの取得など、自動化実験の基本操作を習得します。</p>

<p>---</p>

<h2>学習目標</h2>

<p>本章を学習することで、以下を習得できます：</p>

<ol>
<li><strong>ロボットアーム制御</strong>: 逆運動学、経路計画の基礎とPython実装</li>
<li><strong>液体ハンドリング</strong>: OpenTrons OT-2での精密ピペッティング</li>
<li><strong>固体ハンドリング</strong>: 粉末計量、錠剤成形の自動化手法</li>
<li><strong>センサー統合</strong>: カメラ、分光計、XRDとのインターフェース</li>
<li><strong>安全設計</strong>: エラーハンドリング、緊急停止、異常検知</li>
<li><strong>ラボウェア標準化</strong>: マイクロプレート、バイアル、キュベットの統一規格</li>
</ol>

<p>---</p>

<h2>2.1 ロボットアーム制御の基礎</h2>

<h3>2.1.1 順運動学と逆運動学</h3>

<p>ロボットアームの制御には2つの運動学問題があります。</p>

<strong>順運動学（Forward Kinematics）</strong>:
<p>関節角度 $\theta_1, \theta_2, ..., \theta_n$ からエンドエフェクタの位置・姿勢 $(x, y, z, roll, pitch, yaw)$ を計算</p>

<strong>逆運動学（Inverse Kinematics, IK）</strong>:
<p>目標位置・姿勢からそれを実現する関節角度を計算（実験では通常こちらを使用）</p>

<pre><code class="language-python">import numpy as np
<p>import matplotlib.pyplot as plt</p>
<p>from mpl_toolkits.mplot3d import Axes3D</p>

<p>class SimpleRobotArm:</p>
<p>"""</p>
<p>2リンク2D平面ロボットアームのシミュレーション</p>
<p>材料科学実験での試薬ボトルへのアクセス、サンプル移動などを想定</p>
<p>"""</p>

<p>def __init__(self, link1_length=0.3, link2_length=0.25):</p>
<p>"""</p>
<p>Args:</p>
<p>link1_length: 第1リンクの長さ（メートル）</p>
<p>link2_length: 第2リンクの長さ（メートル）</p>
<p>"""</p>
<p>self.L1 = link1_length</p>
<p>self.L2 = link2_length</p>

<p>def forward_kinematics(self, theta1, theta2):</p>
<p>"""</p>
<p>順運動学: 関節角度からエンドエフェクタ位置を計算</p>

<p>Args:</p>
<p>theta1: 第1関節の角度（度）</p>
<p>theta2: 第2関節の角度（度）</p>

<p>Returns:</p>
<p>(x, y): エンドエフェクタの位置</p>
<p>"""</p>
<p># 度をラジアンに変換</p>
<p>th1 = np.radians(theta1)</p>
<p>th2 = np.radians(theta2)</p>

<p># 第1リンクの先端位置</p>
<p>x1 = self.L1 * np.cos(th1)</p>
<p>y1 = self.L1 * np.sin(th1)</p>

<p># エンドエフェクタの位置</p>
<p>x = x1 + self.L2 * np.cos(th1 + th2)</p>
<p>y = y1 + self.L2 * np.sin(th1 + th2)</p>

<p>return x, y</p>

<p>def inverse_kinematics(self, target_x, target_y):</p>
<p>"""</p>
<p>逆運動学: 目標位置から関節角度を計算</p>

<p>Args:</p>
<p>target_x: 目標X座標</p>
<p>target_y: 目標Y座標</p>

<p>Returns:</p>
<p>(theta1, theta2): 関節角度（度）または None（到達不能）</p>
<p>"""</p>
<p># 到達可能性チェック</p>
<p>distance = np.sqrt(target_x<strong>2 + target_y</strong>2)</p>
<p>if distance > (self.L1 + self.L2) or distance < abs(self.L1 - self.L2):</p>
<p>print(f"警告: 目標位置 ({target_x:.2f}, {target_y:.2f}) は到達不能")</p>
<p>return None</p>

<p># 余弦定理による第2関節角度の計算</p>
<p>cos_theta2 = (target_x<strong>2 + target_y</strong>2 - self.L1<strong>2 - self.L2</strong>2) / (2 <em> self.L1 </em> self.L2)</p>
<p># 数値誤差対策</p>
<p>cos_theta2 = np.clip(cos_theta2, -1.0, 1.0)</p>

<p># Elbow-upの解を選択（実験で一般的）</p>
<p>theta2_rad = np.arccos(cos_theta2)</p>

<p># 第1関節角度の計算</p>
<p>k1 = self.L1 + self.L2 * np.cos(theta2_rad)</p>
<p>k2 = self.L2 * np.sin(theta2_rad)</p>
<p>theta1_rad = np.arctan2(target_y, target_x) - np.arctan2(k2, k1)</p>

<p># ラジアンから度に変換</p>
<p>theta1 = np.degrees(theta1_rad)</p>
<p>theta2 = np.degrees(theta2_rad)</p>

<p>return theta1, theta2</p>

<p>def plot_arm(self, theta1, theta2, target_point=None):</p>
<p>"""アームの現在位置を可視化"""</p>
<p>th1 = np.radians(theta1)</p>
<p>th2 = np.radians(theta2)</p>

<p># 各関節の位置</p>
<p>x0, y0 = 0, 0  # ベース</p>
<p>x1 = self.L1 * np.cos(th1)</p>
<p>y1 = self.L1 * np.sin(th1)</p>
<p>x2 = x1 + self.L2 * np.cos(th1 + th2)</p>
<p>y2 = y1 + self.L2 * np.sin(th1 + th2)</p>

<p>plt.figure(figsize=(8, 8))</p>
<p>plt.plot([x0, x1, x2], [y0, y1, y2], 'o-', linewidth=3, markersize=10, label='ロボットアーム')</p>
<p>plt.plot(x0, y0, 'ro', markersize=15, label='ベース')</p>
<p>plt.plot(x2, y2, 'go', markersize=12, label='エンドエフェクタ')</p>

<p>if target_point:</p>
<p>plt.plot(target_point[0], target_point[1], 'r*', markersize=20, label='目標位置')</p>

<p># 到達範囲の円</p>
<p>theta = np.linspace(0, 2*np.pi, 100)</p>
<p>r_max = self.L1 + self.L2</p>
<p>r_min = abs(self.L1 - self.L2)</p>
<p>plt.plot(r_max <em> np.cos(theta), r_max </em> np.sin(theta), 'k--', alpha=0.3, label='最大到達範囲')</p>
<p>plt.plot(r_min <em> np.cos(theta), r_min </em> np.sin(theta), 'k--', alpha=0.3)</p>

<p>plt.axis('equal')</p>
<p>plt.grid(True, alpha=0.3)</p>
<p>plt.xlabel('X 位置 (m)', fontsize=12)</p>
<p>plt.ylabel('Y 位置 (m)', fontsize=12)</p>
<p>plt.title('2リンクロボットアーム', fontsize=14, fontweight='bold')</p>
<p>plt.legend()</p>
<p>plt.tight_layout()</p>


<h1>使用例</h1>
<p>robot = SimpleRobotArm(link1_length=0.3, link2_length=0.25)</p>

<h1>逆運動学の使用例: 試薬ボトル (0.4, 0.2) にアクセス</h1>
<p>target_x, target_y = 0.4, 0.2</p>
<p>angles = robot.inverse_kinematics(target_x, target_y)</p>

<p>if angles:</p>
<p>theta1, theta2 = angles</p>
<p>print(f"目標位置: ({target_x}, {target_y})")</p>
<p>print(f"必要な関節角度: θ1 = {theta1:.2f}°, θ2 = {theta2:.2f}°")</p>

<p># 検証: 順運動学で位置を確認</p>
<p>x_check, y_check = robot.forward_kinematics(theta1, theta2)</p>
<p>error = np.sqrt((x_check - target_x)<strong>2 + (y_check - target_y)</strong>2)</p>
<p>print(f"検証: 実際の位置 ({x_check:.4f}, {y_check:.4f}), 誤差 {error:.6f}m")</p>

<p># 可視化</p>
<p>robot.plot_arm(theta1, theta2, target_point=(target_x, target_y))</p>
<p>plt.savefig('robot_arm_ik.png', dpi=300, bbox_inches='tight')</p>
<p>plt.show()</p>
</code></pre>

<strong>コード解説</strong>:
<ol>
<li><strong>順運動学</strong>: 三角関数で各リンクの位置を計算</li>
<li><strong>逆運動学</strong>: 余弦定理とアークタンジェントで関節角度を逆算</li>
<li><strong>到達可能性</strong>: 目標距離が $|L_1 - L_2| \leq d \leq L_1 + L_2$ の範囲にあるかチェック</li>
<li><strong>Elbow-up/down</strong>: 同じ目標位置に2つの解がある場合、実験では通常elbow-upを選択</li>
</ol>

<p>---</p>

<h3>2.1.2 軌道計画（Path Planning）</h3>

<p>試薬ボトルから反応容器への移動など、スムーズで安全な軌道を計画します。</p>

<pre><code class="language-python">def linear_trajectory(start_pos, end_pos, num_points=50):
<p>"""</p>
<p>2点間の直線軌道を生成</p>

<p>Args:</p>
<p>start_pos: 開始位置 (x, y)</p>
<p>end_pos: 終了位置 (x, y)</p>
<p>num_points: 軌道上の点数</p>

<p>Returns:</p>
<p>軌道上の点のリスト [(x1, y1), (x2, y2), ...]</p>
<p>"""</p>
<p>x_traj = np.linspace(start_pos[0], end_pos[0], num_points)</p>
<p>y_traj = np.linspace(start_pos[1], end_pos[1], num_points)</p>

<p>trajectory = list(zip(x_traj, y_traj))</p>
<p>return trajectory</p>

<p>def execute_trajectory(robot, trajectory, plot=True):</p>
<p>"""</p>
<p>軌道を実行（シミュレーション）</p>

<p>Args:</p>
<p>robot: RobotArmインスタンス</p>
<p>trajectory: 目標位置のリスト</p>
<p>plot: 軌道を可視化するか</p>
<p>"""</p>
<p>joint_angles = []</p>
<p>successful_points = []</p>

<p>for i, (x, y) in enumerate(trajectory):</p>
<p>angles = robot.inverse_kinematics(x, y)</p>
<p>if angles:</p>
<p>joint_angles.append(angles)</p>
<p>successful_points.append((x, y))</p>
<p>else:</p>
<p>print(f"警告: 点 {i} ({x:.3f}, {y:.3f}) は到達不能")</p>

<p>if plot and successful_points:</p>
<p>plt.figure(figsize=(10, 8))</p>

<p># 到達範囲</p>
<p>theta = np.linspace(0, 2*np.pi, 100)</p>
<p>r_max = robot.L1 + robot.L2</p>
<p>plt.plot(r_max <em> np.cos(theta), r_max </em> np.sin(theta), 'k--', alpha=0.2, label='最大到達範囲')</p>

<p># 軌道</p>
<p>traj_x, traj_y = zip(*successful_points)</p>
<p>plt.plot(traj_x, traj_y, 'b-', linewidth=2, alpha=0.6, label='計画軌道')</p>
<p>plt.plot(traj_x[0], traj_y[0], 'go', markersize=15, label='開始位置')</p>
<p>plt.plot(traj_x[-1], traj_y[-1], 'ro', markersize=15, label='終了位置')</p>

<p># いくつかの中間姿勢を表示</p>
<p>for i in range(0, len(joint_angles), len(joint_angles)//5):</p>
<p>theta1, theta2 = joint_angles[i]</p>
<p>th1 = np.radians(theta1)</p>
<p>th2 = np.radians(theta2)</p>

<p>x1 = robot.L1 * np.cos(th1)</p>
<p>y1 = robot.L1 * np.sin(th1)</p>
<p>x2 = x1 + robot.L2 * np.cos(th1 + th2)</p>
<p>y2 = y1 + robot.L2 * np.sin(th1 + th2)</p>

<p>plt.plot([0, x1, x2], [0, y1, y2], 'gray', alpha=0.3, linewidth=1)</p>

<p>plt.axis('equal')</p>
<p>plt.grid(True, alpha=0.3)</p>
<p>plt.xlabel('X 位置 (m)', fontsize=12)</p>
<p>plt.ylabel('Y 位置 (m)', fontsize=12)</p>
<p>plt.title('ロボットアームの軌道計画', fontsize=14, fontweight='bold')</p>
<p>plt.legend()</p>
<p>plt.tight_layout()</p>
<p>plt.savefig('trajectory_planning.png', dpi=300, bbox_inches='tight')</p>
<p>plt.show()</p>

<p>return joint_angles</p>


<h1>使用例: 試薬ボトル (0.35, 0.15) から反応容器 (0.25, 0.35) への移動</h1>
<p>robot = SimpleRobotArm()</p>
<p>start = (0.35, 0.15)</p>
<p>end = (0.25, 0.35)</p>

<p>trajectory = linear_trajectory(start, end, num_points=30)</p>
<p>print(f"軌道生成: {len(trajectory)}点")</p>

<p>joint_angles = execute_trajectory(robot, trajectory, plot=True)</p>
<p>print(f"実行成功: {len(joint_angles)}/{len(trajectory)}点")</p>
</code></pre>

<p>---</p>

<h2>2.2 液体ハンドリング: OpenTrons OT-2</h2>

<h3>2.2.1 OpenTrons OT-2の概要</h3>

<p>OpenTrons OT-2は、研究室で広く使われるオープンソースの液体ハンドリングロボットです。</p>

<strong>主な仕様</strong>:
<ul>
<li><strong>精度</strong>: ±1 µL（1-20 µL）、±2%（20-300 µL）</li>
<li><strong>容量</strong>: 1-1000 µL（ピペット交換で対応）</li>
<li><strong>デッキサイズ</strong>: 11スロット（マイクロプレート、チューブラック、試薬ボトル）</li>
<li><strong>価格</strong>: 約$10,000（学術割引あり）</li>
<li><strong>プログラミング</strong>: Python API（直感的で学習容易）</li>
</ul>

<h3>2.2.2 基本的なピペッティング</h3>

<pre><code class="language-python">from opentrons import protocol_api

<h1>OT-2プロトコル: 96ウェルプレートへの試薬分注</h1>
<p>metadata = {</p>
<p>'protocolName': '基本的なピペッティング',</p>
<p>'author': 'Materials Lab',</p>
<p>'description': '試薬を96ウェルプレートに分注',</p>
<p>'apiLevel': '2.13'</p>
<p>}</p>

<p>def run(protocol: protocol_api.ProtocolContext):</p>
<p>"""</p>
<p>基本的なピペッティングプロトコル</p>

<p>Args:</p>
<p>protocol: OpenTrons ProtocolContext</p>
<p>"""</p>
<p># デッキレイアウトの設定</p>
<p># スロット1: 96ウェルプレート（反応用）</p>
<p>plate = protocol.load_labware('corning_96_wellplate_360ul_flat', location='1')</p>

<p># スロット2: チューブラック（試薬ボトル）</p>
<p>tuberack = protocol.load_labware('opentrons_24_tuberack_eppendorf_1.5ml_safelock_snapcap', location='2')</p>

<p># スロット3: ピペットチップラック</p>
<p>tiprack = protocol.load_labware('opentrons_96_tiprack_300ul', location='3')</p>

<p># ピペットの装着（P300 Single-Channel）</p>
<p>pipette = protocol.load_instrument('p300_single_gen2', mount='left', tip_racks=[tiprack])</p>

<p># ピペッティング操作</p>
<p># 試薬A（チューブA1）を各ウェルに50 µL分注</p>
<p>reagent_a = tuberack.wells_by_name()['A1']</p>

<p>for well in plate.wells():</p>
<p>pipette.pick_up_tip()  # 新しいチップを取る</p>
<p>pipette.aspirate(50, reagent_a)  # 試薬を吸引（50 µL）</p>
<p>pipette.dispense(50, well)  # ウェルに分注</p>
<p>pipette.blow_out(well.top())  # 余剰液を排出</p>
<p>pipette.drop_tip()  # チップを廃棄</p>

<p>protocol.comment("プロトコル完了: 96ウェルすべてに試薬Aを分注しました")</p>


<h1>プロトコルのシミュレーション（実機なしで動作確認）</h1>
<h1>ターミナルで実行: opentrons_simulate basic_pipetting.py</h1>
</code></pre>

<strong>コード解説</strong>:
<ol>
<li><strong>Labware読み込み</strong>: プレート、チューブラック、チップラックをデッキに配置</li>
<li><strong>Pipette装着</strong>: シングルチャンネル300 µLピペット</li>
<li><strong>ピペッティングループ</strong>: 各ウェルに試薬を分注</li>
<li><strong>クロスコンタミネーション防止</strong>: 毎回新しいチップを使用</li>
</ol>

<p>---</p>

<h3>2.2.3 マルチチャンネルピペッティング</h3>

<p>96ウェルプレート全体への高速分注には、8チャンネルピペットを使用します。</p>

<pre><code class="language-python">def run(protocol: protocol_api.ProtocolContext):
<p>"""</p>
<p>マルチチャンネルピペッティング（8列同時分注）</p>
<p>"""</p>
<p># デッキレイアウト</p>
<p>source_plate = protocol.load_labware('nest_12_reservoir_15ml', location='1')  # 試薬リザーバー</p>
<p>dest_plate = protocol.load_labware('corning_96_wellplate_360ul_flat', location='2')</p>
<p>tiprack = protocol.load_labware('opentrons_96_tiprack_300ul', location='3')</p>

<p># 8チャンネルピペット</p>
<p>p300_multi = protocol.load_instrument('p300_multi_gen2', mount='left', tip_racks=[tiprack])</p>

<p># 試薬リザーバーから96ウェルプレートへ</p>
<p># 8チャンネルピペットは縦1列（8ウェル）を同時処理</p>
<p>p300_multi.pick_up_tip()</p>

<p># 12列を順次処理（96ウェル = 12列 × 8行）</p>
<p>for col in dest_plate.columns():</p>
<p>p300_multi.aspirate(100, source_plate['A1'])  # リザーバーから吸引</p>
<p>p300_multi.dispense(100, col[0])  # 列の最初のウェル（A1, A2, ..., A12）</p>
<p>p300_multi.blow_out()</p>

<p>p300_multi.drop_tip()</p>
<p>protocol.comment("96ウェル全てに100 µL分注完了")</p>


<h1>効率比較</h1>
<p>print("96ウェルプレートへの分注時間:")</p>
<p>print("  シングルチャンネル: 96ウェル × 20秒 = 32分")</p>
<p>print("  マルチチャンネル: 12列 × 20秒 = 4分")</p>
<p>print("  効率化: 8倍高速")</p>
</code></pre>

<p>---</p>

<h3>2.2.4 段階希釈（Serial Dilution）</h3>

<p>触媒スクリーニングなどで重要な段階希釈を自動化します。</p>

<pre><code class="language-python">def run(protocol: protocol_api.ProtocolContext):
<p>"""</p>
<p>段階希釈プロトコル（10倍希釈系列）</p>
<p>濃度: 10^0, 10^-1, 10^-2, ..., 10^-7 M</p>
<p>"""</p>
<p>plate = protocol.load_labware('corning_96_wellplate_360ul_flat', location='1')</p>
<p>tiprack = protocol.load_labware('opentrons_96_tiprack_300ul', location='2')</p>
<p>reservoir = protocol.load_labware('nest_12_reservoir_15ml', location='3')</p>

<p>pipette = protocol.load_instrument('p300_single_gen2', mount='left', tip_racks=[tiprack])</p>

<p># 希釈系列を作成（A列: 10^0 → 10^-7）</p>
<p># ウェルA1: 原液、A2-A8: 希釈液</p>

<p># 1. 各ウェルに溶媒を分注（A2-A8）</p>
<p>solvent = reservoir['A1']</p>
<p>for well in plate.columns()[0][1:8]:  # A2からA8</p>
<p>pipette.pick_up_tip()</p>
<p>pipette.transfer(180, solvent, well, new_tip='never')</p>
<p>pipette.drop_tip()</p>

<p># 2. 原液を A1 に分注</p>
<p>stock_solution = reservoir['A2']</p>
<p>pipette.transfer(200, stock_solution, plate['A1'], new_tip='once')</p>

<p># 3. 段階希釈の実行</p>
<p># A1 → A2 → A3 → ... → A8</p>
<p>pipette.pick_up_tip()</p>
<p>for i in range(7):</p>
<p>source_well = plate.columns()[0][i]  # A1, A2, ..., A7</p>
<p>dest_well = plate.columns()[0][i+1]  # A2, A3, ..., A8</p>

<p># 20 µLを次のウェルに移す</p>
<p>pipette.aspirate(20, source_well)</p>
<p>pipette.dispense(20, dest_well)</p>
<p>pipette.mix(3, 100, dest_well)  # 3回混合（100 µL）</p>

<p>pipette.drop_tip()</p>
<p>protocol.comment("段階希釈完了: 10^0 → 10^-7 M")</p>


<h1>段階希釈の濃度計算</h1>
<p>import pandas as pd</p>

<p>dilution_factor = 10  # 10倍希釈</p>
<p>num_dilutions = 8</p>
<p>initial_concentration = 1.0  # M</p>

<p>concentrations = [initial_concentration / (dilution_factor <em></em> i) for i in range(num_dilutions)]</p>
<p>wells = [f'A{i+1}' for i in range(num_dilutions)]</p>

<p>df_dilution = pd.DataFrame({</p>
<p>'ウェル': wells,</p>
<p>'濃度 (M)': concentrations,</p>
<p>'対数濃度': [f'10^{int(np.log10(c))}' if c >= 1e-10 else '0' for c in concentrations]</p>
<p>})</p>

<p>print("段階希釈系列:")</p>
<p>print(df_dilution.to_string(index=False))</p>
</code></pre>

<p>---</p>

<h2>2.3 固体ハンドリング</h2>

<h3>2.3.1 粉末計量の自動化</h3>

<p>固体試薬の自動計量には、精密天秤とロボットアームの連携が必要です。</p>

<pre><code class="language-python">class PowderDispenserSimulator:
<p>"""</p>
<p>粉末分注システムのシミュレーター</p>
<p>実際の装置: Mettler Toledo Balance + Robot Arm</p>
<p>"""</p>

<p>def __init__(self, accuracy=0.001):</p>
<p>"""</p>
<p>Args:</p>
<p>accuracy: 計量精度（グラム）</p>
<p>"""</p>
<p>self.accuracy = accuracy</p>
<p>self.dispensed_amounts = []</p>

<p>def dispense_powder(self, target_mass, powder_name='試薬A'):</p>
<p>"""</p>
<p>粉末を目標質量まで分注</p>

<p>Args:</p>
<p>target_mass: 目標質量（グラム）</p>
<p>powder_name: 粉末の名前</p>

<p>Returns:</p>
<p>actual_mass: 実際に分注された質量</p>
<p>"""</p>
<p># シミュレーション: 正規分布でばらつきを模擬</p>
<p>actual_mass = np.random.normal(target_mass, self.accuracy)</p>
<p>self.dispensed_amounts.append(actual_mass)</p>

<p>error = actual_mass - target_mass</p>
<p>print(f"{powder_name} 分注: 目標 {target_mass:.3f}g, 実測 {actual_mass:.3f}g (誤差: {error:+.4f}g)")</p>

<p>return actual_mass</p>

<p>def multi_component_dispensing(self, composition_dict):</p>
<p>"""</p>
<p>多成分粉末の自動配合</p>

<p>Args:</p>
<p>composition_dict: {成分名: 質量(g)}</p>

<p>Returns:</p>
<p>actual_composition: 実際の組成</p>
<p>"""</p>
<p>print("多成分配合開始:")</p>
<p>actual_composition = {}</p>

<p>for component, target_mass in composition_dict.items():</p>
<p>actual_mass = self.dispense_powder(target_mass, component)</p>
<p>actual_composition[component] = actual_mass</p>

<p>total_mass = sum(actual_composition.values())</p>
<p>print(f"\n合計質量: {total_mass:.3f}g")</p>

<p># 組成比（重量%）</p>
<p>print("\n実際の組成比（wt%）:")</p>
<p>for component, mass in actual_composition.items():</p>
<p>percentage = (mass / total_mass) * 100</p>
<p>print(f"  {component}: {percentage:.2f}%")</p>

<p>return actual_composition</p>


<h1>使用例: 三元系触媒 (NiO, CoO, MnO2) の配合</h1>
<p>dispenser = PowderDispenserSimulator(accuracy=0.002)</p>

<h1>目標組成: Ni:Co:Mn = 60:20:20 (wt%)</h1>
<p>total_mass = 1.0  # 合計1.0g</p>
<p>composition = {</p>
<p>'NiO': 0.6,</p>
<p>'CoO': 0.2,</p>
<p>'MnO2': 0.2</p>
<p>}</p>

<p>actual_comp = dispenser.multi_component_dispensing(composition)</p>

<h1>精度評価</h1>
<p>print("\n精度評価:")</p>
<p>for component, target_mass in composition.items():</p>
<p>actual_mass = actual_comp[component]</p>
<p>error_percent = abs((actual_mass - target_mass) / target_mass) * 100</p>
<p>print(f"  {component}: 誤差 {error_percent:.2f}%")</p>
</code></pre>

<p>---</p>

<h3>2.3.2 固体試料の移送</h3>

<pre><code class="language-python">def solid_sample_transfer_protocol():
<p>"""</p>
<p>固体試料の自動移送プロトコル（疑似コード）</p>
<p>実際の実装はロボットアームのAPIに依存</p>
<p>"""</p>
<p>protocol_steps = [</p>
<p>"1. ロボットアームがサンプルホルダーを把持",</p>
<p>"2. XRD測定位置に移動",</p>
<p>"3. サンプルをXRDステージに配置",</p>
<p>"4. XRD測定開始（外部トリガー）",</p>
<p>"5. 測定完了を待機",</p>
<p>"6. サンプルを回収",</p>
<p>"7. 次のサンプル位置に移動",</p>
<p>"8. ステップ1-7を繰り返し"</p>
<p>]</p>

<p>for step in protocol_steps:</p>
<p>print(step)</p>

<p># 疑似コード: 実際のロボット制御</p>
<p>"""</p>
<p># Universal Robots UR5eの例</p>
<p>import urx</p>

<p>robot = urx.Robot("192.168.1.100")  # ロボットのIPアドレス</p>

<p># サンプル位置（XYZ座標、ミリメートル）</p>
<p>sample_position = [300, 200, 100, 0, 0, 0]  # X, Y, Z, RX, RY, RZ</p>
<p>xrd_position = [500, 200, 150, 0, 0, 0]</p>

<p># 移動</p>
<p>robot.movel(sample_position, acc=0.1, vel=0.1)  # 線形移動</p>
<p># グリッパーでサンプル把持</p>
<p>robot.set_digital_out(0, True)  # デジタル出力でグリッパー制御</p>

<p>robot.movel(xrd_position, acc=0.1, vel=0.1)</p>
<p># サンプルを配置</p>
<p>robot.set_digital_out(0, False)</p>

<p>robot.close()</p>
<p>"""</p>

<p>solid_sample_transfer_protocol()</p>
</code></pre>

<p>---</p>

<h2>2.4 センサー統合</h2>

<h3>2.4.1 分光計との連携</h3>

<p>UV-Vis分光計でリアルタイムに反応をモニタリングします。</p>

<pre><code class="language-python">import time

<p>class SpectrometerSimulator:</p>
<p>"""</p>
<p>UV-Vis分光計シミュレーター</p>
<p>実際の装置: Ocean Optics USB4000, Agilent Cary 60</p>
<p>"""</p>

<p>def __init__(self, wavelength_range=(200, 800), resolution=1):</p>
<p>"""</p>
<p>Args:</p>
<p>wavelength_range: 波長範囲（nm）</p>
<p>resolution: 波長分解能（nm）</p>
<p>"""</p>
<p>self.wavelengths = np.arange(wavelength_range[0], wavelength_range[1], resolution)</p>

<p>def measure_absorbance(self, sample_id, concentration=0.1):</p>
<p>"""</p>
<p>吸光度測定（シミュレーション）</p>

<p>Args:</p>
<p>sample_id: サンプルID</p>
<p>concentration: 濃度（M）</p>

<p>Returns:</p>
<p>wavelengths, absorbance: 波長と吸光度の配列</p>
<p>"""</p>
<p># Beer-Lambert則: A = ε <em> c </em> l</p>
<p># ピーク波長: 450 nm（仮想的な化合物）</p>
<p>peak_wavelength = 450</p>
<p>peak_absorbance = concentration * 10  # εcl = 10 (仮定)</p>

<p># ガウス型吸収スペクトル</p>
<p>absorbance = peak_absorbance <em> np.exp(-((self.wavelengths - peak_wavelength) / 50)</em>*2)</p>

<p># ノイズ追加</p>
<p>noise = np.random.normal(0, 0.01, len(self.wavelengths))</p>
<p>absorbance += noise</p>

<p>print(f"サンプル {sample_id} 測定完了: ピーク波長 {peak_wavelength}nm, 吸光度 {peak_absorbance:.3f}")</p>

<p>return self.wavelengths, absorbance</p>

<p>def kinetic_measurement(self, duration=60, interval=5):</p>
<p>"""</p>
<p>反応速度論測定（時間変化を追跡）</p>

<p>Args:</p>
<p>duration: 測定時間（秒）</p>
<p>interval: 測定間隔（秒）</p>

<p>Returns:</p>
<p>times, absorbance_at_450nm: 時間と450nmでの吸光度</p>
<p>"""</p>
<p>times = np.arange(0, duration, interval)</p>
<p>absorbance_450 = []</p>

<p>print("反応速度論測定開始...")</p>
<p>for t in times:</p>
<p># 一次反応のシミュレーション: [A] = [A]0 * exp(-kt)</p>
<p>k = 0.02  # s^-1</p>
<p>concentration = 0.1 <em> np.exp(-k </em> t)</p>

<p>_, abs_spectrum = self.measure_absorbance(f't={t}s', concentration)</p>
<p># 450nmでの吸光度を抽出</p>
<p>idx_450 = np.argmin(np.abs(self.wavelengths - 450))</p>
<p>absorbance_450.append(abs_spectrum[idx_450])</p>

<p>time.sleep(0.1)  # 実際の測定では実時間で待機</p>

<p>return times, np.array(absorbance_450)</p>


<h1>使用例</h1>
<p>spectrometer = SpectrometerSimulator()</p>

<h1>スペクトル測定</h1>
<p>wavelengths, absorbance = spectrometer.measure_absorbance('Sample_001', concentration=0.15)</p>

<p>plt.figure(figsize=(10, 6))</p>
<p>plt.plot(wavelengths, absorbance, linewidth=2)</p>
<p>plt.xlabel('波長 (nm)', fontsize=12)</p>
<p>plt.ylabel('吸光度', fontsize=12)</p>
<p>plt.title('UV-Vis吸収スペクトル', fontsize=14, fontweight='bold')</p>
<p>plt.grid(alpha=0.3)</p>
<p>plt.tight_layout()</p>
<p>plt.savefig('uv_vis_spectrum.png', dpi=300, bbox_inches='tight')</p>
<p>plt.show()</p>

<h1>反応速度論測定</h1>
<p>times, abs_450 = spectrometer.kinetic_measurement(duration=100, interval=10)</p>

<p>plt.figure(figsize=(10, 6))</p>
<p>plt.plot(times, abs_450, 'o-', linewidth=2, markersize=8)</p>
<p>plt.xlabel('時間 (s)', fontsize=12)</p>
<p>plt.ylabel('吸光度 (450 nm)', fontsize=12)</p>
<p>plt.title('反応速度論測定', fontsize=14, fontweight='bold')</p>
<p>plt.grid(alpha=0.3)</p>
<p>plt.tight_layout()</p>
<p>plt.savefig('kinetic_measurement.png', dpi=300, bbox_inches='tight')</p>
<p>plt.show()</p>

<h1>一次反応速度定数のフィッティング</h1>
<p>from scipy.optimize import curve_fit</p>

<p>def first_order_kinetics(t, A0, k):</p>
<p>return A0 <em> np.exp(-k </em> t)</p>

<p>params, covariance = curve_fit(first_order_kinetics, times, abs_450, p0=[1.5, 0.02])</p>
<p>A0_fit, k_fit = params</p>

<p>print(f"\n一次反応フィッティング:")</p>
<p>print(f"  初期吸光度 A0 = {A0_fit:.3f}")</p>
<p>print(f"  速度定数 k = {k_fit:.4f} s^-1")</p>
<p>print(f"  半減期 t1/2 = {np.log(2)/k_fit:.1f} s")</p>
</code></pre>

<p>---</p>

<h3>2.4.2 カメラによる画像解析</h3>

<p>結晶成長、沈殿形成、色変化などをカメラで自動記録・解析します。</p>

<pre><code class="language-python">from PIL import Image, ImageDraw, ImageFont
<p>import cv2</p>

<p>class LabCameraSimulator:</p>
<p>"""</p>
<p>実験用カメラシミュレーター</p>
<p>実際の装置: Basler ace, FLIR Blackfly</p>
<p>"""</p>

<p>def __init__(self, resolution=(1920, 1080)):</p>
<p>self.resolution = resolution</p>

<p>def capture_wellplate(self, plate_id='Plate_001'):</p>
<p>"""</p>
<p>96ウェルプレートの画像取得（シミュレーション）</p>

<p>Returns:</p>
<p>image: PIL Image</p>
<p>"""</p>
<p># シミュレーション: 96ウェルプレートのグリッド画像を生成</p>
<p>img = Image.new('RGB', self.resolution, color='white')</p>
<p>draw = ImageDraw.Draw(img)</p>

<p># 8行 × 12列のウェル</p>
<p>well_diameter = 50</p>
<p>spacing = 70</p>
<p>offset_x, offset_y = 200, 100</p>

<p>for row in range(8):</p>
<p>for col in range(12):</p>
<p>center_x = offset_x + col * spacing</p>
<p>center_y = offset_y + row * spacing</p>

<p># ウェルの色（濃度に応じて変化をシミュレート）</p>
<p>intensity = int(255 * (1 - (row + col) / 20))  # 徐々に濃くなる</p>
<p>color = (intensity, intensity, 255)</p>

<p># ウェルを描画</p>
<p>draw.ellipse([center_x - well_diameter//2, center_y - well_diameter//2,</p>
<p>center_x + well_diameter//2, center_y + well_diameter//2],</p>
<p>fill=color, outline='black')</p>

<p>print(f"プレート {plate_id} の画像取得完了")</p>
<p>return img</p>

<p>def analyze_well_color(self, image, well_position):</p>
<p>"""</p>
<p>特定ウェルの色を解析</p>

<p>Args:</p>
<p>image: PIL Image</p>
<p>well_position: (row, col) ウェル位置</p>

<p>Returns:</p>
<p>rgb_mean: RGB平均値</p>
<p>"""</p>
<p>row, col = well_position</p>
<p>well_diameter = 50</p>
<p>spacing = 70</p>
<p>offset_x, offset_y = 200, 100</p>

<p>center_x = offset_x + col * spacing</p>
<p>center_y = offset_y + row * spacing</p>

<p># ウェル領域を切り出し</p>
<p>crop_box = (center_x - well_diameter//2, center_y - well_diameter//2,</p>
<p>center_x + well_diameter//2, center_y + well_diameter//2)</p>
<p>well_img = image.crop(crop_box)</p>

<p># RGB平均値を計算</p>
<p>well_array = np.array(well_img)</p>
<p>rgb_mean = well_array.mean(axis=(0, 1))</p>

<p>return rgb_mean</p>


<h1>使用例</h1>
<p>camera = LabCameraSimulator()</p>
<p>plate_image = camera.capture_wellplate('Plate_001')</p>
<p>plate_image.save('wellplate_image.png')</p>

<h1>ウェルA1の色解析</h1>
<p>rgb = camera.analyze_well_color(plate_image, well_position=(0, 0))</p>
<p>print(f"ウェルA1のRGB値: R={rgb[0]:.1f}, G={rgb[1]:.1f}, B={rgb[2]:.1f}")</p>

<h1>全ウェルの色解析</h1>
<p>print("\n全ウェルの青色成分（B値）マップ:")</p>
<p>blue_values = np.zeros((8, 12))</p>
<p>for row in range(8):</p>
<p>for col in range(12):</p>
<p>rgb = camera.analyze_well_color(plate_image, (row, col))</p>
<p>blue_values[row, col] = rgb[2]</p>

<p>plt.figure(figsize=(12, 6))</p>
<p>plt.imshow(blue_values, cmap='Blues', interpolation='nearest')</p>
<p>plt.colorbar(label='青色成分 (B値)')</p>
<p>plt.xlabel('列', fontsize=12)</p>
<p>plt.ylabel('行', fontsize=12)</p>
<p>plt.title('96ウェルプレートの色分布', fontsize=14, fontweight='bold')</p>
<p>plt.xticks(range(12), [f'{i+1}' for i in range(12)])</p>
<p>plt.yticks(range(8), ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'])</p>
<p>plt.tight_layout()</p>
<p>plt.savefig('wellplate_color_map.png', dpi=300, bbox_inches='tight')</p>
<p>plt.show()</p>
</code></pre>

<p>---</p>

<h2>2.5 安全性とエラーハンドリング</h2>

<h3>2.5.1 緊急停止機能</h3>

<pre><code class="language-python">class SafetyController:
<p>"""</p>
<p>実験自動化システムの安全制御</p>
<p>"""</p>

<p>def __init__(self):</p>
<p>self.emergency_stop = False</p>
<p>self.error_log = []</p>

<p>def check_safety(self, temperature, pressure, liquid_level):</p>
<p>"""</p>
<p>安全パラメータのチェック</p>

<p>Args:</p>
<p>temperature: 温度（℃）</p>
<p>pressure: 圧力（bar）</p>
<p>liquid_level: 液面レベル（%）</p>

<p>Returns:</p>
<p>is_safe: 安全かどうか</p>
<p>"""</p>
<p>is_safe = True</p>
<p>warnings = []</p>

<p># 温度チェック</p>
<p>if temperature > 100:</p>
<p>warnings.append(f"警告: 温度が高すぎます ({temperature}℃)")</p>
<p>is_safe = False</p>

<p># 圧力チェック</p>
<p>if pressure > 5:</p>
<p>warnings.append(f"警告: 圧力が高すぎます ({pressure} bar)")</p>
<p>is_safe = False</p>

<p># 液面レベルチェック</p>
<p>if liquid_level < 10:</p>
<p>warnings.append(f"警告: 液面が低すぎます ({liquid_level}%)")</p>
<p>is_safe = False</p>

<p>if not is_safe:</p>
<p>for warning in warnings:</p>
<p>print(warning)</p>
<p>self.error_log.append({'time': time.strftime('%Y-%m-%d %H:%M:%S'), 'message': warning})</p>

<p>return is_safe</p>

<p>def emergency_stop_sequence(self):</p>
<p>"""緊急停止シーケンス"""</p>
<p>print("\n🚨 緊急停止を実行します 🚨")</p>
<p>self.emergency_stop = True</p>

<p># 停止アクション</p>
<p>actions = [</p>
<p>"1. すべてのロボット動作を停止",</p>
<p>"2. ヒーターを停止",</p>
<p>"3. 冷却水を循環",</p>
<p>"4. バルブを安全位置に移動",</p>
<p>"5. オペレーターに通知",</p>
<p>"6. ログを記録"</p>
<p>]</p>

<p>for action in actions:</p>
<p>print(action)</p>
<p>time.sleep(0.5)</p>

<p>print("\n緊急停止完了。システムは安全状態です。")</p>

<p>def print_error_log(self):</p>
<p>"""エラーログを表示"""</p>
<p>print("\n=== エラーログ ===")</p>
<p>for error in self.error_log:</p>
<p>print(f"[{error['time']}] {error['message']}")</p>


<h1>使用例</h1>
<p>safety = SafetyController()</p>

<h1>正常な状態</h1>
<p>print("=== 正常運転 ===")</p>
<p>is_safe = safety.check_safety(temperature=80, pressure=2.0, liquid_level=50)</p>
<p>print(f"安全状態: {is_safe}\n")</p>

<h1>異常な状態</h1>
<p>print("=== 異常検知 ===")</p>
<p>is_safe = safety.check_safety(temperature=120, pressure=6.5, liquid_level=5)</p>
<p>print(f"安全状態: {is_safe}")</p>

<p>if not is_safe:</p>
<p>safety.emergency_stop_sequence()</p>

<p>safety.print_error_log()</p>
</code></pre>

<p>---</p>

<h3>2.5.2 エラーリカバリー</h3>

<pre><code class="language-python">def robust_pipetting_with_retry(pipette, source, dest, volume, max_retries=3):
<p>"""</p>
<p>エラーリカバリー付きピペッティング</p>

<p>Args:</p>
<p>pipette: OT-2 pipette</p>
<p>source: 吸引元</p>
<p>dest: 分注先</p>
<p>volume: 容量（µL）</p>
<p>max_retries: 最大リトライ回数</p>

<p>Returns:</p>
<p>success: 成功したかどうか</p>
<p>"""</p>
<p>for attempt in range(max_retries):</p>
<p>try:</p>
<p>pipette.pick_up_tip()</p>
<p>pipette.aspirate(volume, source)</p>
<p>pipette.dispense(volume, dest)</p>
<p>pipette.drop_tip()</p>

<p>print(f"ピペッティング成功: {volume} µL ({attempt+1}回目)")</p>
<p>return True</p>

<p>except Exception as e:</p>
<p>print(f"エラー発生 ({attempt+1}回目): {e}")</p>

<p># リカバリーアクション</p>
<p>if pipette.has_tip:</p>
<p>pipette.drop_tip()</p>

<p>if attempt < max_retries - 1:</p>
<p>print("リトライします...")</p>
<p>time.sleep(1)</p>
<p>else:</p>
<p>print("最大リトライ回数に達しました。操作を中止します。")</p>
<p>return False</p>

<p>return False</p>


<h1>疑似コードでの使用例</h1>
<p>print("エラーリカバリー付きピペッティングのデモ:\n")</p>

<p>class MockPipette:</p>
<p>def __init__(self, fail_probability=0.3):</p>
<p>self.has_tip = False</p>
<p>self.fail_probability = fail_probability</p>

<p>def pick_up_tip(self):</p>
<p>if np.random.random() < self.fail_probability:</p>
<p>raise Exception("チップ取得失敗")</p>
<p>self.has_tip = True</p>

<p>def aspirate(self, volume, source):</p>
<p>if np.random.random() < self.fail_probability:</p>
<p>raise Exception("吸引失敗")</p>

<p>def dispense(self, volume, dest):</p>
<p>if np.random.random() < self.fail_probability:</p>
<p>raise Exception("分注失敗")</p>

<p>def drop_tip(self):</p>
<p>self.has_tip = False</p>

<p>mock_pipette = MockPipette(fail_probability=0.4)  # 40%の確率で失敗</p>
<p>success = robust_pipetting_with_retry(mock_pipette, 'A1', 'B1', 100, max_retries=5)</p>
<p>print(f"\n最終結果: {'成功' if success else '失敗'}")</p>
</code></pre>

<p>---</p>

<h2>2.6 ラボウェアの標準化</h2>

<h3>2.6.1 SBS（Society for Biomolecular Screening）規格</h3>

<p>96ウェルプレート、384ウェルプレートなど、ラボウェアの寸法は国際規格で標準化されています。</p>

<pre><code class="language-python">class SBS_Labware:
<p>"""</p>
<p>SBS規格のラボウェア仕様</p>
<p>"""</p>

<p>@staticmethod</p>
<p>def plate_96_well():</p>
<p>"""96ウェルプレートの仕様"""</p>
<p>specs = {</p>
<p>'名称': '96ウェルプレート',</p>
<p>'フットプリント': '127.76 mm × 85.48 mm (SBS規格)',</p>
<p>'ウェル配置': '8行 × 12列',</p>
<p>'ウェル間隔': '9.0 mm (中心間)',</p>
<p>'ウェル容量': '通常 300-360 µL',</p>
<p>'ウェル形状': 'フラット、U字型、V字型',</p>
<p>'用途': '一般的なスクリーニング、アッセイ'</p>
<p>}</p>
<p>return specs</p>

<p>@staticmethod</p>
<p>def plate_384_well():</p>
<p>"""384ウェルプレートの仕様"""</p>
<p>specs = {</p>
<p>'名称': '384ウェルプレート',</p>
<p>'フットプリント': '127.76 mm × 85.48 mm (96ウェルと同じ)',</p>
<p>'ウェル配置': '16行 × 24列',</p>
<p>'ウェル間隔': '4.5 mm (中心間、96ウェルの半分)',</p>
<p>'ウェル容量': '通常 50-100 µL',</p>
<p>'用途': '高密度スクリーニング、創薬'</p>
<p>}</p>
<p>return specs</p>

<p>@staticmethod</p>
<p>def plot_wellplate_layout(n_wells=96):</p>
<p>"""ウェルプレートのレイアウトを可視化"""</p>
<p>if n_wells == 96:</p>
<p>rows, cols = 8, 12</p>
<p>well_spacing = 9.0  # mm</p>
<p>elif n_wells == 384:</p>
<p>rows, cols = 16, 24</p>
<p>well_spacing = 4.5  # mm</p>
<p>else:</p>
<p>raise ValueError("96または384ウェルのみサポート")</p>

<p>fig, ax = plt.subplots(figsize=(12, 6))</p>

<p># ウェルを描画</p>
<p>for row in range(rows):</p>
<p>for col in range(cols):</p>
<p>x = col * well_spacing</p>
<p>y = row * well_spacing</p>
<p>circle = plt.Circle((x, y), radius=well_spacing*0.4, color='lightblue', ec='black')</p>
<p>ax.add_patch(circle)</p>

<p># ウェル名を表示（96ウェルのみ、見やすさのため）</p>
<p>if n_wells == 96:</p>
<p>well_name = f"{chr(65+row)}{col+1}"</p>
<p>ax.text(x, y, well_name, ha='center', va='center', fontsize=8)</p>

<p>ax.set_xlim(-well_spacing, cols * well_spacing)</p>
<p>ax.set_ylim(-well_spacing, rows * well_spacing)</p>
<p>ax.set_aspect('equal')</p>
<p>ax.invert_yaxis()  # Y軸を反転（A行が上）</p>
<p>ax.set_xlabel('X 方向 (mm)', fontsize=12)</p>
<p>ax.set_ylabel('Y 方向 (mm)', fontsize=12)</p>
<p>ax.set_title(f'{n_wells}ウェルプレート レイアウト (SBS規格)', fontsize=14, fontweight='bold')</p>
<p>ax.grid(alpha=0.3)</p>
<p>plt.tight_layout()</p>
<p>plt.savefig(f'{n_wells}_wellplate_layout.png', dpi=300, bbox_inches='tight')</p>
<p>plt.show()</p>


<h1>仕様の表示</h1>
<p>labware = SBS_Labware()</p>

<p>print("=== 96ウェルプレート ===")</p>
<p>for key, value in labware.plate_96_well().items():</p>
<p>print(f"{key}: {value}")</p>

<p>print("\n=== 384ウェルプレート ===")</p>
<p>for key, value in labware.plate_384_well().items():</p>
<p>print(f"{key}: {value}")</p>

<h1>レイアウトの可視化</h1>
<p>labware.plot_wellplate_layout(n_wells=96)</p>
</code></pre>

<p>---</p>

<h2>2.7 演習問題</h2>

<h3>演習1: ロボットアームの軌道最適化（難易度: Medium）</h3>

<p>2つの試薬ボトル（位置A: (0.35, 0.15)、位置B: (0.25, 0.35)）と反応容器（位置C: (0.4, 0.3)）がある場合、最短時間で A → B → C の順に訪問する軌道を計画してください。</p>

<details>
<summary>ヒント</summary>

<p>直線軌道の移動時間は距離に比例します。A→B→C と A→C→B の2つのルートを比較し、総移動距離が短い方を選択してください。</p>

</details>

<details>
<summary>解答例</summary>

<pre><code class="language-python">def calculate_path_length(points):
<p>"""経路の総距離を計算"""</p>
<p>total_distance = 0</p>
<p>for i in range(len(points) - 1):</p>
<p>dx = points[i+1][0] - points[i][0]</p>
<p>dy = points[i+1][1] - points[i][1]</p>
<p>distance = np.sqrt(dx<strong>2 + dy</strong>2)</p>
<p>total_distance += distance</p>
<p>return total_distance</p>

<h1>試薬ボトルと反応容器の位置</h1>
<p>A = (0.35, 0.15)  # 試薬A</p>
<p>B = (0.25, 0.35)  # 試薬B</p>
<p>C = (0.4, 0.3)    # 反応容器</p>

<h1>ルート1: A → B → C</h1>
<p>route1 = [A, B, C]</p>
<p>distance1 = calculate_path_length(route1)</p>

<h1>ルート2: A → C → B</h1>
<p>route2 = [A, C, B]</p>
<p>distance2 = calculate_path_length(route2)</p>

<p>print("ルート比較:")</p>
<p>print(f"  A → B → C: {distance1:.3f} m")</p>
<p>print(f"  A → C → B: {distance2:.3f} m")</p>

<p>if distance1 < distance2:</p>
<p>print(f"\n最適ルート: A → B → C（{distance1:.3f} m）")</p>
<p>optimal_route = route1</p>
<p>else:</p>
<p>print(f"\n最適ルート: A → C → B（{distance2:.3f} m）")</p>
<p>optimal_route = route2</p>

<h1>可視化</h1>
<p>robot = SimpleRobotArm()</p>
<p>fig, ax = plt.subplots(figsize=(10, 8))</p>

<h1>到達範囲</h1>
<p>theta = np.linspace(0, 2*np.pi, 100)</p>
<p>r_max = robot.L1 + robot.L2</p>
<p>ax.plot(r_max <em> np.cos(theta), r_max </em> np.sin(theta), 'k--', alpha=0.2, label='最大到達範囲')</p>

<h1>位置をプロット</h1>
<p>for point, label in zip([A, B, C], ['試薬A', '試薬B', '反応容器']):</p>
<p>ax.plot(point[0], point[1], 'o', markersize=15, label=label)</p>

<h1>最適ルートを描画</h1>
<p>route_x, route_y = zip(*optimal_route)</p>
<p>ax.plot(route_x, route_y, 'r-', linewidth=2, alpha=0.6, label='最適経路')</p>

<p>ax.axis('equal')</p>
<p>ax.grid(alpha=0.3)</p>
<p>ax.set_xlabel('X 位置 (m)', fontsize=12)</p>
<p>ax.set_ylabel('Y 位置 (m)', fontsize=12)</p>
<p>ax.set_title('経路最適化', fontsize=14, fontweight='bold')</p>
<p>ax.legend()</p>
<p>plt.tight_layout()</p>
<p>plt.savefig('path_optimization.png', dpi=300, bbox_inches='tight')</p>
<p>plt.show()</p>
</code></pre>

</details>

<p>---</p>

<h3>演習2: 96ウェルプレートへの複数試薬分注（難易度: Medium）</h3>

<p>96ウェルプレートに3種類の試薬（A、B、C）を以下のパターンで分注するOpenTronsプロトコルを作成してください。</p>

<ul>
<li>試薬A: 列1-4（ウェルA1-H4）に50 µL</li>
<li>試薬B: 列5-8（ウェルA5-H8）に50 µL</li>
<li>試薬C: 列9-12（ウェルA9-H12）に50 µL</li>
</ul>

<details>
<summary>ヒント</summary>

<p>8チャンネルピペットを使用すれば、各列を1回のピペッティングで処理できます。<code>plate.columns()[0:4]</code>で列1-4を選択できます。</p>

</details>

<details>
<summary>解答例</summary>

<pre><code class="language-python">from opentrons import protocol_api

<p>metadata = {</p>
<p>'protocolName': '96ウェル 3試薬分注',</p>
<p>'author': 'Materials Lab',</p>
<p>'description': '3種類の試薬を列ごとに分注',</p>
<p>'apiLevel': '2.13'</p>
<p>}</p>

<p>def run(protocol: protocol_api.ProtocolContext):</p>
<p># デッキレイアウト</p>
<p>plate = protocol.load_labware('corning_96_wellplate_360ul_flat', location='1')</p>
<p>reservoir = protocol.load_labware('nest_12_reservoir_15ml', location='2')</p>
<p>tiprack = protocol.load_labware('opentrons_96_tiprack_300ul', location='3')</p>

<p># 8チャンネルピペット</p>
<p>pipette = protocol.load_instrument('p300_multi_gen2', mount='left', tip_racks=[tiprack])</p>

<p># 試薬の位置</p>
<p>reagent_a = reservoir['A1']</p>
<p>reagent_b = reservoir['A2']</p>
<p>reagent_c = reservoir['A3']</p>

<p># 試薬Aを列1-4に分注</p>
<p>pipette.pick_up_tip()</p>
<p>for col in plate.columns()[0:4]:  # 列1-4</p>
<p>pipette.aspirate(50, reagent_a)</p>
<p>pipette.dispense(50, col[0])  # 列の先頭ウェル（A1, A2, A3, A4）</p>
<p>pipette.blow_out()</p>
<p>pipette.drop_tip()</p>

<p>protocol.comment("試薬A 分注完了")</p>

<p># 試薬Bを列5-8に分注</p>
<p>pipette.pick_up_tip()</p>
<p>for col in plate.columns()[4:8]:  # 列5-8</p>
<p>pipette.aspirate(50, reagent_b)</p>
<p>pipette.dispense(50, col[0])</p>
<p>pipette.blow_out()</p>
<p>pipette.drop_tip()</p>

<p>protocol.comment("試薬B 分注完了")</p>

<p># 試薬Cを列9-12に分注</p>
<p>pipette.pick_up_tip()</p>
<p>for col in plate.columns()[8:12]:  # 列9-12</p>
<p>pipette.aspirate(50, reagent_c)</p>
<p>pipette.dispense(50, col[0])</p>
<p>pipette.blow_out()</p>
<p>pipette.drop_tip()</p>

<p>protocol.comment("試薬C 分注完了")</p>
<p>protocol.comment("プロトコル完了: 96ウェル全てに試薬を分注しました")</p>

<h1>シミュレーション実行</h1>
<p>print("プロトコル作成完了")</p>
<p>print("実行コマンド: opentrons_simulate three_reagent_protocol.py")</p>
</code></pre>

</details>

<p>---</p>

<h3>演習3: センサーデータの異常検知（難易度: Hard）</h3>

<p>UV-Vis分光計で反応をモニタリング中、異常な吸光度変化（急激な増加または減少）を検知し、緊急停止するシステムを実装してください。</p>

<strong>条件</strong>:
<ul>
<li>測定間隔: 10秒</li>
<li>異常判定: 前回測定値から20%以上変化した場合</li>
<li>異常が2回連続した場合に緊急停止</li>
</ul>

<details>
<summary>ヒント</summary>

<p>各測定で前回値と比較し、変化率を計算します。異常カウンターを導入し、2回連続で異常が検知されたら緊急停止を実行します。</p>

</details>

<details>
<summary>解答例</summary>

<pre><code class="language-python">class ReactionMonitor:
<p>"""</p>
<p>反応モニタリングと異常検知</p>
<p>"""</p>

<p>def __init__(self, anomaly_threshold=0.2, consecutive_anomalies=2):</p>
<p>"""</p>
<p>Args:</p>
<p>anomaly_threshold: 異常判定の閾値（変化率）</p>
<p>consecutive_anomalies: 緊急停止までの連続異常回数</p>
<p>"""</p>
<p>self.threshold = anomaly_threshold</p>
<p>self.consecutive_threshold = consecutive_anomalies</p>
<p>self.anomaly_count = 0</p>
<p>self.previous_value = None</p>
<p>self.measurements = []</p>

<p>def check_anomaly(self, current_value):</p>
<p>"""</p>
<p>異常検知</p>

<p>Args:</p>
<p>current_value: 現在の測定値</p>

<p>Returns:</p>
<p>is_anomaly: 異常かどうか</p>
<p>"""</p>
<p>if self.previous_value is None:</p>
<p>self.previous_value = current_value</p>
<p>return False</p>

<p># 変化率を計算</p>
<p>change_rate = abs((current_value - self.previous_value) / self.previous_value)</p>

<p>is_anomaly = change_rate > self.threshold</p>

<p>if is_anomaly:</p>
<p>self.anomaly_count += 1</p>
<p>print(f"⚠️ 異常検知: 変化率 {change_rate<em>100:.1f}% (閾値: {self.threshold</em>100:.1f}%)")</p>
<p>print(f"   前回値: {self.previous_value:.3f}, 現在値: {current_value:.3f}")</p>
<p>print(f"   連続異常回数: {self.anomaly_count}/{self.consecutive_threshold}")</p>
<p>else:</p>
<p>self.anomaly_count = 0  # 正常なら異常カウンターをリセット</p>

<p>self.previous_value = current_value</p>
<p>return is_anomaly</p>

<p>def should_emergency_stop(self):</p>
<p>"""緊急停止が必要か判定"""</p>
<p>return self.anomaly_count >= self.consecutive_threshold</p>


<h1>シミュレーション</h1>
<p>print("=== 反応モニタリング開始 ===\n")</p>
<p>monitor = ReactionMonitor(anomaly_threshold=0.2, consecutive_anomalies=2)</p>
<p>safety = SafetyController()</p>

<h1>測定データ（シミュレーション）</h1>
<h1>正常 → 正常 → 異常1 → 異常2（緊急停止）</h1>
<p>simulated_absorbance = [1.0, 1.05, 1.08, 1.40, 1.75]</p>

<p>for i, absorbance in enumerate(simulated_absorbance):</p>
<p>print(f"--- 測定 {i+1} ---")</p>
<p>print(f"吸光度: {absorbance:.3f}")</p>

<p>monitor.measurements.append(absorbance)</p>
<p>is_anomaly = monitor.check_anomaly(absorbance)</p>

<p>if monitor.should_emergency_stop():</p>
<p>print("\n🚨 連続異常検知！ 緊急停止を実行します。")</p>
<p>safety.emergency_stop_sequence()</p>
<p>break</p>

<p>print()</p>

<h1>測定データのプロット</h1>
<p>plt.figure(figsize=(10, 6))</p>
<p>plt.plot(range(1, len(monitor.measurements) + 1), monitor.measurements, 'o-', linewidth=2, markersize=10)</p>
<p>plt.axhline(y=monitor.measurements[0] * (1 + monitor.threshold), color='red', linestyle='--', label='上限閾値')</p>
<p>plt.axhline(y=monitor.measurements[0] * (1 - monitor.threshold), color='red', linestyle='--', label='下限閾値')</p>
<p>plt.xlabel('測定回数', fontsize=12)</p>
<p>plt.ylabel('吸光度', fontsize=12)</p>
<p>plt.title('反応モニタリングと異常検知', fontsize=14, fontweight='bold')</p>
<p>plt.legend()</p>
<p>plt.grid(alpha=0.3)</p>
<p>plt.tight_layout()</p>
<p>plt.savefig('anomaly_detection.png', dpi=300, bbox_inches='tight')</p>
<p>plt.show()</p>
</code></pre>

</details>

<p>---</p>

<h2>本章のまとめ</h2>

<p>本章では、ロボティクス実験の基礎技術を実践的に学びました。</p>

<h3>キーポイント</h3>

<ol>
<li><strong>ロボットアーム制御</strong>:</li>
</ol>
<p>- 順運動学: 関節角度→位置</p>
<p>- 逆運動学: 目標位置→関節角度（実験で使用）</p>
<p>- 軌道計画: スムーズで安全な経路生成</p>

<ol>
<li><strong>液体ハンドリング（OpenTrons OT-2）</strong>:</li>
</ol>
<p>- 基本ピペッティング: 精度±1 µL</p>
<p>- マルチチャンネル: 8倍高速化</p>
<p>- 段階希釈: 10^-7 Mまでの自動希釈系列</p>

<ol>
<li><strong>固体ハンドリング</strong>:</li>
</ol>
<p>- 粉末計量: ±0.001 gの精度</p>
<p>- 多成分配合: 自動化による再現性向上</p>

<ol>
<li><strong>センサー統合</strong>:</li>
</ol>
<p>- UV-Vis分光計: リアルタイム反応モニタリング</p>
<p>- カメラ: 画像解析による定量評価</p>

<ol>
<li><strong>安全設計</strong>:</li>
</ol>
<p>- 緊急停止: 異常検知時の自動停止</p>
<p>- エラーリカバリー: リトライ機能</p>
<p>- ログ記録: トレーサビリティ確保</p>

<ol>
<li><strong>ラボウェア標準化</strong>:</li>
</ol>
<p>- SBS規格: 96/384ウェルプレートの国際標準</p>
<p>- 互換性: 異なるメーカー間でも使用可能</p>

<h3>次章予告</h3>

<p>第3章では、ベイズ最適化とロボット実験を統合したクローズドループ最適化を学びます。実験→測定→解析→予測→次実験の自動サイクルを実装し、材料探索を劇的に加速します。</p>

<p>---</p>

<h2>参考文献</h2>

<ol>
<li>OpenTrons. "OT-2 Robot Documentation." https://docs.opentrons.com/</li>
<li>Lynch, K. M., & Park, F. C. (2017). <em>Modern Robotics: Mechanics, Planning, and Control</em>. Cambridge University Press.</li>
<li>Granda, J. M. et al. (2018). "Controlling an organic synthesis robot with machine learning to search for new reactivity." <em>Nature</em>, 559, 377-381.</li>
<li>SBS (Society for Laboratory Automation and Screening). "ANSI/SLAS Microplate Standards." https://www.slas.org/education/ansi-slas-microplate-standards/</li>
</ol>

<p>---</p>

<strong>次の章へ</strong>: <a href="chapter-3.html">第3章: クローズドループ最適化</a>

<a href="index.html">目次に戻る</a>


        <div class="navigation">
            <a href="index.html" class="nav-button">← シリーズ目次に戻る</a>
<a href="chapter-2.html" class="nav-button">次章: 第2章 →</a>
        </div>
    </main>

    <footer>
        <p><strong>作成者</strong>: AI Terakoya Content Team</p>
        <p><strong>監修</strong>: Dr. Yusuke Hashimoto（東北大学）</p>
        <p><strong>バージョン</strong>: 1.0 | <strong>作成日</strong>: 2025-10-17</p>
        <p><strong>ライセンス</strong>: Creative Commons BY 4.0</p>
        <p>© 2025 AI Terakoya. All rights reserved.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const mermaidCodeBlocks = document.querySelectorAll('pre.codehilite code.language-mermaid, pre code.language-mermaid');

            mermaidCodeBlocks.forEach(function(codeBlock) {
                const pre = codeBlock.parentElement;
                const mermaidCode = codeBlock.textContent;

                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = mermaidCode.trim();

                pre.parentNode.replaceChild(mermaidDiv, pre);
            });

            if (typeof mermaid !== 'undefined') {
                mermaid.initialize({
                    startOnLoad: true,
                    theme: 'default'
                });
                mermaid.init(undefined, document.querySelectorAll('.mermaid'));
            }
        });
    </script>
</body>
</html>
