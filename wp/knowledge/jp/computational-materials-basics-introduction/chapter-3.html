<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第3章：分子動力学（MD）シミュレーション - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第3章：分子動力学（MD）シミュレーション</h1>
            <p class="subtitle">原子の運動と熱力学特性の計算</p>
            <div class="meta">
                <span class="meta-item">📖 読了時間: 25-30分</span>
                <span class="meta-item">📊 難易度: 中級</span>
                <span class="meta-item">💻 コード例: 7個</span>
            </div>
        </div>
    </header>

    <main class="container">
        
<p><h1>第3章：分子動力学（MD）シミュレーション</h1></p>

<p><h2>学習目標</h2></p>

<p>この章を読むことで、以下を習得できます：</p>
<ul>
<li>MDシミュレーションの基本原理（ニュートン運動方程式、時間積分）を理解する</li>
<li>力場（Force Field）とポテンシャルの概念を理解する</li>
<li>統計アンサンブル（NVE、NVT、NPT）の違いを説明できる</li>
<li>LAMMPSで基本的なMDシミュレーションを実行できる</li>
<li>Ab Initio MD（AIMD）とClassical MDの違いを理解する</li>
</ul>

<p>---</p>

<p><h2>3.1 分子動力学の基本原理</h2></p>

<p><h3>ニュートンの運動方程式</h3></p>

<p>MDシミュレーションの核心は、古典力学の<strong>ニュートンの運動方程式</strong>です：</p>

<p>$$</p>
<p>m_i \frac{d^2 \mathbf{r}_i}{dt^2} = \mathbf{F}_i = -\nabla_i U(\mathbf{r}_1, \mathbf{r}_2, \ldots, \mathbf{r}_N)</p>
<p>$$</p>

<ul>
<li>$m_i$: 原子$i$の質量</li>
<li>$\mathbf{r}_i$: 原子$i$の位置</li>
<li>$\mathbf{F}_i$: 原子$i$に働く力</li>
<li>$U(\mathbf{r}_1, \ldots, \mathbf{r}_N)$: ポテンシャルエネルギー</li>
</ul>

<p><h3>MDシミュレーションの手順</h3></p>

<p><pre><code class="language-mermaid">graph TD</p>
<p>    A[初期配置・速度を設定] --> B[力を計算: F = -∇U]</p>
<p>    B --> C[位置・速度を更新: 時間積分]</p>
<p>    C --> D[物理量を計算: T, P, E, etc.]</p>
<p>    D --> E{時間終了?}</p>
<p>    E -->|No| B</p>
<p>    E -->|Yes| F[データ解析・可視化]</p>

<p>    style A fill:#e3f2fd</p>
<p>    style F fill:#c8e6c9</p>
<p></code></pre></p>

<p><strong>時間ステップ</strong>: 典型的には$\Delta t = 0.5$-$2$ fs（フェムト秒、$10^{-15}$秒）</p>

<p>---</p>

<p><h2>3.2 時間積分アルゴリズム</h2></p>

<p><h3>Verlet法（最も基本的）</h3></p>

<p>位置のTaylor展開：</p>

<p>$$</p>
<p>\mathbf{r}(t + \Delta t) = \mathbf{r}(t) + \mathbf{v}(t)\Delta t + \frac{1}{2}\mathbf{a}(t)\Delta t^2 + O(\Delta t^3)</p>
<p>$$</p>

<p>$$</p>
<p>\mathbf{r}(t - \Delta t) = \mathbf{r}(t) - \mathbf{v}(t)\Delta t + \frac{1}{2}\mathbf{a}(t)\Delta t^2 + O(\Delta t^3)</p>
<p>$$</p>

<p>2式を足すと：</p>

<p>$$</p>
<p>\mathbf{r}(t + \Delta t) = 2\mathbf{r}(t) - \mathbf{r}(t - \Delta t) + \mathbf{a}(t)\Delta t^2</p>
<p>$$</p>

<p><strong>特徴</strong>:</p>
<ul>
<li>✅ シンプル、メモリ効率良い</li>
<li>✅ 時間反転対称性を保つ</li>
<li>❌ 速度が陽に現れない</li>
</ul>

<p><h3>Velocity Verlet法（最もよく使われる）</h3></p>

<p>$$</p>
<p>\mathbf{r}(t + \Delta t) = \mathbf{r}(t) + \mathbf{v}(t)\Delta t + \frac{1}{2}\mathbf{a}(t)\Delta t^2</p>
<p>$$</p>

<p>$$</p>
<p>\mathbf{v}(t + \Delta t) = \mathbf{v}(t) + \frac{1}{2}[\mathbf{a}(t) + \mathbf{a}(t + \Delta t)]\Delta t</p>
<p>$$</p>

<p><strong>特徴</strong>:</p>
<ul>
<li>✅ 位置と速度を同時に更新</li>
<li>✅ エネルギー保存が良い</li>
<li>✅ 最も広く使われる</li>
</ul>

<p><h3>Leap-frog法</h3></p>

<p>$$</p>
<p>\mathbf{v}(t + \frac{\Delta t}{2}) = \mathbf{v}(t - \frac{\Delta t}{2}) + \mathbf{a}(t)\Delta t</p>
<p>$$</p>

<p>$$</p>
<p>\mathbf{r}(t + \Delta t) = \mathbf{r}(t) + \mathbf{v}(t + \frac{\Delta t}{2})\Delta t</p>
<p>$$</p>

<p>位置と速度が半時間ステップずれる「跳び石」のような動き。</p>

<p><h3>Pythonでの実装例</h3></p>

<p><pre><code class="language-python">import numpy as np</p>
<p>import matplotlib.pyplot as plt</p>

<p>def lennard_jones(r, epsilon=1.0, sigma=1.0):</p>
<p>    """Lennard-Jonesポテンシャル"""</p>
<p>    return 4 <em> epsilon </em> ((sigma/r)<strong>12 - (sigma/r)</strong>6)</p>

<p>def lj_force(r, epsilon=1.0, sigma=1.0):</p>
<p>    """Lennard-Jonesポテンシャルの力"""</p>
<p>    return 24 <em> epsilon </em> (2*(sigma/r)<strong>13 - (sigma/r)</strong>7) / r</p>

<p>def velocity_verlet_md(N_steps=1000, dt=0.001):</p>
<p>    """</p>
<p>    Velocity Verlet法による1次元MDシミュレーション</p>
<p>    2つのLennard-Jones粒子</p>
<p>    """</p>
<p>    <h1>初期条件</h1></p>
<p>    r = np.array([0.0, 2.0])  <h1>位置</h1></p>
<p>    v = np.array([0.5, -0.5])  <h1>速度</h1></p>
<p>    m = np.array([1.0, 1.0])  <h1>質量</h1></p>

<p>    <h1>履歴保存用</h1></p>
<p>    r_history = np.zeros((N_steps, 2))</p>
<p>    v_history = np.zeros((N_steps, 2))</p>
<p>    E_history = np.zeros(N_steps)</p>

<p>    for step in range(N_steps):</p>
<p>        <h1>力の計算</h1></p>
<p>        r12 = r[1] - r[0]</p>
<p>        F = lj_force(abs(r12))</p>
<p>        a = np.array([-F/m[0], F/m[1]])  <h1>加速度</h1></p>

<p>        <h1>位置の更新</h1></p>
<p>        r = r + v <em> dt + 0.5 </em> a <em> dt</em>*2</p>

<p>        <h1>新しい力の計算</h1></p>
<p>        r12_new = r[1] - r[0]</p>
<p>        F_new = lj_force(abs(r12_new))</p>
<p>        a_new = np.array([-F_new/m[0], F_new/m[1]])</p>

<p>        <h1>速度の更新</h1></p>
<p>        v = v + 0.5 <em> (a + a_new) </em> dt</p>

<p>        <h1>エネルギー計算</h1></p>
<p>        KE = 0.5 <em> np.sum(m </em> v**2)</p>
<p>        PE = lennard_jones(abs(r12_new))</p>
<p>        E_total = KE + PE</p>

<p>        <h1>保存</h1></p>
<p>        r_history[step] = r</p>
<p>        v_history[step] = v</p>
<p>        E_history[step] = E_total</p>

<p>    return r_history, v_history, E_history</p>

<p><h1>シミュレーション実行</h1></p>
<p>r_hist, v_hist, E_hist = velocity_verlet_md(N_steps=5000, dt=0.001)</p>

<p><h1>プロット</h1></p>
<p>fig, axes = plt.subplots(2, 2, figsize=(12, 10))</p>
<p>time = np.arange(len(r_hist)) * 0.001</p>

<p><h1>位置</h1></p>
<p>axes[0,0].plot(time, r_hist[:, 0], label='Particle 1')</p>
<p>axes[0,0].plot(time, r_hist[:, 1], label='Particle 2')</p>
<p>axes[0,0].set_xlabel('Time')</p>
<p>axes[0,0].set_ylabel('Position')</p>
<p>axes[0,0].set_title('Particle Positions')</p>
<p>axes[0,0].legend()</p>
<p>axes[0,0].grid(alpha=0.3)</p>

<p><h1>速度</h1></p>
<p>axes[0,1].plot(time, v_hist[:, 0], label='Particle 1')</p>
<p>axes[0,1].plot(time, v_hist[:, 1], label='Particle 2')</p>
<p>axes[0,1].set_xlabel('Time')</p>
<p>axes[0,1].set_ylabel('Velocity')</p>
<p>axes[0,1].set_title('Particle Velocities')</p>
<p>axes[0,1].legend()</p>
<p>axes[0,1].grid(alpha=0.3)</p>

<p><h1>エネルギー保存</h1></p>
<p>axes[1,0].plot(time, E_hist)</p>
<p>axes[1,0].set_xlabel('Time')</p>
<p>axes[1,0].set_ylabel('Total Energy')</p>
<p>axes[1,0].set_title('Energy Conservation (NVE)')</p>
<p>axes[1,0].grid(alpha=0.3)</p>

<p><h1>相空間軌道</h1></p>
<p>axes[1,1].plot(r_hist[:, 0] - r_hist[:, 1], v_hist[:, 0], alpha=0.5)</p>
<p>axes[1,1].set_xlabel('Relative Position')</p>
<p>axes[1,1].set_ylabel('Velocity 1')</p>
<p>axes[1,1].set_title('Phase Space Trajectory')</p>
<p>axes[1,1].grid(alpha=0.3)</p>

<p>plt.tight_layout()</p>
<p>plt.savefig('md_verlet.png', dpi=150)</p>
<p>plt.show()</p>

<p>print(f"エネルギー変動: {np.std(E_hist):.6f} (理想的には0に近い)")</p>
<p></code></pre></p>

<p><strong>実行結果</strong>: エネルギー変動 < $10^{-6}$（エネルギー保存則が良好）</p>

<p>---</p>

<p><h2>3.3 力場（Force Field）とポテンシャル</h2></p>

<p><h3>Lennard-Jonesポテンシャル</h3></p>

<p>最も基本的な2体ポテンシャル：</p>

<p>$$</p>
<p>U_{\text{LJ}}(r) = 4\epsilon \left[\left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^6\right]</p>
<p>$$</p>

<ul>
<li>$\epsilon$: ポテンシャルの深さ（結合エネルギー）</li>
<li>$\sigma$: 平衡距離のスケール</li>
<li>$r^{-12}$: 短距離斥力（Pauli斥力）</li>
<li>$r^{-6}$: 長距離引力（van der Waals力）</li>
</ul>

<p><strong>用途</strong>: 希ガス（Ar, Ne）、粗視化モデル</p>

<p><h3>多体ポテンシャル</h3></p>

<p><strong>Embedded Atom Method (EAM)</strong> - 金属向け:</p>

<p>$$</p>
<p>U_{\text{EAM}} = \sum_i F_i(\rho_i) + \frac{1}{2}\sum_{i \neq j} \phi_{ij}(r_{ij})</p>
<p>$$</p>

<ul>
<li>$F_i(\rho_i)$: 埋め込みエネルギー（電子密度$\rho_i$の関数）</li>
<li>$\phi_{ij}(r_{ij})$: 対ポテンシャル</li>
</ul>

<p><strong>Tersoff/Brenner</strong> - 共有結合系（C, Si, Ge）:</p>

<p>$$</p>
<p>U_{\text{Tersoff}} = \sum_i \sum_{j>i} [f_R(r_{ij}) - b_{ij} f_A(r_{ij})]</p>
<p>$$</p>

<p>$b_{ij}$は結合次数（bond order）、周囲の環境に依存。</p>

<p><h3>水の力場</h3></p>

<p><strong>TIP3P</strong>（3点電荷モデル）:</p>
<ul>
<li>O原子に負電荷$-0.834e$</li>
<li>各H原子に正電荷$+0.417e$</li>
<li>Lennard-Jonesポテンシャル（O-O間のみ）</li>
</ul>

<p><strong>特徴</strong>:</p>
<ul>
<li>✅ 計算が高速</li>
<li>✅ 液体水の密度・拡散係数を再現</li>
<li>❌ 氷の構造は不正確</li>
</ul>

<p>---</p>

<p><h2>3.4 統計アンサンブル</h2></p>

<p><h3>NVE（微小正準）アンサンブル</h3></p>

<p><strong>条件</strong>: 粒子数$N$、体積$V$、エネルギー$E$が一定（孤立系）</p>

<p><strong>実装</strong>: 時間積分のみ（熱浴なし）</p>

<p><strong>用途</strong>:</p>
<ul>
<li>エネルギー保存のテスト</li>
<li>理論的基礎研究</li>
</ul>

<p><h3>NVT（正準）アンサンブル</h3></p>

<p><strong>条件</strong>: 粒子数$N$、体積$V$、温度$T$が一定（熱浴と接触）</p>

<p><strong>Nosé-Hoover熱浴</strong>:</p>

<p>$$</p>
<p>\frac{d\mathbf{r}_i}{dt} = \mathbf{v}_i</p>
<p>$$</p>

<p>$$</p>
<p>\frac{d\mathbf{v}_i}{dt} = \frac{\mathbf{F}_i}{m_i} - \zeta \mathbf{v}_i</p>
<p>$$</p>

<p>$$</p>
<p>\frac{d\zeta}{dt} = \frac{1}{Q}\left(\sum_i m_i v_i^2 - 3NkT\right)</p>
<p>$$</p>

<ul>
<li>$\zeta$: 熱浴変数（摩擦係数のような役割）</li>
<li>$Q$: 熱浴の「質量」（緩和時間を制御）</li>
</ul>

<p><strong>用途</strong>:</p>
<ul>
<li>平衡状態の熱力学量計算</li>
<li>相転移の研究</li>
</ul>

<p><h3>NPT（等温等圧）アンサンブル</h3></p>

<p><strong>条件</strong>: 粒子数$N$、圧力$P$、温度$T$が一定（熱浴＋圧力浴）</p>

<p><strong>Parrinello-Rahman法</strong>: セルの形状とサイズが変動</p>

<p><strong>用途</strong>:</p>
<ul>
<li>実験条件との直接比較</li>
<li>格子定数の計算</li>
<li>相転移（固-液など）</li>
</ul>

<p><h3>比較表</h3></p>

<p>| アンサンブル | 保存量 | 変動量 | 用途 |</p>
<p>|-----------|--------|--------|------|</p>
<p>| NVE | $N, V, E$ | $T, P$ | 孤立系、検証 |</p>
<p>| NVT | $N, V, T$ | $E, P$ | 熱平衡状態 |</p>
<p>| NPT | $N, P, T$ | $E, V$ | 実験条件再現 |</p>

<p>---</p>

<p><h2>3.5 LAMMPSによる実践</h2></p>

<p><h3>LAMMPSとは</h3></p>

<p><strong>LAMMPS</strong>（Large-scale Atomic/Molecular Massively Parallel Simulator）:</p>
<ul>
<li>Sandia National Laboratoryが開発</li>
<li>オープンソース、無料</li>
<li>並列計算に最適化（数億原子スケール可能）</li>
</ul>

<p><h3>Example 1: Arガスの平衡化（NVT）</h3></p>

<p><pre><code class="language-bash"><h1>LAMMPS入力ファイル: ar_nvt.in</h1></p>

<p><h1>初期設定</h1></p>
<p>units lj                    <h1>Lennard-Jones単位系</h1></p>
<p>atom_style atomic</p>
<p>dimension 3</p>
<p>boundary p p p              <h1>周期境界条件</h1></p>

<p><h1>系の作成</h1></p>
<p>region box block 0 10 0 10 0 10</p>
<p>create_box 1 box</p>
<p>create_atoms 1 random 100 12345 box</p>

<p><h1>質量設定</h1></p>
<p>mass 1 1.0</p>

<p><h1>ポテンシャル</h1></p>
<p>pair_style lj/cut 2.5</p>
<p>pair_coeff 1 1 1.0 1.0 2.5  <h1>epsilon, sigma, cutoff</h1></p>

<p><h1>初期速度（温度1.0に対応）</h1></p>
<p>velocity all create 1.0 87287 dist gaussian</p>

<p><h1>NVT設定（Nosé-Hoover）</h1></p>
<p>fix 1 all nvt temp 1.0 1.0 0.1</p>

<p><h1>時間ステップ</h1></p>
<p>timestep 0.005</p>

<p><h1>熱力学出力</h1></p>
<p>thermo 100</p>
<p>thermo_style custom step temp press pe ke etotal vol density</p>

<p><h1>トラジェクトリ保存</h1></p>
<p>dump 1 all custom 1000 ar_nvt.lammpstrj id type x y z vx vy vz</p>

<p><h1>実行</h1></p>
<p>run 10000</p>

<p><h1>終了</h1></p>
<p>write_data ar_nvt_final.data</p>
<p></code></pre></p>

<p><strong>実行</strong>:</p>
<p><pre><code class="language-bash">lammps -in ar_nvt.in</p>
<p></code></pre></p>

<p><h3>Example 2: Pythonから LAMMPSを制御</h3></p>

<p><pre><code class="language-python">from lammps import lammps</p>
<p>import numpy as np</p>
<p>import matplotlib.pyplot as plt</p>

<p><h1>LAMMPSインスタンス</h1></p>
<p>lmp = lammps()</p>

<p><h1>入力ファイルを実行</h1></p>
<p>lmp.file('ar_nvt.in')</p>

<p><h1>熱力学データの抽出</h1></p>
<p>temps = lmp.extract_compute("thermo_temp", 0, 0)</p>
<p>press = lmp.extract_compute("thermo_press", 0, 0)</p>

<p>print(f"平衡温度: {temps:.3f} (目標: 1.0)")</p>
<p>print(f"平衡圧力: {press:.3f}")</p>

<p><h1>動径分布関数（RDF）の計算</h1></p>
<p>lmp.command("compute myRDF all rdf 100")</p>
<p>lmp.command("fix 2 all ave/time 100 1 100 c_myRDF[*] file ar_rdf.dat mode vector")</p>
<p>lmp.command("run 5000")</p>

<p><h1>RDFの読み込みとプロット</h1></p>
<p>rdf_data = np.loadtxt('ar_rdf.dat')</p>
<p>r = rdf_data[:, 1]</p>
<p>g_r = rdf_data[:, 2]</p>

<p>plt.figure(figsize=(8, 6))</p>
<p>plt.plot(r, g_r, linewidth=2)</p>
<p>plt.xlabel('r (σ)', fontsize=12)</p>
<p>plt.ylabel('g(r)', fontsize=12)</p>
<p>plt.title('Radial Distribution Function (Ar gas)', fontsize=14)</p>
<p>plt.grid(alpha=0.3)</p>
<p>plt.savefig('ar_rdf.png', dpi=150)</p>
<p>plt.show()</p>

<p>lmp.close()</p>
<p></code></pre></p>

<p>---</p>

<p><h3>Example 3: 水分子のMDシミュレーション（TIP3P）</h3></p>

<p><pre><code class="language-bash"><h1>water_nvt.in</h1></p>

<p>units real                  <h1>実単位系 (Å, fs, kcal/mol)</h1></p>
<p>atom_style full</p>
<p>dimension 3</p>
<p>boundary p p p</p>

<p><h1>データファイル読み込み（水分子216個）</h1></p>
<p>read_data water_box.data</p>

<p><h1>TIP3P水モデル</h1></p>
<p>pair_style lj/cut/coul/long 10.0</p>
<p>pair_coeff 1 1 0.102 3.188   <h1>O-O</h1></p>
<p>pair_coeff * 2 0.0 0.0       <h1>H原子はLJなし</h1></p>
<p>kspace_style pppm 1e-4       <h1>長距離クーロン（Ewald和）</h1></p>

<p><h1>結合・角度</h1></p>
<p>bond_style harmonic</p>
<p>bond_coeff 1 450.0 0.9572    <h1>O-H結合</h1></p>
<p>angle_style harmonic</p>
<p>angle_coeff 1 55.0 104.52    <h1>H-O-H角度</h1></p>

<p><h1>SHAKE制約（O-H結合を固定）</h1></p>
<p>fix shake all shake 0.0001 20 0 b 1 a 1</p>

<p><h1>NVT（300K）</h1></p>
<p>fix 1 all nvt temp 300.0 300.0 100.0</p>

<p><h1>時間ステップ</h1></p>
<p>timestep 1.0  <h1>1 fs</h1></p>

<p><h1>出力</h1></p>
<p>thermo 100</p>
<p>dump 1 all custom 1000 water.lammpstrj id mol type x y z</p>

<p><h1>実行（100 ps）</h1></p>
<p>run 100000</p>
<p></code></pre></p>

<p><strong>拡散係数の計算</strong>:</p>
<p><pre><code class="language-python">import numpy as np</p>
<p>from MDAnalysis import Universe</p>
<p>import matplotlib.pyplot as plt</p>

<p><h1>トラジェクトリ読み込み</h1></p>
<p>u = Universe('water_box.data', 'water.lammpstrj', format='LAMMPSDUMP')</p>

<p><h1>酸素原子のみ選択</h1></p>
<p>oxygens = u.select_atoms('type 1')</p>

<p><h1>平均二乗変位（MSD）の計算</h1></p>
<p>n_frames = len(u.trajectory)</p>
<p>msd = np.zeros(n_frames)</p>

<p>for i, ts in enumerate(u.trajectory):</p>
<p>    if i == 0:</p>
<p>        r0 = oxygens.positions.copy()</p>
<p>    dr = oxygens.positions - r0</p>
<p>    msd[i] = np.mean(np.sum(dr**2, axis=1))</p>

<p><h1>時間軸（fs）</h1></p>
<p>time = np.arange(n_frames) * 1.0</p>

<p><h1>プロット</h1></p>
<p>plt.figure(figsize=(8, 6))</p>
<p>plt.plot(time/1000, msd, linewidth=2)</p>
<p>plt.xlabel('Time (ps)', fontsize=12)</p>
<p>plt.ylabel('MSD (Å²)', fontsize=12)</p>
<p>plt.title('Mean Square Displacement (H₂O)', fontsize=14)</p>
<p>plt.grid(alpha=0.3)</p>
<p>plt.savefig('water_msd.png', dpi=150)</p>
<p>plt.show()</p>

<p><h1>拡散係数の計算（Einstein関係式）</h1></p>
<p><h1>MSD = 6Dt → D = slope / 6</h1></p>
<p>slope = np.polyfit(time[len(time)//2:], msd[len(time)//2:], 1)[0]</p>
<p>D = slope / 6 / 1000  <h1>Å²/ps → 10⁻⁵ cm²/s</h1></p>
<p>print(f"拡散係数: {D:.2f} × 10⁻⁵ cm²/s")</p>
<p>print(f"実験値: 2.30 × 10⁻⁵ cm²/s (300K)")</p>
<p></code></pre></p>

<p>---</p>

<p><h2>3.6 Ab Initio MD（AIMD）</h2></p>

<p><h3>Classical MD vs Ab Initio MD</h3></p>

<p>| 項目 | Classical MD | Ab Initio MD |</p>
<p>|------|-------------|--------------|</p>
<p>| <strong>力の計算</strong> | 経験的ポテンシャル（力場） | DFT計算（第一原理） |</p>
<p>| <strong>精度</strong> | 力場に依存 | 量子力学的に正確 |</p>
<p>| <strong>計算コスト</strong> | 低い（$\sim$1 ns/day） | 極めて高い（$\sim$10 ps/day） |</p>
<p>| <strong>系のサイズ</strong> | 数百万原子 | 数百原子 |</p>
<p>| <strong>用途</strong> | 大規模系、長時間 | 化学反応、電子状態 |</p>

<p><h3>Born-Oppenheimer MD（BOMD）</h3></p>

<p>各時間ステップでDFT計算を実行：</p>

<p><pre><code class="language-">1. 原子配置 R(t) を与える</p>
<ol>
<li>DFT計算で基底状態エネルギー E(R(t)) を計算</li>
<li>力 F = -∇E を計算</li>
<li>ニュートン方程式で R(t+Δt) を計算</li>
<li>1に戻る</li>
</ol>
<p></code></pre></p>

<p><h3>GPAWによるAIMD実装例</h3></p>

<p><pre><code class="language-python">from ase import Atoms</p>
<p>from ase.md.velocitydistribution import MaxwellBoltzmannDistribution</p>
<p>from ase.md.verlet import VelocityVerlet</p>
<p>from ase import units</p>
<p>from gpaw import GPAW, PW</p>

<p><h1>水分子の作成</h1></p>
<p>h2o = Atoms('H2O',</p>
<p>            positions=[[0.00, 0.00, 0.00],</p>
<p>                       [0.96, 0.00, 0.00],</p>
<p>                       [0.24, 0.93, 0.00]])</p>
<p>h2o.center(vacuum=5.0)</p>

<p><h1>DFT計算機（力場の代わり）</h1></p>
<p>calc = GPAW(mode=PW(400),</p>
<p>            xc='PBE',</p>
<p>            txt='h2o_aimd.txt')</p>

<p>h2o.calc = calc</p>

<p><h1>初期速度（300K）</h1></p>
<p>MaxwellBoltzmannDistribution(h2o, temperature_K=300)</p>

<p><h1>Velocity Verlet MD</h1></p>
<p>dyn = VelocityVerlet(h2o, timestep=1.0*units.fs,</p>
<p>                     trajectory='h2o_aimd.traj')</p>

<p><h1>10 ps実行（実際には非常に時間がかかる）</h1></p>
<p>def print_energy(a=h2o):</p>
<p>    epot = a.get_potential_energy()</p>
<p>    ekin = a.get_kinetic_energy()</p>
<p>    print(f"Time: {dyn.get_time()/units.fs:.1f} fs, "</p>
<p>          f"Epot: {epot:.3f} eV, "</p>
<p>          f"Ekin: {ekin:.3f} eV, "</p>
<p>          f"Etot: {epot+ekin:.3f} eV")</p>

<p>dyn.attach(print_energy, interval=10)</p>
<p>dyn.run(100)  <h1>100ステップ = 100 fs</h1></p>
<p></code></pre></p>

<p><strong>用途</strong>:</p>
<ul>
<li>化学反応の研究</li>
<li>相転移のメカニズム</li>
<li>力場が存在しない新規材料</li>
</ul>

<p>---</p>

<p><h2>3.7 本章のまとめ</h2></p>

<p><h3>学んだこと</h3></p>

<ol>
<li><strong>MDの基本原理</strong></li>
</ol>
<p>   - ニュートン運動方程式</p>
<p>   - 時間積分アルゴリズム（Verlet、Velocity Verlet、Leap-frog）</p>
<p>   - エネルギー保存則</p>

<ol>
<li><strong>力場とポテンシャル</strong></li>
</ol>
<p>   - Lennard-Jones（希ガス）</p>
<p>   - EAM（金属）</p>
<p>   - Tersoff/Brenner（共有結合系）</p>
<p>   - TIP3P（水）</p>

<ol>
<li><strong>統計アンサンブル</strong></li>
</ol>
<p>   - NVE（微小正準）</p>
<p>   - NVT（正準、Nosé-Hoover熱浴）</p>
<p>   - NPT（等温等圧、Parrinello-Rahman）</p>

<ol>
<li><strong>LAMMPSによる実践</strong></li>
</ol>
<p>   - 入力ファイルの作成</p>
<p>   - 平衡化シミュレーション</p>
<p>   - 動径分布関数、拡散係数</p>

<ol>
<li><strong>Ab Initio MD</strong></li>
</ol>
<p>   - Classical MDとの違い</p>
<p>   - Born-Oppenheimer MD</p>
<p>   - GPAWでの実装</p>

<p><h3>重要なポイント</h3></p>

<ul>
<li>MDは古典力学に基づく</li>
<li>時間ステップは約1 fs</li>
<li>統計アンサンブルで実験条件を再現</li>
<li>力場の選択が精度を決める</li>
<li>AIMDは精度が高いが計算コスト大</li>
</ul>

<p><h3>次の章へ</h3></p>

<p>第4章では、格子振動（フォノン）と熱力学特性の計算を学びます。</p>

<p>---</p>

<p><h2>演習問題</h2></p>

<p><h3>問題1（難易度：easy）</h3></p>

<p>Velocity Verlet法とLeap-frog法の違いを説明してください。</p>

<p><details></p>
<p><summary>解答例</summary></p>

<p><strong>Velocity Verlet法</strong>:</p>
<ul>
<li>位置$\mathbf{r}$と速度$\mathbf{v}$を同じ時刻$t$で更新</li>
<li>速度は現在と次時刻の加速度の平均を使用</li>
<li>熱力学量（温度、運動エネルギー）が直接計算可能</li>
</ul>

<p><strong>Leap-frog法</strong>:</p>
<ul>
<li>位置$\mathbf{r}(t)$と速度$\mathbf{v}(t+\Delta t/2)$が半時間ステップずれる</li>
<li>「跳び石」のように交互に更新</li>
<li>熱力学量を計算するには速度の補間が必要</li>
</ul>

<p><strong>どちらも</strong>:</p>
<ul>
<li>エネルギー保存性は同等</li>
<li>2次精度（$O(\Delta t^2)$）</li>
<li>時間反転対称性を持つ</li>
</ul>

<p></details></p>

<p><h3>問題2（難易度：medium）</h3></p>

<p>NVTアンサンブルとNPTアンサンブルをいつ使うべきか、具体例とともに説明してください。</p>

<p><details></p>
<p><summary>解答例</summary></p>

<p><strong>NVTアンサンブル（N, V, T一定）</strong>:</p>

<p><strong>使用場面</strong>:</p>
<ul>
<li>固体の熱力学特性（比熱、熱膨張係数）</li>
<li>液体の構造因子、動径分布関数</li>
<li>表面・界面のシミュレーション（体積固定）</li>
<li>特定の密度での挙動を調べたい場合</li>
</ul>

<p><strong>具体例</strong>:</p>
<ul>
<li>Si結晶の300Kでの原子振動</li>
<li>水溶液中のタンパク質の構造揺らぎ</li>
<li>リチウムイオン電池電解液の輸送特性</li>
</ul>

<p><strong>NPTアンサンブル（N, P, T一定）</strong>:</p>

<p><strong>使用場面</strong>:</p>
<ul>
<li>実験条件（1気圧、室温など）との直接比較</li>
<li>相転移（固-液、液-気）</li>
<li>格子定数の計算</li>
<li>密度の温度・圧力依存性</li>
</ul>

<p><strong>具体例</strong>:</p>
<ul>
<li>1気圧、300Kでの液体水の密度計算</li>
<li>高圧下での材料の構造変化</li>
<li>熱膨張係数の計算</li>
<li>氷の融解シミュレーション</li>
</ul>

<p><strong>判断基準</strong>:</p>
<ul>
<li>実験が定圧条件 → NPT</li>
<li>理論研究で密度固定 → NVT</li>
<li>相転移の研究 → NPT（体積変化を観測）</li>
</ul>

<p></details></p>

<p><h3>問題3（難易度：hard）</h3></p>

<p>Classical MDとAb Initio MDの計算コストの違いを、100原子系で見積もってください。各MDステップでDFT計算にかかる時間が1秒とします。</p>

<p><details></p>
<p><summary>解答例</summary></p>

<p><strong>前提条件</strong>:</p>
<ul>
<li>系: 100原子</li>
<li>時間ステップ: $\Delta t = 1$ fs</li>
<li>DFT計算: 1ステップあたり1秒</li>
</ul>

<p><strong>Classical MD</strong>:</p>

<p>力の計算: 力場（解析式）</p>
<ul>
<li>Lennard-Jonesの場合: $O(N^2)$ または $O(N)$（カットオフ使用）</li>
<li>1ステップの計算時間: $\sim 10^{-3}$ 秒（100原子程度）</li>
</ul>

<p><strong>シミュレーション時間</strong>:</p>
<ul>
<li>1 ns（ナノ秒）= $10^6$ fs = $10^6$ステップ</li>
<li>総計算時間: $10^6 \times 10^{-3}$ 秒 = 1000秒 ≈ <strong>17分</strong></li>
</ul>

<p><strong>Ab Initio MD (AIMD)</strong>:</p>

<p>力の計算: DFT（SCF計算）</p>
<ul>
<li>1ステップの計算時間: 1秒（前提）</li>
</ul>

<p><strong>シミュレーション時間</strong>:</p>
<ul>
<li>10 ps（ピコ秒）= $10^4$ fs = $10^4$ステップ</li>
<li>総計算時間: $10^4 \times 1$ 秒 = 10000秒 ≈ <strong>2.8時間</strong></li>
</ul>

<p><strong>比較</strong>:</p>

<p>| 項目 | Classical MD | AIMD |</p>
<p>|------|-------------|------|</p>
<p>| 1ステップ計算時間 | 0.001秒 | 1秒 |</p>
<p>| 到達可能時間 | 1 ns (17分) | 10 ps (2.8時間) |</p>
<p>| <strong>時間スケール比</strong> | <strong>100倍長い</strong> | - |</p>
<p>| <strong>計算コスト比</strong> | 1 | <strong>1000倍</strong> |</p>

<p><strong>結論</strong>:</p>
<ul>
<li>AIMDは1ステップあたり約1000倍遅い</li>
<li>同じ計算時間で、Classical MDは100倍長い時間をシミュレート可能</li>
<li>AIMDは化学反応（ps-nsスケール）には適用可能</li>
<li>拡散過程（nsスケール以上）にはClassical MDが必須</li>
</ul>

<p><strong>実用的戦略</strong>:</p>
<ol>
<li>AIMDで短時間シミュレーション（10-100 ps）</li>
<li>AIMDの結果から力場（Machine Learning Potential）を訓練</li>
<li>MLPを使ったClassical MDで長時間シミュレーション（ns-μs）</li>
</ol>

<p>→ 第5章でMLPについて詳しく学びます！</p>

<p></details></p>

<p>---</p>

<p><h2>参考文献</h2></p>

<ol>
<li>Frenkel, D., & Smit, B. (2001). <em>Understanding Molecular Simulation: From Algorithms to Applications</em> (2nd ed.). Academic Press.</li>
</ol>

<ol>
<li>Haile, J. M. (1992). <em>Molecular Dynamics Simulation: Elementary Methods</em>. Wiley-Interscience.</li>
</ol>

<ol>
<li>Plimpton, S. (1995). "Fast Parallel Algorithms for Short-Range Molecular Dynamics." <em>Journal of Computational Physics</em>, 117(1), 1-19.</li>
</ol>
<p>   DOI: <a href="https://doi.org/10.1006/jcph.1995.1039">10.1006/jcph.1995.1039</a></p>

<ol>
<li>LAMMPS Documentation: https://docs.lammps.org/</li>
<li>ASE-MD Documentation: https://wiki.fysik.dtu.dk/ase/ase/md.html</li>
</ol>

<p>---</p>

<p><h2>著者情報</h2></p>

<p><strong>作成者</strong>: MI Knowledge Hub Content Team</p>
<p><strong>監修</strong>: Dr. Yusuke Hashimoto（東北大学）</p>
<p><strong>作成日</strong>: 2025-10-17</p>
<p><strong>バージョン</strong>: 1.0</p>
<p><strong>シリーズ</strong>: 計算材料科学基礎入門 v1.0</p>

<p><strong>ライセンス</strong>: Creative Commons BY-NC-SA 4.0</p>


        
        <div class="navigation">
            <a href="chapter-4.html" class="nav-button">次章: 第4章 →</a>
            <a href="index.html" class="nav-button">← シリーズ目次に戻る</a>
            <a href="chapter-2.html" class="nav-button">← 前章: 第2章</a>
        </div>
    
    </main>

    <footer>
        <p><strong>作成者</strong>: AI Terakoya Content Team</p>
        <p><strong>監修</strong>: Dr. Yusuke Hashimoto(東北大学)</p>
        <p><strong>バージョン</strong>: 1.0 | <strong>作成日</strong>: 2025-10-17</p>
        <p><strong>ライセンス</strong>: Creative Commons BY 4.0</p>
        <p>© 2025 AI Terakoya. All rights reserved.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const mermaidCodeBlocks = document.querySelectorAll('pre.codehilite code.language-mermaid, pre code.language-mermaid');

            mermaidCodeBlocks.forEach(function(codeBlock) {
                const pre = codeBlock.parentElement;
                const mermaidCode = codeBlock.textContent;

                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = mermaidCode.trim();

                pre.parentNode.replaceChild(mermaidDiv, pre);
            });

            if (typeof mermaid !== 'undefined') {
                mermaid.initialize({
                    startOnLoad: true,
                    theme: 'default'
                });
                mermaid.init(undefined, document.querySelectorAll('.mermaid'));
            }
        });
    </script>
</body>
</html>