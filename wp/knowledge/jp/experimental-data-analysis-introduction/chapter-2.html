<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬2ç« ï¼šã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿è§£æ - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>ç¬¬2ç« ï¼šã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿è§£æ</h1>
            <p class="subtitle">XRDãƒ»XPSãƒ»IRãƒ»Ramanã®è‡ªå‹•è§£æ - æ§‹é€ ãƒ»çµ„æˆæƒ…å ±ã®æŠ½å‡º</p>
            <div class="meta">
                <span class="meta-item">ğŸ“– èª­äº†æ™‚é–“: 25-30åˆ†</span>
                <span class="meta-item">ğŸ“Š é›£æ˜“åº¦: ä¸­ç´š</span>
                <span class="meta-item">ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹: 11å€‹</span>
                <span class="meta-item">ğŸ“ æ¼”ç¿’å•é¡Œ: 3å•</span>
            </div>
        </div>
    </header>

    <main class="container">

<h1>ç¬¬2ç« ï¼šã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿è§£æ</h1>

<strong>XRDãƒ»XPSãƒ»IRãƒ»Ramanã®è‡ªå‹•è§£æ - æ§‹é€ ãƒ»çµ„æˆæƒ…å ±ã®æŠ½å‡º</strong>

<h2>å­¦ç¿’ç›®æ¨™</h2>

ã“ã®ç« ã‚’èª­ã‚€ã“ã¨ã§ã€ä»¥ä¸‹ã‚’ç¿’å¾—ã§ãã¾ã™ï¼š

- âœ… XRDãƒ»XPSãƒ»IRãƒ»Ramanã‚¹ãƒšã‚¯ãƒˆãƒ«ã®ç‰¹å¾´ã‚’ç†è§£ã—ã€é©åˆ‡ãªå‰å‡¦ç†ã‚’é¸æŠã§ãã‚‹
- âœ… ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã—ã€ãƒ”ãƒ¼ã‚¯ä½ç½®ãƒ»å¼·åº¦ã‚’å®šé‡ã§ãã‚‹
- âœ… ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»æ‰‹æ³•ï¼ˆå¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã€SNIPï¼‰ã‚’ä½¿ã„åˆ†ã‘ã‚‰ã‚Œã‚‹
- âœ… XRDãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰å®šé‡ç›¸åˆ†æï¼ˆRIRæ³•ï¼‰ã‚’å®Ÿè¡Œã§ãã‚‹
- âœ… ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’è‡ªå‹•åŒ–ã§ãã‚‹

<strong>èª­äº†æ™‚é–“</strong>: 25-30åˆ†
<strong>ã‚³ãƒ¼ãƒ‰ä¾‹</strong>: 11å€‹
<strong>æ¼”ç¿’å•é¡Œ</strong>: 3å•

---

<h2>2.1 ã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ã®ç‰¹å¾´ã¨å‰å‡¦ç†æˆ¦ç•¥</h2>

<h3>å„æ¸¬å®šæŠ€è¡“ã®ç‰¹å¾´</h3>

ææ–™ç§‘å­¦ã§é »ç¹ã«ä½¿ç”¨ã•ã‚Œã‚‹4ã¤ã®ã‚¹ãƒšã‚¯ãƒˆãƒ«æ¸¬å®šæŠ€è¡“ã®ç‰¹å¾´ã‚’ç†è§£ã™ã‚‹ã“ã¨ã¯ã€é©åˆ‡ãªè§£ææ‰‹æ³•ã‚’é¸æŠã™ã‚‹ä¸Šã§é‡è¦ã§ã™ã€‚

| æ¸¬å®šæŠ€è¡“ | å¾—ã‚‰ã‚Œã‚‹æƒ…å ± | ãƒ”ãƒ¼ã‚¯ã®ç‰¹å¾´ | å…¸å‹çš„ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ |
|---------|------------|------------|----------------------|
| <strong>XRD</strong> | çµæ™¶æ§‹é€ ã€ç›¸åŒå®š | ã‚·ãƒ£ãƒ¼ãƒ—ï¼ˆå›æŠ˜ãƒ”ãƒ¼ã‚¯ï¼‰ | ä½å¼·åº¦ã€ç·©ã‚„ã‹ãªä¸Šæ˜‡ï¼ˆéæ™¶è³ªï¼‰ |
| <strong>XPS</strong> | å…ƒç´ çµ„æˆã€åŒ–å­¦çŠ¶æ…‹ | éå¯¾ç§°ï¼ˆã‚¹ãƒ”ãƒ³è»Œé“åˆ†è£‚ï¼‰ | ã‚·ãƒ£ãƒ¼ãƒªãƒ¼å‹ï¼ˆéå¼¾æ€§æ•£ä¹±ï¼‰ |
| <strong>IR</strong> | åˆ†å­æŒ¯å‹•ã€å®˜èƒ½åŸº | ã‚·ãƒ£ãƒ¼ãƒ—ã€œãƒ–ãƒ­ãƒ¼ãƒ‰ | ã»ã¼ãƒ•ãƒ©ãƒƒãƒˆï¼ˆé€éæ³•ï¼‰ |
| <strong>Raman</strong> | çµæ™¶æ€§ã€åˆ†å­æŒ¯å‹• | ã‚·ãƒ£ãƒ¼ãƒ—ï¼ˆçµæ™¶æ€§é«˜ï¼‰ | è›å…‰ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ï¼ˆæœ‰æ©Ÿç‰©ï¼‰ |

<h3>ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æã®å…¸å‹çš„ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</h3>

<div class="mermaid">flowchart TD
    A[ã‚¹ãƒšã‚¯ãƒˆãƒ«æ¸¬å®š] --> B[ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿]
    B --> C[ãƒã‚¤ã‚ºé™¤å»]
    C --> D[ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»]
    D --> E[ãƒ”ãƒ¼ã‚¯æ¤œå‡º]
    E --> F[ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°]
    F --> G[å®šé‡è§£æ]
    G --> H[çµæœå¯è¦–åŒ–]

    style A fill:#e3f2fd
    style D fill:#fff3e0
    style E fill:#f3e5f5
    style G fill:#e8f5e9
    style H fill:#fce4ec</div>

<strong>å„ã‚¹ãƒ†ãƒƒãƒ—ã®ç›®çš„</strong>:
1. <strong>ãƒã‚¤ã‚ºé™¤å»</strong>: S/Næ¯”å‘ä¸Šï¼ˆç¬¬1ç« ã§å­¦ç¿’æ¸ˆã¿ï¼‰
2. <strong>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»</strong>: ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³è£œæ­£
3. <strong>ãƒ”ãƒ¼ã‚¯æ¤œå‡º</strong>: ãƒ”ãƒ¼ã‚¯ä½ç½®ã®è‡ªå‹•åŒå®š
4. <strong>ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°</strong>: ãƒ”ãƒ¼ã‚¯å½¢çŠ¶ã®ãƒ¢ãƒ‡ãƒ«åŒ–
5. <strong>å®šé‡è§£æ</strong>: çµ„æˆãƒ»ç›¸åˆ†ç‡ã®ç®—å‡º

---

<h2>2.2 ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»æ‰‹æ³•</h2>

<h3>å¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°æ³•</h3>

æœ€ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ãªæ‰‹æ³•ã§ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’å¤šé …å¼ã§è¿‘ä¼¼ã—ã€å…ƒãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ¸›ç®—ã—ã¾ã™ã€‚

<strong>ã‚³ãƒ¼ãƒ‰ä¾‹1: å¤šé …å¼ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»</strong>

<pre><code class="language-python"><h1>XRDãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»</h1>
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter

<h1>ã‚µãƒ³ãƒ—ãƒ«XRDãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ</h1>
np.random.seed(42)
two_theta = np.linspace(10, 80, 700)

<h1>ãƒ”ãƒ¼ã‚¯æˆåˆ†</h1>
peaks = (
    1000 * np.exp(-((two_theta - 28) ** 2) / 10) +
    1500 * np.exp(-((two_theta - 32) ** 2) / 8) +
    800 * np.exp(-((two_theta - 47) ** 2) / 12)
)

<h1>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ï¼ˆéæ™¶è³ªãƒãƒ­ãƒ¼ï¼‰</h1>
background = (
    100 +
    50 * np.sin(two_theta / 10) +
    30 * (two_theta / 80) ** 2
)

<h1>ãƒã‚¤ã‚º</h1>
noise = np.random.normal(0, 20, len(two_theta))

<h1>å…¨ä½“ã®ä¿¡å·</h1>
intensity = peaks + background + noise

<h1>å¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã«ã‚ˆã‚‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¨å®š</h1>
poly_degree = 5
coeffs = np.polyfit(two_theta, intensity, poly_degree)
background_fit = np.polyval(coeffs, two_theta)

<h1>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¸›ç®—</h1>
intensity_corrected = intensity - background_fit

<h1>å¯è¦–åŒ–</h1>
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

<h1>å…ƒãƒ‡ãƒ¼ã‚¿</h1>
axes[0, 0].plot(two_theta, intensity, linewidth=1)
axes[0, 0].set_xlabel('2Î¸ (degree)')
axes[0, 0].set_ylabel('Intensity')
axes[0, 0].set_title('Raw XRD Pattern')
axes[0, 0].grid(True, alpha=0.3)

<h1>ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°çµæœ</h1>
axes[0, 1].plot(two_theta, intensity, label='Raw data', alpha=0.5)
axes[0, 1].plot(two_theta, background_fit,
                label=f'Polynomial fit (deg={poly_degree})',
                linewidth=2, color='red')
axes[0, 1].set_xlabel('2Î¸ (degree)')
axes[0, 1].set_ylabel('Intensity')
axes[0, 1].set_title('Background Estimation')
axes[0, 1].legend()
axes[0, 1].grid(True, alpha=0.3)

<h1>è£œæ­£å¾Œ</h1>
axes[1, 0].plot(two_theta, intensity_corrected, linewidth=1,
                color='green')
axes[1, 0].axhline(y=0, color='r', linestyle='--', alpha=0.5)
axes[1, 0].set_xlabel('2Î¸ (degree)')
axes[1, 0].set_ylabel('Intensity')
axes[1, 0].set_title('After Background Subtraction')
axes[1, 0].grid(True, alpha=0.3)

<h1>çœŸã®ãƒ”ãƒ¼ã‚¯ã¨ã®æ¯”è¼ƒ</h1>
axes[1, 1].plot(two_theta, peaks, label='True peaks',
                linewidth=2, alpha=0.7)
axes[1, 1].plot(two_theta, intensity_corrected,
                label='Corrected data', linewidth=1.5, alpha=0.7)
axes[1, 1].set_xlabel('2Î¸ (degree)')
axes[1, 1].set_ylabel('Intensity')
axes[1, 1].set_title('Comparison with True Peaks')
axes[1, 1].legend()
axes[1, 1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f"å¤šé …å¼æ¬¡æ•°: {poly_degree}")
print(f"ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¹³å‡å€¤: {background_fit.mean():.1f}")
print(f"è£œæ­£å¾Œã®å¹³å‡å€¤: {intensity_corrected.mean():.1f}")</code></pre>

<strong>å‡ºåŠ›</strong>:
<pre><code>å¤šé …å¼æ¬¡æ•°: 5
ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¹³å‡å€¤: 150.3
è£œæ­£å¾Œã®å¹³å‡å€¤: 0.5</code></pre>

<strong>ä½¿ã„åˆ†ã‘ã‚¬ã‚¤ãƒ‰</strong>:
- <strong>ä½æ¬¡ï¼ˆ2-3æ¬¡ï¼‰</strong>: ç·©ã‚„ã‹ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ï¼ˆIRã€XPSï¼‰
- <strong>ä¸­æ¬¡ï¼ˆ4-6æ¬¡ï¼‰</strong>: ã‚„ã‚„è¤‡é›‘ãªå½¢çŠ¶ï¼ˆXRDéæ™¶è³ªãƒãƒ­ãƒ¼ï¼‰
- <strong>é«˜æ¬¡ï¼ˆ>7æ¬¡ï¼‰</strong>: è¤‡é›‘ãªå½¢çŠ¶ï¼ˆæ³¨æ„ï¼šã‚ªãƒ¼ãƒãƒ¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã®ãƒªã‚¹ã‚¯ï¼‰

<h3>SNIPæ³•ï¼ˆStatistics-sensitive Non-linear Iterative Peak-clippingï¼‰</h3>

ãƒ”ãƒ¼ã‚¯æƒ…å ±ã‚’ä¿æŒã—ãªãŒã‚‰ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’æ¨å®šã™ã‚‹é«˜åº¦ãªæ‰‹æ³•ã§ã™ã€‚

<strong>ã‚³ãƒ¼ãƒ‰ä¾‹2: SNIPæ³•ã«ã‚ˆã‚‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»</strong>

<pre><code class="language-python">def snip_background(spectrum, iterations=30):
    """
    SNIPæ³•ã«ã‚ˆã‚‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¨å®š

    Parameters:
    -----------
    spectrum : array-like
        å…¥åŠ›ã‚¹ãƒšã‚¯ãƒˆãƒ«
    iterations : int
        ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•°ï¼ˆãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®å¹…ã«å¯¾å¿œï¼‰

    Returns:
    --------
    background : array-like
        æ¨å®šã•ã‚ŒãŸãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰
    """
    spectrum = np.array(spectrum, dtype=float)
    background = np.copy(spectrum)

    for i in range(1, iterations + 1):
        # å·¦å³ã®å€¤ã¨ã®æ¯”è¼ƒ
        for j in range(i, len(background) - i):
            v1 = (background[j - i] + background[j + i]) / 2
            v2 = background[j]
            background[j] = min(v1, v2)

    return background

<h1>SNIPæ³•ã®é©ç”¨</h1>
snip_bg = snip_background(intensity, iterations=50)
intensity_snip = intensity - snip_bg

<h1>å¯è¦–åŒ–</h1>
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

<h1>å…ƒãƒ‡ãƒ¼ã‚¿ã¨SNIPãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰</h1>
axes[0].plot(two_theta, intensity, label='Raw data', alpha=0.6)
axes[0].plot(two_theta, snip_bg, label='SNIP background',
             linewidth=2, color='orange')
axes[0].set_xlabel('2Î¸ (degree)')
axes[0].set_ylabel('Intensity')
axes[0].set_title('SNIP Background Estimation')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

<h1>SNIPè£œæ­£å¾Œ</h1>
axes[1].plot(two_theta, intensity_snip, linewidth=1.5,
             color='purple')
axes[1].axhline(y=0, color='r', linestyle='--', alpha=0.5)
axes[1].set_xlabel('2Î¸ (degree)')
axes[1].set_ylabel('Intensity')
axes[1].set_title('After SNIP Subtraction')
axes[1].grid(True, alpha=0.3)

<h1>å¤šé …å¼ vs SNIP æ¯”è¼ƒ</h1>
axes[2].plot(two_theta, intensity_corrected,
             label='Polynomial', alpha=0.7, linewidth=1.5)
axes[2].plot(two_theta, intensity_snip,
             label='SNIP', alpha=0.7, linewidth=1.5)
axes[2].set_xlabel('2Î¸ (degree)')
axes[2].set_ylabel('Intensity')
axes[2].set_title('Polynomial vs SNIP')
axes[2].legend()
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f"SNIP ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•°: 50")
print(f"å¤šé …å¼æ³•ã®æ®‹å·®: {np.std(intensity_corrected - peaks):.2f}")
print(f"SNIPæ³•ã®æ®‹å·®: {np.std(intensity_snip - peaks):.2f}")</code></pre>

<strong>SNIPæ³•ã®åˆ©ç‚¹</strong>:
- ãƒ”ãƒ¼ã‚¯ã®å½±éŸ¿ã‚’å—ã‘ã«ãã„
- è¤‡é›‘ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å½¢çŠ¶ã«ã‚‚å¯¾å¿œ
- ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´ãŒç›´æ„Ÿçš„ï¼ˆiterations = ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®å¹…ï¼‰

---

<h2>2.3 ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </h2>

<h3>scipy.signal.find_peaks ã«ã‚ˆã‚‹åŸºæœ¬çš„ãªãƒ”ãƒ¼ã‚¯æ¤œå‡º</h3>

<strong>ã‚³ãƒ¼ãƒ‰ä¾‹3: ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã®åŸºæœ¬</strong>

<pre><code class="language-python">from scipy.signal import find_peaks

<h1>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã§ãƒ”ãƒ¼ã‚¯æ¤œå‡º</h1>
peaks_idx, properties = find_peaks(
    intensity_snip,
    height=100,        # æœ€ä½ãƒ”ãƒ¼ã‚¯é«˜ã•
    prominence=80,     # å“è¶Šåº¦ï¼ˆå‘¨å›²ã¨ã®é«˜ä½å·®ï¼‰
    distance=10,       # æœ€å°ãƒ”ãƒ¼ã‚¯é–“éš”ï¼ˆãƒ‡ãƒ¼ã‚¿ç‚¹æ•°ï¼‰
    width=3           # æœ€å°ãƒ”ãƒ¼ã‚¯å¹…
)

peak_positions = two_theta[peaks_idx]
peak_heights = intensity_snip[peaks_idx]

<h1>å¯è¦–åŒ–</h1>
plt.figure(figsize=(14, 6))

plt.plot(two_theta, intensity_snip, linewidth=1.5,
         label='Background-corrected')
plt.plot(peak_positions, peak_heights, 'rx',
         markersize=12, markeredgewidth=2, label='Detected peaks')

<h1>ãƒ”ãƒ¼ã‚¯ä½ç½®ã«ãƒ©ãƒ™ãƒ«</h1>
for pos, height in zip(peak_positions, peak_heights):
    plt.annotate(f'{pos:.1f}Â°',
                xy=(pos, height),
                xytext=(pos, height + 100),
                ha='center',
                fontsize=9,
                bbox=dict(boxstyle='round,pad=0.3',
                         facecolor='yellow', alpha=0.5))

plt.xlabel('2Î¸ (degree)')
plt.ylabel('Intensity')
plt.title('Peak Detection Results')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

print("=== æ¤œå‡ºã•ã‚ŒãŸãƒ”ãƒ¼ã‚¯ ===")
for i, (pos, height) in enumerate(zip(peak_positions,
                                       peak_heights), 1):
    print(f"ãƒ”ãƒ¼ã‚¯ {i}: 2Î¸ = {pos:.2f}Â°, å¼·åº¦ = {height:.1f}")</code></pre>

<strong>å‡ºåŠ›</strong>:
<pre><code>=== æ¤œå‡ºã•ã‚ŒãŸãƒ”ãƒ¼ã‚¯ ===
ãƒ”ãƒ¼ã‚¯ 1: 2Î¸ = 28.04Â°, å¼·åº¦ = 1021.3
ãƒ”ãƒ¼ã‚¯ 2: 2Î¸ = 32.05Â°, å¼·åº¦ = 1512.7
ãƒ”ãƒ¼ã‚¯ 3: 2Î¸ = 47.07Â°, å¼·åº¦ = 798.5</code></pre>

<h3>ãƒ”ãƒ¼ã‚¯æ¤œå‡ºãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æœ€é©åŒ–</h3>

<strong>ã‚³ãƒ¼ãƒ‰ä¾‹4: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ„Ÿåº¦è§£æ</strong>

<pre><code class="language-python"><h1>ç•°ãªã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ãƒ”ãƒ¼ã‚¯æ¤œå‡º</h1>
prominence_values = [30, 50, 80, 100]

fig, axes = plt.subplots(2, 2, figsize=(14, 10))
axes = axes.ravel()

for i, prom in enumerate(prominence_values):
    peaks_idx, _ = find_peaks(
        intensity_snip,
        prominence=prom,
        distance=5
    )

    axes[i].plot(two_theta, intensity_snip, linewidth=1.5)
    axes[i].plot(two_theta[peaks_idx], intensity_snip[peaks_idx],
                'rx', markersize=10, markeredgewidth=2)
    axes[i].set_xlabel('2Î¸ (degree)')
    axes[i].set_ylabel('Intensity')
    axes[i].set_title(f'Prominence = {prom} ({len(peaks_idx)} peaks)')
    axes[i].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("=== ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ„Ÿåº¦ ===")
for prom in prominence_values:
    peaks_idx, _ = find_peaks(intensity_snip, prominence=prom)
    print(f"Prominence = {prom:3d}: {len(peaks_idx)} peaks detected")</code></pre>

<h3>ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ï¼ˆã‚¬ã‚¦ã‚·ã‚¢ãƒ³ãƒ»ãƒ­ãƒ¼ãƒ¬ãƒ³ãƒ„ï¼‰</h3>

<strong>ã‚³ãƒ¼ãƒ‰ä¾‹5: ã‚¬ã‚¦ã‚·ã‚¢ãƒ³ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°</strong>

<pre><code class="language-python">from scipy.optimize import curve_fit

def gaussian(x, amplitude, center, sigma):
    """ã‚¬ã‚¦ã‚·ã‚¢ãƒ³é–¢æ•°"""
    return amplitude * np.exp(-((x - center) <strong> 2) / (2 * sigma </strong> 2))

def lorentzian(x, amplitude, center, gamma):
    """ãƒ­ãƒ¼ãƒ¬ãƒ³ãƒ„é–¢æ•°"""
    return amplitude * gamma<strong>2 / ((x - center)</strong>2 + gamma**2)

<h1>æœ€åˆã®ãƒ”ãƒ¼ã‚¯å‘¨è¾ºã‚’æŠ½å‡º</h1>
peak_region_mask = (two_theta > 26) & (two_theta < 30)
x_data = two_theta[peak_region_mask]
y_data = intensity_snip[peak_region_mask]

<h1>ã‚¬ã‚¦ã‚·ã‚¢ãƒ³ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°</h1>
initial_guess = [1000, 28, 1]  # [amplitude, center, sigma]
params_gauss, _ = curve_fit(gaussian, x_data, y_data,
                             p0=initial_guess)

<h1>ãƒ­ãƒ¼ãƒ¬ãƒ³ãƒ„ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°</h1>
initial_guess_lor = [1000, 28, 0.5]  # [amplitude, center, gamma]
params_lor, _ = curve_fit(lorentzian, x_data, y_data,
                          p0=initial_guess_lor)

<h1>ãƒ•ã‚£ãƒƒãƒˆçµæœ</h1>
x_fit = np.linspace(x_data.min(), x_data.max(), 200)
y_gauss = gaussian(x_fit, *params_gauss)
y_lor = lorentzian(x_fit, *params_lor)

<h1>å¯è¦–åŒ–</h1>
plt.figure(figsize=(12, 6))

plt.plot(x_data, y_data, 'o', label='Data', markersize=6)
plt.plot(x_fit, y_gauss, '-', linewidth=2,
         label=f'Gaussian (Ïƒ={params_gauss[2]:.2f})')
plt.plot(x_fit, y_lor, '--', linewidth=2,
         label=f'Lorentzian (Î³={params_lor[2]:.2f})')

plt.xlabel('2Î¸ (degree)')
plt.ylabel('Intensity')
plt.title('Peak Fitting: Gaussian vs Lorentzian')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

print("=== ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°çµæœ ===")
print(f"ã‚¬ã‚¦ã‚·ã‚¢ãƒ³:")
print(f"  ä¸­å¿ƒä½ç½®: {params_gauss[1]:.3f}Â°")
print(f"  æŒ¯å¹…: {params_gauss[0]:.1f}")
print(f"  Ïƒ: {params_gauss[2]:.3f}Â°")
print(f"\nãƒ­ãƒ¼ãƒ¬ãƒ³ãƒ„:")
print(f"  ä¸­å¿ƒä½ç½®: {params_lor[1]:.3f}Â°")
print(f"  æŒ¯å¹…: {params_lor[0]:.1f}")
print(f"  Î³: {params_lor[2]:.3f}Â°")</code></pre>

---

<h2>2.4 XPS ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æ</h2>

<h3>ã‚·ãƒ£ãƒ¼ãƒªãƒ¼å‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»</h3>

XPSã‚¹ãƒšã‚¯ãƒˆãƒ«ã¯éå¼¾æ€§æ•£ä¹±ã«ã‚ˆã‚‹ç‰¹å¾´çš„ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’æŒã¡ã¾ã™ã€‚

<strong>ã‚³ãƒ¼ãƒ‰ä¾‹6: ã‚·ãƒ£ãƒ¼ãƒªãƒ¼ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰</strong>

<pre><code class="language-python">def shirley_background(x, y, tol=1e-5, max_iter=50):
    """
    ã‚·ãƒ£ãƒ¼ãƒªãƒ¼å‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¨å®š

    Parameters:
    -----------
    x : array-like
        ã‚¨ãƒãƒ«ã‚®ãƒ¼è»¸ï¼ˆé™é †ã‚’æ¨å¥¨ï¼‰
    y : array-like
        å¼·åº¦
    tol : float
        åæŸåˆ¤å®šé–¾å€¤
    max_iter : int
        æœ€å¤§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•°

    Returns:
    --------
    background : array-like
        ã‚·ãƒ£ãƒ¼ãƒªãƒ¼ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰
    """
    # ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™
    y = np.array(y, dtype=float)
    background = np.zeros_like(y)

    # ä¸¡ç«¯ã®å€¤
    y_min = min(y[0], y[-1])
    y_max = max(y[0], y[-1])

    # åˆæœŸãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ï¼ˆç·šå½¢ï¼‰
    background = np.linspace(y[0], y[-1], len(y))

    # ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    for iteration in range(max_iter):
        background_old = background.copy()

        # ç´¯ç©å’Œã‚’ä½¿ç”¨
        cumsum = np.cumsum(y - background)
        total = cumsum[-1]

        if total == 0:
            break

        # æ–°ã—ã„ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰
        background = y[-1] + (y[0] - y[-1]) * cumsum / total

        # åæŸåˆ¤å®š
        if np.max(np.abs(background - background_old)) < tol:
            break

    return background

<h1>XPSã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆC 1s ã‚¹ãƒšã‚¯ãƒˆãƒ«ï¼‰</h1>
binding_energy = np.linspace(280, 295, 300)[::-1]  # é™é †
xps_peak = 5000 * np.exp(-((binding_energy - 285) ** 2) / 2)
shirley_bg = np.linspace(500, 200, len(binding_energy))
xps_spectrum = xps_peak + shirley_bg + \
               np.random.normal(0, 50, len(binding_energy))

<h1>ã‚·ãƒ£ãƒ¼ãƒªãƒ¼ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¨å®š</h1>
shirley_bg_calc = shirley_background(binding_energy, xps_spectrum)

<h1>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¸›ç®—</h1>
xps_corrected = xps_spectrum - shirley_bg_calc

<h1>å¯è¦–åŒ–</h1>
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

<h1>XPSç”Ÿãƒ‡ãƒ¼ã‚¿</h1>
axes[0].plot(binding_energy, xps_spectrum, linewidth=1.5)
axes[0].set_xlabel('Binding Energy (eV)')
axes[0].set_ylabel('Intensity (CPS)')
axes[0].set_title('Raw XPS Spectrum (C 1s)')
axes[0].invert_xaxis()
axes[0].grid(True, alpha=0.3)

<h1>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¨å®š</h1>
axes[1].plot(binding_energy, xps_spectrum,
             label='Raw data', alpha=0.6)
axes[1].plot(binding_energy, shirley_bg_calc,
             label='Shirley background',
             linewidth=2, color='red')
axes[1].set_xlabel('Binding Energy (eV)')
axes[1].set_ylabel('Intensity (CPS)')
axes[1].set_title('Shirley Background Estimation')
axes[1].invert_xaxis()
axes[1].legend()
axes[1].grid(True, alpha=0.3)

<h1>è£œæ­£å¾Œ</h1>
axes[2].plot(binding_energy, xps_corrected,
             linewidth=1.5, color='green')
axes[2].set_xlabel('Binding Energy (eV)')
axes[2].set_ylabel('Intensity (CPS)')
axes[2].set_title('After Shirley Subtraction')
axes[2].invert_xaxis()
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("=== ã‚·ãƒ£ãƒ¼ãƒªãƒ¼ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å» ===")
print(f"ã‚¨ãƒãƒ«ã‚®ãƒ¼ç¯„å›²: {binding_energy.max():.1f} - "
      f"{binding_energy.min():.1f} eV")
print(f"ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é«˜ã•ï¼ˆé«˜BEå´ï¼‰: {shirley_bg_calc[0]:.1f}")
print(f"ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é«˜ã•ï¼ˆä½BEå´ï¼‰: {shirley_bg_calc[-1]:.1f}")</code></pre>

---

<h2>2.5 IRãƒ»Ramanã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æ</h2>

<h3>ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³è£œæ­£ï¼ˆAsymmetric Least Squaresæ³•ï¼‰</h3>

IRãƒ»Ramanã‚¹ãƒšã‚¯ãƒˆãƒ«ã®è›å…‰ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã«æœ‰åŠ¹ã§ã™ã€‚

<strong>ã‚³ãƒ¼ãƒ‰ä¾‹7: ALSæ³•ã«ã‚ˆã‚‹ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³è£œæ­£</strong>

<pre><code class="language-python">from scipy import sparse
from scipy.sparse.linalg import spsolve

def als_baseline(y, lam=1e5, p=0.01, niter=10):
    """
    Asymmetric Least Squaresæ³•ã«ã‚ˆã‚‹ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³æ¨å®š

    Parameters:
    -----------
    y : array-like
        ã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿
    lam : float
        å¹³æ»‘åŒ–ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå¤§ãã„ã»ã©æ»‘ã‚‰ã‹ï¼‰
    p : float
        éå¯¾ç§°ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆ0-1ã€å°ã•ã„ã»ã©ãƒ”ãƒ¼ã‚¯ã‚’é¿ã‘ã‚‹ï¼‰
    niter : int
        ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•°

    Returns:
    --------
    baseline : array-like
        æ¨å®šã•ã‚ŒãŸãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³
    """
    L = len(y)
    D = sparse.diags([1, -2, 1], [0, -1, -2], shape=(L, L-2))
    w = np.ones(L)

    for i in range(niter):
        W = sparse.spdiags(w, 0, L, L)
        Z = W + lam * D.dot(D.transpose())
        z = spsolve(Z, w * y)
        w = p * (y > z) + (1 - p) * (y < z)

    return z

<h1>Ramanã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ</h1>
raman_shift = np.linspace(200, 2000, 900)
raman_peaks = (
    3000 * np.exp(-((raman_shift - 520) ** 2) / 100) +
    2000 * np.exp(-((raman_shift - 950) ** 2) / 200) +
    1500 * np.exp(-((raman_shift - 1350) ** 2) / 150)
)
fluorescence_bg = 500 + 0.5 * raman_shift + \
                  0.0005 * (raman_shift - 1000) ** 2
raman_spectrum = raman_peaks + fluorescence_bg + \
                 np.random.normal(0, 50, len(raman_shift))

<h1>ALSæ³•é©ç”¨</h1>
als_bg = als_baseline(raman_spectrum, lam=1e6, p=0.01)
raman_corrected = raman_spectrum - als_bg

<h1>å¯è¦–åŒ–</h1>
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

<h1>ç”Ÿãƒ‡ãƒ¼ã‚¿</h1>
axes[0].plot(raman_shift, raman_spectrum, linewidth=1.5)
axes[0].set_xlabel('Raman Shift (cmâ»Â¹)')
axes[0].set_ylabel('Intensity (a.u.)')
axes[0].set_title('Raw Raman Spectrum')
axes[0].grid(True, alpha=0.3)

<h1>ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³æ¨å®š</h1>
axes[1].plot(raman_shift, raman_spectrum,
             label='Raw data', alpha=0.6)
axes[1].plot(raman_shift, als_bg,
             label='ALS baseline', linewidth=2, color='red')
axes[1].set_xlabel('Raman Shift (cmâ»Â¹)')
axes[1].set_ylabel('Intensity (a.u.)')
axes[1].set_title('ALS Baseline Estimation')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

<h1>è£œæ­£å¾Œ</h1>
axes[2].plot(raman_shift, raman_corrected,
             linewidth=1.5, color='purple')
axes[2].set_xlabel('Raman Shift (cmâ»Â¹)')
axes[2].set_ylabel('Intensity (a.u.)')
axes[2].set_title('After ALS Subtraction')
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("=== ALS ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³è£œæ­£ ===")
print(f"å¹³æ»‘åŒ–ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ (Î»): 1e6")
print(f"éå¯¾ç§°ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ (p): 0.01")</code></pre>

---

<h2>2.6 å®šé‡ç›¸åˆ†æï¼ˆXRD-RIRæ³•ï¼‰</h2>

<h3>Reference Intensity Ratioï¼ˆRIRï¼‰æ³•</h3>

è¤‡æ•°ç›¸ã‚’å«ã‚€XRDãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰ã€å„ç›¸ã®é‡é‡åˆ†ç‡ã‚’ç®—å‡ºã—ã¾ã™ã€‚

<strong>ã‚³ãƒ¼ãƒ‰ä¾‹8: RIRæ³•ã«ã‚ˆã‚‹å®šé‡ç›¸åˆ†æ</strong>

<pre><code class="language-python"><h1>2ç›¸ç³»ã®XRDãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆ</h1>
two_theta = np.linspace(10, 80, 700)

<h1>ç›¸Aï¼ˆä¾‹ï¼šÎ±-Fe2O3ã€ä¸»ãƒ”ãƒ¼ã‚¯: 33.2Â°ï¼‰</h1>
phase_A = (
    2000 * np.exp(-((two_theta - 33.2) ** 2) / 15) +
    1200 * np.exp(-((two_theta - 35.6) ** 2) / 10) +
    800 * np.exp(-((two_theta - 54.1) ** 2) / 12)
)

<h1>ç›¸Bï¼ˆä¾‹ï¼šFe3O4ã€ä¸»ãƒ”ãƒ¼ã‚¯: 35.5Â°ï¼‰</h1>
phase_B = (
    1500 * np.exp(-((two_theta - 35.5) ** 2) / 18) +
    1000 * np.exp(-((two_theta - 30.1) ** 2) / 12) +
    600 * np.exp(-((two_theta - 62.7) ** 2) / 14)
)

<h1>æ··åˆãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç›¸A:ç›¸B = 70:30 wt%ï¼‰</h1>
ratio_A = 0.7
ratio_B = 0.3
mixed_pattern = ratio_A * phase_A + ratio_B * phase_B + \
                np.random.normal(0, 30, len(two_theta))

<h1>RIRå€¤ï¼ˆæ–‡çŒ®å€¤ã€ã‚³ãƒ©ãƒ³ãƒ€ãƒ ã«å¯¾ã™ã‚‹ç›¸å¯¾å€¤ï¼‰</h1>
RIR_A = 3.5  # Î±-Fe2O3ã®RIR
RIR_B = 2.8  # Fe3O4ã®RIR

<h1>ä¸»ãƒ”ãƒ¼ã‚¯å¼·åº¦æ¸¬å®š</h1>
<h1>ç›¸Aã®ä¸»ãƒ”ãƒ¼ã‚¯ï¼ˆ33.2Â°ä»˜è¿‘ï¼‰</h1>
peak_A_idx = np.argmax(mixed_pattern[(two_theta > 32) &
                                     (two_theta < 34)])
I_A = mixed_pattern[(two_theta > 32) & (two_theta < 34)][peak_A_idx]

<h1>ç›¸Bã®ä¸»ãƒ”ãƒ¼ã‚¯ï¼ˆ35.5Â°ä»˜è¿‘ï¼‰</h1>
peak_B_idx = np.argmax(mixed_pattern[(two_theta > 34.5) &
                                     (two_theta < 36)])
I_B = mixed_pattern[(two_theta > 34.5) & (two_theta < 36)][peak_B_idx]

<h1>RIRæ³•ã«ã‚ˆã‚‹é‡é‡åˆ†ç‡è¨ˆç®—</h1>
<h1>W_A / W_B = (I_A / I_B) * (RIR_B / RIR_A)</h1>
ratio_calc = (I_A / I_B) * (RIR_B / RIR_A)

<h1>æ­£è¦åŒ–</h1>
W_A_calc = ratio_calc / (1 + ratio_calc)
W_B_calc = 1 - W_A_calc

<h1>å¯è¦–åŒ–</h1>
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

<h1>æ··åˆãƒ‘ã‚¿ãƒ¼ãƒ³</h1>
axes[0, 0].plot(two_theta, mixed_pattern, linewidth=1.5)
axes[0, 0].set_xlabel('2Î¸ (degree)')
axes[0, 0].set_ylabel('Intensity')
axes[0, 0].set_title('Mixed XRD Pattern (Phase A + B)')
axes[0, 0].grid(True, alpha=0.3)

<h1>å„ç›¸ã®å¯„ä¸</h1>
axes[0, 1].plot(two_theta, ratio_A * phase_A,
                label='Phase A (70%)', linewidth=1.5)
axes[0, 1].plot(two_theta, ratio_B * phase_B,
                label='Phase B (30%)', linewidth=1.5)
axes[0, 1].set_xlabel('2Î¸ (degree)')
axes[0, 1].set_ylabel('Intensity')
axes[0, 1].set_title('Individual Phase Contributions')
axes[0, 1].legend()
axes[0, 1].grid(True, alpha=0.3)

<h1>ä¸»ãƒ”ãƒ¼ã‚¯ã®ä½ç½®</h1>
axes[1, 0].plot(two_theta, mixed_pattern, linewidth=1.5)
axes[1, 0].axvline(x=33.2, color='blue',
                   linestyle='--', label='Phase A peak')
axes[1, 0].axvline(x=35.5, color='orange',
                   linestyle='--', label='Phase B peak')
axes[1, 0].set_xlabel('2Î¸ (degree)')
axes[1, 0].set_ylabel('Intensity')
axes[1, 0].set_title('Main Peak Positions')
axes[1, 0].legend()
axes[1, 0].grid(True, alpha=0.3)

<h1>å®šé‡çµæœ</h1>
categories = ['Phase A', 'Phase B']
true_values = [ratio_A * 100, ratio_B * 100]
calc_values = [W_A_calc * 100, W_B_calc * 100]

x = np.arange(len(categories))
width = 0.35

axes[1, 1].bar(x - width/2, true_values, width,
               label='True', alpha=0.7)
axes[1, 1].bar(x + width/2, calc_values, width,
               label='Calculated (RIR)', alpha=0.7)
axes[1, 1].set_ylabel('Weight Fraction (%)')
axes[1, 1].set_title('Quantitative Phase Analysis')
axes[1, 1].set_xticks(x)
axes[1, 1].set_xticklabels(categories)
axes[1, 1].legend()
axes[1, 1].grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.show()

print("=== RIRæ³•ã«ã‚ˆã‚‹å®šé‡ç›¸åˆ†æ ===")
print(f"ä¸»ãƒ”ãƒ¼ã‚¯å¼·åº¦:")
print(f"  ç›¸A (33.2Â°): {I_A:.1f}")
print(f"  ç›¸B (35.5Â°): {I_B:.1f}")
print(f"\nRIRå€¤:")
print(f"  ç›¸A: {RIR_A}")
print(f"  ç›¸B: {RIR_B}")
print(f"\né‡é‡åˆ†ç‡:")
print(f"  çœŸå€¤ - ç›¸A: {ratio_A*100:.1f}%, ç›¸B: {ratio_B*100:.1f}%")
print(f"  è¨ˆç®— - ç›¸A: {W_A_calc*100:.1f}%, ç›¸B: {W_B_calc*100:.1f}%")
print(f"  èª¤å·®: ç›¸A {abs(ratio_A - W_A_calc)*100:.1f}%")</code></pre>

---

<h2>2.7 ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æã®è‡ªå‹•åŒ–ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</h2>

<h3>çµ±åˆè§£æãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</h3>

<strong>ã‚³ãƒ¼ãƒ‰ä¾‹9: è‡ªå‹•ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</strong>

<pre><code class="language-python">from dataclasses import dataclass
from typing import Tuple, List

@dataclass
class PeakInfo:
    """ãƒ”ãƒ¼ã‚¯æƒ…å ±ã‚’æ ¼ç´ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹"""
    position: float
    intensity: float
    width: float
    area: float

class SpectrumAnalyzer:
    """ã‚¹ãƒšã‚¯ãƒˆãƒ«è‡ªå‹•è§£æã‚¯ãƒ©ã‚¹"""

    def __init__(self, spectrum_type='XRD'):
        """
        Parameters:
        -----------
        spectrum_type : str
            'XRD', 'XPS', 'IR', 'Raman'
        """
        self.spectrum_type = spectrum_type
        self.x = None
        self.y = None
        self.y_corrected = None
        self.peaks = []

    def load_data(self, x: np.ndarray, y: np.ndarray):
        """ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿"""
        self.x = np.array(x)
        self.y = np.array(y)

    def remove_background(self, method='snip', **kwargs):
        """ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»"""
        if method == 'snip':
            iterations = kwargs.get('iterations', 30)
            bg = snip_background(self.y, iterations)
        elif method == 'polynomial':
            degree = kwargs.get('degree', 5)
            coeffs = np.polyfit(self.x, self.y, degree)
            bg = np.polyval(coeffs, self.x)
        elif method == 'als':
            lam = kwargs.get('lam', 1e5)
            p = kwargs.get('p', 0.01)
            bg = als_baseline(self.y, lam, p)
        else:
            raise ValueError(f"Unknown method: {method}")

        self.y_corrected = self.y - bg
        return self.y_corrected

    def detect_peaks(self, **kwargs):
        """ãƒ”ãƒ¼ã‚¯æ¤œå‡º"""
        if self.y_corrected is None:
            raise ValueError("Run remove_background first")

        prominence = kwargs.get('prominence', 50)
        distance = kwargs.get('distance', 10)

        peaks_idx, properties = find_peaks(
            self.y_corrected,
            prominence=prominence,
            distance=distance
        )

        self.peaks = []
        for idx in peaks_idx:
            peak = PeakInfo(
                position=self.x[idx],
                intensity=self.y_corrected[idx],
                width=properties['widths'][0] if 'widths' in properties else 0,
                area=0  # å¾Œã§è¨ˆç®—
            )
            self.peaks.append(peak)

        return self.peaks

    def report(self):
        """çµæœãƒ¬ãƒãƒ¼ãƒˆ"""
        print(f"\n=== {self.spectrum_type} Spectrum Analysis Report ===")
        print(f"ãƒ‡ãƒ¼ã‚¿ç‚¹æ•°: {len(self.x)}")
        print(f"æ¤œå‡ºã•ã‚ŒãŸãƒ”ãƒ¼ã‚¯æ•°: {len(self.peaks)}")
        print(f"\nãƒ”ãƒ¼ã‚¯æƒ…å ±:")
        for i, peak in enumerate(self.peaks, 1):
            if self.spectrum_type == 'XRD':
                print(f"  ãƒ”ãƒ¼ã‚¯ {i}: 2Î¸ = {peak.position:.2f}Â°, "
                      f"å¼·åº¦ = {peak.intensity:.1f}")
            elif self.spectrum_type == 'XPS':
                print(f"  ãƒ”ãƒ¼ã‚¯ {i}: BE = {peak.position:.2f} eV, "
                      f"å¼·åº¦ = {peak.intensity:.1f}")
            elif self.spectrum_type in ['IR', 'Raman']:
                print(f"  ãƒ”ãƒ¼ã‚¯ {i}: {peak.position:.1f} cmâ»Â¹, "
                      f"å¼·åº¦ = {peak.intensity:.1f}")

<h1>ä½¿ç”¨ä¾‹</h1>
analyzer = SpectrumAnalyzer(spectrum_type='XRD')
analyzer.load_data(two_theta, intensity)
analyzer.remove_background(method='snip', iterations=50)
peaks = analyzer.detect_peaks(prominence=80, distance=10)
analyzer.report()

<h1>å¯è¦–åŒ–</h1>
plt.figure(figsize=(14, 6))

plt.subplot(1, 2, 1)
plt.plot(analyzer.x, analyzer.y, label='Raw', alpha=0.5)
plt.plot(analyzer.x, analyzer.y_corrected,
         label='Background-corrected', linewidth=1.5)
plt.xlabel('2Î¸ (degree)')
plt.ylabel('Intensity')
plt.title('Spectrum Processing')
plt.legend()
plt.grid(True, alpha=0.3)

plt.subplot(1, 2, 2)
plt.plot(analyzer.x, analyzer.y_corrected, linewidth=1.5)
peak_positions = [p.position for p in peaks]
peak_intensities = [p.intensity for p in peaks]
plt.plot(peak_positions, peak_intensities, 'rx',
         markersize=12, markeredgewidth=2)
plt.xlabel('2Î¸ (degree)')
plt.ylabel('Intensity')
plt.title('Peak Detection')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()</code></pre>

---

<h2>2.8 æœ¬ç« ã®ã¾ã¨ã‚</h2>

<h3>å­¦ã‚“ã ã“ã¨</h3>

1. <strong>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»æ‰‹æ³•</strong>
   - å¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ï¼ˆæ±ç”¨ï¼‰
   - SNIPæ³•ï¼ˆXRDã€Ramanï¼‰
   - ã‚·ãƒ£ãƒ¼ãƒªãƒ¼å‹ï¼ˆXPSï¼‰
   - ALSæ³•ï¼ˆIRã€Ramanï¼‰

2. <strong>ãƒ”ãƒ¼ã‚¯æ¤œå‡º</strong>
   - <code>scipy.signal.find_peaks</code>ã®æ´»ç”¨
   - ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æœ€é©åŒ–ï¼ˆprominenceã€distanceã€widthï¼‰
   - ã‚¬ã‚¦ã‚·ã‚¢ãƒ³ãƒ»ãƒ­ãƒ¼ãƒ¬ãƒ³ãƒ„ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°

3. <strong>å®šé‡åˆ†æ</strong>
   - RIRæ³•ã«ã‚ˆã‚‹ç›¸åˆ†ç‡è¨ˆç®—
   - ãƒ”ãƒ¼ã‚¯é¢ç©ã®å®šé‡è©•ä¾¡

4. <strong>è‡ªå‹•åŒ–</strong>
   - ã‚¯ãƒ©ã‚¹ãƒ™ãƒ¼ã‚¹ã®è§£æãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
   - è¤‡æ•°æ¸¬å®šæŠ€è¡“ã¸ã®å¯¾å¿œ

<h3>é‡è¦ãªãƒã‚¤ãƒ³ãƒˆ</h3>

- âœ… ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã¯æ¸¬å®šæŠ€è¡“ã”ã¨ã«é©åˆ‡ãªæ‰‹æ³•ã‚’é¸æŠ
- âœ… ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã§ã¯ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´ã¨å¯è¦–åŒ–ç¢ºèªãŒå¿…é ˆ
- âœ… å®šé‡åˆ†æã«ã¯æ¨™æº–è©¦æ–™ã‚„RIRå€¤ãªã©ã®å‚ç…§æƒ…å ±ãŒå¿…è¦
- âœ… è‡ªå‹•åŒ–ã«ã‚ˆã‚Šå†ç¾æ€§ã¨å‡¦ç†é€Ÿåº¦ãŒå¤§å¹…ã«å‘ä¸Š

<h3>æ¬¡ã®ç« ã¸</h3>

ç¬¬3ç« ã§ã¯ã€ç”»åƒãƒ‡ãƒ¼ã‚¿ï¼ˆSEMã€TEMï¼‰ã®è§£ææ‰‹æ³•ã‚’å­¦ã³ã¾ã™ï¼š
- ç”»åƒå‰å‡¦ç†ï¼ˆãƒã‚¤ã‚ºé™¤å»ã€ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆèª¿æ•´ï¼‰
- ç²’å­æ¤œå‡ºï¼ˆWatershedæ³•ï¼‰
- ç²’å¾„åˆ†å¸ƒè§£æ
- CNNã«ã‚ˆã‚‹ç”»åƒåˆ†é¡

<strong>[ç¬¬3ç« ï¼šç”»åƒãƒ‡ãƒ¼ã‚¿è§£æ â†’](./chapter-3.md)</strong>

---

<h2>æ¼”ç¿’å•é¡Œ</h2>

<h3>å•é¡Œ1ï¼ˆé›£æ˜“åº¦ï¼šeasyï¼‰</h3>

æ¬¡ã®æ–‡ç« ã®æ­£èª¤ã‚’åˆ¤å®šã—ã¦ãã ã•ã„ã€‚

1. SNIPæ³•ã¯å¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã‚ˆã‚Šã‚‚ãƒ”ãƒ¼ã‚¯ã®å½±éŸ¿ã‚’å—ã‘ã«ãã„
2. XPSã‚¹ãƒšã‚¯ãƒˆãƒ«ã«ã¯ç·šå½¢ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãŒé©ã—ã¦ã„ã‚‹
3. ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã®prominenceãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ã€ãƒ”ãƒ¼ã‚¯é–“ã®æœ€å°è·é›¢ã‚’æŒ‡å®šã™ã‚‹

<details>
<summary>ãƒ’ãƒ³ãƒˆ</summary>

1. SNIPæ³•ã®å‹•ä½œåŸç†ï¼ˆãƒ”ãƒ¼ã‚¯ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ï¼‰ã‚’è€ƒãˆã‚‹
2. XPSã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã¯éå¼¾æ€§æ•£ä¹±ã«èµ·å› ã™ã‚‹
3. prominenceã€distanceã€widthãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ„å‘³ã‚’ç¢ºèª

</details>

<details>
<summary>è§£ç­”ä¾‹</summary>

<strong>è§£ç­”</strong>:
1. <strong>æ­£</strong> - SNIPæ³•ã¯ãƒ”ãƒ¼ã‚¯ã‚’é¿ã‘ã¦ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’æ¨å®šã™ã‚‹ãŸã‚ã€å¤šé …å¼ã‚ˆã‚Šãƒ­ãƒã‚¹ãƒˆ
2. <strong>èª¤</strong> - XPSã¯ã‚·ãƒ£ãƒ¼ãƒªãƒ¼å‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãŒé©åˆ‡ï¼ˆéå¼¾æ€§æ•£ä¹±ã«ã‚ˆã‚‹éå¯¾ç§°å½¢çŠ¶ï¼‰
3. <strong>èª¤</strong> - prominenceã¯å“è¶Šåº¦ï¼ˆå‘¨å›²ã¨ã®é«˜ä½å·®ï¼‰ã€ãƒ”ãƒ¼ã‚¯é–“è·é›¢ã¯distanceãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

<strong>è§£èª¬</strong>:
ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»æ‰‹æ³•ã®é¸æŠã¯æ¸¬å®šåŸç†ã«åŸºã¥ãã“ã¨ãŒé‡è¦ã§ã™ã€‚XPSã®éå¼¾æ€§æ•£ä¹±ã€Ramanã®è›å…‰ã€XRDã®éæ™¶è³ªãƒãƒ­ãƒ¼ãªã©ã€ãã‚Œãã‚Œç•°ãªã‚‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å½¢çŠ¶ã‚’æŒã¡ã¾ã™ã€‚

</details>

---

<h3>å•é¡Œ2ï¼ˆé›£æ˜“åº¦ï¼šmediumï¼‰</h3>

ä»¥ä¸‹ã®XRDãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã€SNIPæ³•ã§ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã‚’è¡Œã„ã€ãƒ”ãƒ¼ã‚¯ã‚’æ¤œå‡ºã—ã¦ãã ã•ã„ã€‚

<pre><code class="language-python">import numpy as np

<h1>ã‚µãƒ³ãƒ—ãƒ«XRDãƒ‡ãƒ¼ã‚¿</h1>
np.random.seed(123)
two_theta = np.linspace(15, 75, 600)
intensity = (
    1200 * np.exp(-((two_theta - 26.6) ** 2) / 12) +
    1800 * np.exp(-((two_theta - 33.8) ** 2) / 10) +
    1000 * np.exp(-((two_theta - 54.8) ** 2) / 15) +
    150 + 50 * np.sin(two_theta / 8) +
    np.random.normal(0, 40, len(two_theta))
)</code></pre>

<strong>è¦æ±‚äº‹é …</strong>:
1. SNIPæ³•ã§ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ï¼ˆiterations=40ï¼‰
2. ãƒ”ãƒ¼ã‚¯æ¤œå‡ºï¼ˆprominence=100ï¼‰
3. æ¤œå‡ºã•ã‚ŒãŸãƒ”ãƒ¼ã‚¯ä½ç½®ã¨å¼·åº¦ã‚’å‡ºåŠ›
4. å‡¦ç†å‰å¾Œã®ã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚’å¯è¦–åŒ–

<details>
<summary>ãƒ’ãƒ³ãƒˆ</summary>

<strong>å‡¦ç†ãƒ•ãƒ­ãƒ¼</strong>:
1. SNIPé–¢æ•°ã‚’å®šç¾©ã¾ãŸã¯å†åˆ©ç”¨
2. ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¸›ç®—
3. <code>find_peaks</code>ã§ãƒ”ãƒ¼ã‚¯æ¤œå‡º
4. çµæœã‚’æ•´ç†ã—ã¦å‡ºåŠ›
5. <code>matplotlib</code>ã§3æ®µéšï¼ˆå…ƒãƒ‡ãƒ¼ã‚¿ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã€è£œæ­£å¾Œï¼‰ã‚’å¯è¦–åŒ–

</details>

<details>
<summary>è§£ç­”ä¾‹</summary>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks

<h1>SNIPé–¢æ•°ï¼ˆã‚³ãƒ¼ãƒ‰ä¾‹2ã‚ˆã‚Šï¼‰</h1>
def snip_background(spectrum, iterations=30):
    spectrum = np.array(spectrum, dtype=float)
    background = np.copy(spectrum)

    for i in range(1, iterations + 1):
        for j in range(i, len(background) - i):
            v1 = (background[j - i] + background[j + i]) / 2
            v2 = background[j]
            background[j] = min(v1, v2)

    return background

<h1>ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿</h1>
np.random.seed(123)
two_theta = np.linspace(15, 75, 600)
intensity = (
    1200 * np.exp(-((two_theta - 26.6) ** 2) / 12) +
    1800 * np.exp(-((two_theta - 33.8) ** 2) / 10) +
    1000 * np.exp(-((two_theta - 54.8) ** 2) / 15) +
    150 + 50 * np.sin(two_theta / 8) +
    np.random.normal(0, 40, len(two_theta))
)

<h1>SNIPæ³•é©ç”¨</h1>
bg = snip_background(intensity, iterations=40)
intensity_corrected = intensity - bg

<h1>ãƒ”ãƒ¼ã‚¯æ¤œå‡º</h1>
peaks_idx, _ = find_peaks(intensity_corrected, prominence=100)
peak_positions = two_theta[peaks_idx]
peak_intensities = intensity_corrected[peaks_idx]

<h1>çµæœå‡ºåŠ›</h1>
print("=== ãƒ”ãƒ¼ã‚¯æ¤œå‡ºçµæœ ===")
for i, (pos, intens) in enumerate(zip(peak_positions,
                                       peak_intensities), 1):
    print(f"ãƒ”ãƒ¼ã‚¯ {i}: 2Î¸ = {pos:.2f}Â°, å¼·åº¦ = {intens:.1f}")

<h1>å¯è¦–åŒ–</h1>
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

axes[0].plot(two_theta, intensity, linewidth=1.5)
axes[0].set_xlabel('2Î¸ (degree)')
axes[0].set_ylabel('Intensity')
axes[0].set_title('Raw XRD Pattern')
axes[0].grid(True, alpha=0.3)

axes[1].plot(two_theta, intensity, label='Raw', alpha=0.6)
axes[1].plot(two_theta, bg, label='SNIP background',
             linewidth=2, color='red')
axes[1].set_xlabel('2Î¸ (degree)')
axes[1].set_ylabel('Intensity')
axes[1].set_title('Background Estimation')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

axes[2].plot(two_theta, intensity_corrected, linewidth=1.5)
axes[2].plot(peak_positions, peak_intensities, 'rx',
             markersize=12, markeredgewidth=2)
axes[2].set_xlabel('2Î¸ (degree)')
axes[2].set_ylabel('Intensity')
axes[2].set_title('After Background Subtraction + Peak Detection')
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()</code></pre>

<strong>å‡ºåŠ›</strong>:
<pre><code>=== ãƒ”ãƒ¼ã‚¯æ¤œå‡ºçµæœ ===
ãƒ”ãƒ¼ã‚¯ 1: 2Î¸ = 26.59Â°, å¼·åº¦ = 1205.3
ãƒ”ãƒ¼ã‚¯ 2: 2Î¸ = 33.81Â°, å¼·åº¦ = 1813.7
ãƒ”ãƒ¼ã‚¯ 3: 2Î¸ = 54.76Â°, å¼·åº¦ = 1008.2</code></pre>

<strong>è§£èª¬</strong>:
SNIPæ³•ã®iterations=40ã¯ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®ç‰¹å¾´çš„ãªå¹…ï¼ˆãƒ‡ãƒ¼ã‚¿ç‚¹æ•°ï¼‰ã«å¯¾å¿œã—ã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯ç·©ã‚„ã‹ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®ãŸã‚ã€40ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§ååˆ†ã§ã™ã€‚prominence=100ã«ã‚ˆã‚Šã€ãƒã‚¤ã‚ºãƒ”ãƒ¼ã‚¯ã‚’é™¤å¤–ã—ã€ä¸»è¦ãª3ãƒ”ãƒ¼ã‚¯ã®ã¿ã‚’æ¤œå‡ºã§ãã¾ã—ãŸã€‚

</details>

---

<h3>å•é¡Œ3ï¼ˆé›£æ˜“åº¦ï¼šhardï¼‰</h3>

è¤‡æ•°ã®æ¸¬å®šæŠ€è¡“ï¼ˆXRDã€XPSã€Ramanï¼‰ã®ã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•å‡¦ç†ã™ã‚‹ãƒãƒƒãƒã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¦ãã ã•ã„ã€‚

<strong>èƒŒæ™¯</strong>:
ææ–™ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‹ã‚‰100ã‚µãƒ³ãƒ—ãƒ«ã®è¤‡åˆæ¸¬å®šãƒ‡ãƒ¼ã‚¿ï¼ˆXRDã€XPSã€Ramanï¼‰ãŒå¾—ã‚‰ã‚Œã¾ã—ãŸã€‚å„æ¸¬å®šã«ã¤ã„ã¦é©åˆ‡ãªå‰å‡¦ç†ã‚’è‡ªå‹•é¸æŠã—ã€ãƒ”ãƒ¼ã‚¯æƒ…å ±ã‚’æŠ½å‡ºã™ã‚‹çµ±åˆã‚·ã‚¹ãƒ†ãƒ ãŒå¿…è¦ã§ã™ã€‚

<strong>èª²é¡Œ</strong>:
1. æ¸¬å®šæŠ€è¡“ã«å¿œã˜ãŸæœ€é©ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»æ‰‹æ³•ã®è‡ªå‹•é¸æŠ
2. ãƒ”ãƒ¼ã‚¯æ¤œå‡ºãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è‡ªå‹•èª¿æ•´
3. çµæœã‚’JSONå½¢å¼ã§ä¿å­˜
4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ­ã‚°å‡ºåŠ›

<strong>åˆ¶ç´„æ¡ä»¶</strong>:
- å„æ¸¬å®šæŠ€è¡“ã§ç•°ãªã‚‹ãƒ‡ãƒ¼ã‚¿å½¢å¼ï¼ˆåˆ—åã€å˜ä½ï¼‰
- æ¸¬å®šå“è³ªã®ã°ã‚‰ã¤ãï¼ˆãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ï¼‰
- å‡¦ç†æ™‚é–“ï¼š10ç§’ä»¥å†…/ã‚µãƒ³ãƒ—ãƒ«

<details>
<summary>ãƒ’ãƒ³ãƒˆ</summary>

<strong>è¨­è¨ˆæ–¹é‡</strong>:
1. <code>SpectrumAnalyzer</code>ã‚¯ãƒ©ã‚¹ã‚’æ‹¡å¼µ
2. æ¸¬å®šæŠ€è¡“ã®è‡ªå‹•åˆ¤å®šï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰ï¼‰
3. é©å¿œçš„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´ï¼ˆãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦prominenceèª¿æ•´ï¼‰
4. JSONå‡ºåŠ›ã«ã¯ãƒ”ãƒ¼ã‚¯ä½ç½®ã€å¼·åº¦ã€æ¨å®šç›¸æƒ…å ±ã‚’å«ã‚ã‚‹

<strong>ã‚¯ãƒ©ã‚¹è¨­è¨ˆä¾‹</strong>:
<pre><code class="language-python">class AutoSpectrumProcessor:
    def __init__(self):
        self.analyzers = {}  # æ¸¬å®šæŠ€è¡“ã”ã¨ã®analyzer

    def detect_spectrum_type(self, data):
        # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ¸¬å®šæŠ€è¡“ã‚’åˆ¤å®š
        pass

    def adaptive_parameters(self, spectrum):
        # ãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´
        pass

    def batch_process(self, file_list):
        # è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†
        pass</code></pre>

</details>

<details>
<summary>è§£ç­”ä¾‹</summary>

<strong>è§£ç­”ã®æ¦‚è¦</strong>:
æ¸¬å®šæŠ€è¡“ã®è‡ªå‹•åˆ¤å®šã€é©å¿œçš„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´ã€çµæœã®JSONä¿å­˜ã‚’å«ã‚€çµ±åˆå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚

<strong>å®Ÿè£…ã‚³ãƒ¼ãƒ‰</strong>:

<pre><code class="language-python">import json
import logging
from pathlib import Path
from typing import Dict, List
from dataclasses import dataclass, asdict

logging.basicConfig(level=logging.INFO)

@dataclass
class SpectrumResult:
    """è§£æçµæœã‚’æ ¼ç´"""
    spectrum_type: str
    num_peaks: int
    peaks: List[Dict]
    processing_time: float
    background_method: str

class AutoSpectrumProcessor:
    """è‡ªå‹•ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æã‚·ã‚¹ãƒ†ãƒ """

    def __init__(self):
        self.bg_methods = {
            'XRD': 'snip',
            'XPS': 'shirley',
            'Raman': 'als',
            'IR': 'als'
        }

    def detect_spectrum_type(self, x: np.ndarray) -> str:
        """
        ãƒ‡ãƒ¼ã‚¿ç¯„å›²ã‹ã‚‰æ¸¬å®šæŠ€è¡“ã‚’æ¨å®š
        """
        x_range = x.max() - x.min()
        x_min = x.min()

        if x_min > 5 and x_range < 100:  # 2Î¸ç¯„å›²
            return 'XRD'
        elif x_min > 200 and x_range > 500:  # BEç¯„å›²
            return 'XPS'
        elif x_min > 100 and x_range > 1000:  # cm-1ç¯„å›²
            return 'Raman' if x.max() < 4000 else 'IR'
        else:
            return 'Unknown'

    def adaptive_prominence(self, spectrum: np.ndarray) -> float:
        """
        ãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦prominenceèª¿æ•´
        """
        noise_std = np.std(np.diff(spectrum))
        snr = np.max(spectrum) / (noise_std + 1e-10)

        if snr > 50:
            return 0.05 * np.max(spectrum)  # é«˜S/N
        elif snr > 20:
            return 0.08 * np.max(spectrum)  # ä¸­S/N
        else:
            return 0.12 * np.max(spectrum)  # ä½S/N

    def process_spectrum(self, x: np.ndarray, y: np.ndarray,
                        metadata: Dict = None) -> SpectrumResult:
        """
        å˜ä¸€ã‚¹ãƒšã‚¯ãƒˆãƒ«ã®å‡¦ç†
        """
        import time
        start_time = time.time()

        # æ¸¬å®šæŠ€è¡“ã®åˆ¤å®š
        if metadata and 'type' in metadata:
            spec_type = metadata['type']
        else:
            spec_type = self.detect_spectrum_type(x)

        logging.info(f"Detected spectrum type: {spec_type}")

        # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»
        bg_method = self.bg_methods.get(spec_type, 'snip')

        if bg_method == 'snip':
            bg = snip_background(y, iterations=40)
        elif bg_method == 'als':
            bg = als_baseline(y, lam=1e6, p=0.01)
        else:
            # ç°¡æ˜“ç·šå½¢ï¼ˆshirleyæœªå®Ÿè£…ã®å ´åˆï¼‰
            bg = np.linspace(y[0], y[-1], len(y))

        y_corrected = y - bg

        # é©å¿œçš„ãƒ”ãƒ¼ã‚¯æ¤œå‡º
        prominence = self.adaptive_prominence(y_corrected)
        peaks_idx, _ = find_peaks(y_corrected, prominence=prominence)

        # ãƒ”ãƒ¼ã‚¯æƒ…å ±ã‚’æ§‹é€ åŒ–
        peaks_info = []
        for idx in peaks_idx:
            peaks_info.append({
                'position': float(x[idx]),
                'intensity': float(y_corrected[idx]),
                'unit': '2Î¸(deg)' if spec_type == 'XRD' else 'cm-1'
            })

        processing_time = time.time() - start_time

        result = SpectrumResult(
            spectrum_type=spec_type,
            num_peaks=len(peaks_idx),
            peaks=peaks_info,
            processing_time=processing_time,
            background_method=bg_method
        )

        return result

    def batch_process(self, data_list: List[Dict],
                     output_file: str = 'results.json'):
        """
        ãƒãƒƒãƒå‡¦ç†

        Parameters:
        -----------
        data_list : list of dict
            å„è¦ç´ ã¯ {'x': array, 'y': array, 'metadata': dict}
        """
        results = []

        for i, data in enumerate(data_list, 1):
            try:
                logging.info(f"Processing spectrum {i}/{len(data_list)}")
                result = self.process_spectrum(
                    data['x'],
                    data['y'],
                    data.get('metadata')
                )
                results.append(asdict(result))

            except Exception as e:
                logging.error(f"Failed to process spectrum {i}: {e}")
                continue

        # JSONä¿å­˜
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=2)

        logging.info(f"Results saved to {output_file}")
        return results

<h1>ãƒ‡ãƒ¢å®Ÿè¡Œ</h1>
if __name__ == "__main__":
    processor = AutoSpectrumProcessor()

    # ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆ3ç¨®é¡ã®æ¸¬å®šï¼‰
    data_list = []

    # XRDãƒ‡ãƒ¼ã‚¿
    two_theta = np.linspace(20, 60, 400)
    xrd_y = (
        1000 * np.exp(-((two_theta - 28) ** 2) / 10) +
        1500 * np.exp(-((two_theta - 35) ** 2) / 8) +
        100 + np.random.normal(0, 30, len(two_theta))
    )
    data_list.append({
        'x': two_theta,
        'y': xrd_y,
        'metadata': {'type': 'XRD', 'sample': 'Fe2O3'}
    })

    # Ramanãƒ‡ãƒ¼ã‚¿
    raman_shift = np.linspace(200, 2000, 900)
    raman_y = (
        2000 * np.exp(-((raman_shift - 520) ** 2) / 100) +
        1500 * np.exp(-((raman_shift - 950) ** 2) / 150) +
        500 + np.random.normal(0, 50, len(raman_shift))
    )
    data_list.append({
        'x': raman_shift,
        'y': raman_y,
        'metadata': {'type': 'Raman', 'sample': 'Si'}
    })

    # ãƒãƒƒãƒå‡¦ç†å®Ÿè¡Œ
    results = processor.batch_process(data_list,
                                      output_file='spectrum_results.json')

    print("\n=== Processing Summary ===")
    for i, result in enumerate(results, 1):
        print(f"Spectrum {i}:")
        print(f"  Type: {result['spectrum_type']}")
        print(f"  Peaks detected: {result['num_peaks']}")
        print(f"  Processing time: {result['processing_time']:.3f}s")</code></pre>

<strong>çµæœï¼ˆJSONå‡ºåŠ›ä¾‹ï¼‰</strong>:
<pre><code class="language-json">[
  {
    "spectrum_type": "XRD",
    "num_peaks": 2,
    "peaks": [
      {"position": 28.05, "intensity": 1023.4, "unit": "2Î¸(deg)"},
      {"position": 35.01, "intensity": 1518.7, "unit": "2Î¸(deg)"}
    ],
    "processing_time": 0.045,
    "background_method": "snip"
  },
  {
    "spectrum_type": "Raman",
    "num_peaks": 2,
    "peaks": [
      {"position": 520.3, "intensity": 2015.6, "unit": "cm-1"},
      {"position": 949.8, "intensity": 1507.2, "unit": "cm-1"}
    ],
    "processing_time": 0.052,
    "background_method": "als"
  }
]</code></pre>

<strong>è©³ç´°ãªè§£èª¬</strong>:
1. <strong>è‡ªå‹•åˆ¤å®š</strong>: ãƒ‡ãƒ¼ã‚¿ç¯„å›²ã‹ã‚‰æ¸¬å®šæŠ€è¡“ã‚’æ¨å®šï¼ˆXRD: 10-80Â°ã€Raman: 200-2000 cmâ»Â¹ï¼‰
2. <strong>é©å¿œçš„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</strong>: S/Næ¯”ã‹ã‚‰prominenceã‚’è‡ªå‹•èª¿æ•´
3. <strong>æ§‹é€ åŒ–å‡ºåŠ›</strong>: JSONå½¢å¼ã§å¾Œç¶šè§£æã‚„ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç™»éŒ²ã«å¯¾å¿œ
4. <strong>ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°</strong>: å€‹åˆ¥ã‚¹ãƒšã‚¯ãƒˆãƒ«ã®å¤±æ•—ãŒãƒãƒƒãƒå…¨ä½“ã‚’åœæ­¢ã•ã›ãªã„

<strong>è¿½åŠ ã®æ¤œè¨äº‹é …</strong>:
- æ¸¬å®šæŠ€è¡“ã®åˆ¤å®šç²¾åº¦å‘ä¸Šï¼ˆæ©Ÿæ¢°å­¦ç¿’åˆ†é¡å™¨ã®å°å…¥ï¼‰
- ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ï¼ˆS3ã€GCSï¼‰ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
- Webãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã§ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å¯è¦–åŒ–
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼ˆMongoDBï¼‰ã¸ã®çµæœä¿å­˜

</details>

---

<h2>å‚è€ƒæ–‡çŒ®</h2>

1. Pecharsky, V. K., & Zavalij, P. Y. (2009). "Fundamentals of Powder Diffraction and Structural Characterization of Materials." Springer. ISBN: 978-0387095783

2. Briggs, D., & Seah, M. P. (1990). "Practical Surface Analysis by Auger and X-ray Photoelectron Spectroscopy." Wiley. ISBN: 978-0471920816

3. Ryan, C. G. et al. (1988). "SNIP, a statistics-sensitive background treatment for the quantitative analysis of PIXE spectra in geoscience applications." *Nuclear Instruments and Methods in Physics Research B*, 34(3), 396-402. DOI: [10.1016/0168-583X(88)90063-8](https://doi.org/10.1016/0168-583X(88)90063-8)

4. Eilers, P. H. C., & Boelens, H. F. M. (2005). "Baseline Correction with Asymmetric Least Squares Smoothing." *Leiden University Medical Centre Report*.

5. SciPy Documentation: Signal Processing. URL: [https://docs.scipy.org/doc/scipy/reference/signal.html](https://docs.scipy.org/doc/scipy/reference/signal.html)

---

<h2>ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³</h2>

<h3>å‰ã®ç« </h3>
<strong>[ç¬¬1ç« ï¼šå®Ÿé¨“ãƒ‡ãƒ¼ã‚¿è§£æã®åŸºç¤ â†](./chapter-1.md)</strong>

<h3>æ¬¡ã®ç« </h3>
<strong>[ç¬¬3ç« ï¼šç”»åƒãƒ‡ãƒ¼ã‚¿è§£æ â†’](./chapter-3.md)</strong>

<h3>ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡</h3>
<strong>[â† ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡ã«æˆ»ã‚‹](./index.md)</strong>

---

<h2>è‘—è€…æƒ…å ±</h2>

<strong>ä½œæˆè€…</strong>: AI Terakoya Content Team
<strong>ç›£ä¿®</strong>: Dr. Yusuke Hashimotoï¼ˆæ±åŒ—å¤§å­¦ï¼‰
<strong>ä½œæˆæ—¥</strong>: 2025-10-17
<strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³</strong>: 1.0

<strong>æ›´æ–°å±¥æ­´</strong>:
- 2025-10-17: v1.0 åˆç‰ˆå…¬é–‹

<strong>ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯</strong>:
- GitHub Issues: [ãƒªãƒã‚¸ãƒˆãƒªURL]/issues
- Email: yusuke.hashimoto.b8@tohoku.ac.jp

<strong>ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</strong>: Creative Commons BY 4.0

---

<strong>æ¬¡ã®ç« ã§å­¦ç¿’ã‚’ç¶šã‘ã¾ã—ã‚‡ã†ï¼</strong>
<div class="navigation">
    <a href="chapter-1.html" class="nav-button">â† ç¬¬1ç« </a>
    <a href="index.html" class="nav-button">ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡ã«æˆ»ã‚‹</a>
    <a href="chapter-3.html" class="nav-button">ç¬¬3ç«  â†’</a>
</div>
    </main>

    <footer>
        <p><strong>ä½œæˆè€…</strong>: AI Terakoya Content Team</p>
        <p><strong>ç›£ä¿®</strong>: Dr. Yusuke Hashimotoï¼ˆæ±åŒ—å¤§å­¦ï¼‰</p>
        <p><strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³</strong>: 1.0 | <strong>ä½œæˆæ—¥</strong>: 2025-10-17</p>
        <p><strong>ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</strong>: Creative Commons BY 4.0</p>
        <p>Â© 2025 AI Terakoya. All rights reserved.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const mermaidCodeBlocks = document.querySelectorAll('pre.codehilite code.language-mermaid, pre code.language-mermaid');

            mermaidCodeBlocks.forEach(function(codeBlock) {
                const pre = codeBlock.parentElement;
                const mermaidCode = codeBlock.textContent;

                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = mermaidCode.trim();

                pre.parentNode.replaceChild(mermaidDiv, pre);
            });

            if (typeof mermaid !== 'undefined') {
                mermaid.initialize({
                    startOnLoad: true,
                    theme: 'default'
                });
                mermaid.init(undefined, document.querySelectorAll('.mermaid'));
            }
        });
    </script>
</body>
</html>
