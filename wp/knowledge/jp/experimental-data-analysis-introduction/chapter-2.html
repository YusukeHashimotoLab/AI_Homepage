<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Á¨¨2Á´†Ôºö„Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„ÇøËß£Êûê - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>Á¨¨2Á´†Ôºö„Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„ÇøËß£Êûê</h1>
            <p class="subtitle">XRD„ÉªXPS„ÉªIR„ÉªRaman„ÅÆËá™ÂãïËß£Êûê - ÊßãÈÄ†„ÉªÁµÑÊàêÊÉÖÂ†±„ÅÆÊäΩÂá∫</p>
            <div class="meta">
                <span class="meta-item">üìñ Ë™≠‰∫ÜÊôÇÈñì: 25-30ÂàÜ</span>
                <span class="meta-item">üìä Èõ£ÊòìÂ∫¶: ‰∏≠Á¥ö</span>
                <span class="meta-item">üíª „Ç≥„Éº„Éâ‰æã: 11ÂÄã</span>
                <span class="meta-item">üìù ÊºîÁøíÂïèÈ°å: 3Âïè</span>
            </div>
        </div>
    </header>

    <main class="container">

<h1>Á¨¨2Á´†Ôºö„Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„ÇøËß£Êûê</h1>

<strong>XRD„ÉªXPS„ÉªIR„ÉªRaman„ÅÆËá™ÂãïËß£Êûê - ÊßãÈÄ†„ÉªÁµÑÊàêÊÉÖÂ†±„ÅÆÊäΩÂá∫</strong>

<h2>Â≠¶ÁøíÁõÆÊ®ô</h2>

„Åì„ÅÆÁ´†„ÇíË™≠„ÇÄ„Åì„Å®„Åß„ÄÅ‰ª•‰∏ã„ÇíÁøíÂæó„Åß„Åç„Åæ„ÅôÔºö

- ‚úÖ XRD„ÉªXPS„ÉªIR„ÉªRaman„Çπ„Éö„ÇØ„Éà„É´„ÅÆÁâπÂæ¥„ÇíÁêÜËß£„Åó„ÄÅÈÅ©Âàá„Å™ÂâçÂá¶ÁêÜ„ÇíÈÅ∏Êäû„Åß„Åç„Çã
- ‚úÖ „Éî„Éº„ÇØÊ§úÂá∫„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÇíÂÆüË£Ö„Åó„ÄÅ„Éî„Éº„ÇØ‰ΩçÁΩÆ„ÉªÂº∑Â∫¶„ÇíÂÆöÈáè„Åß„Åç„Çã
- ‚úÖ „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÊâãÊ≥ïÔºàÂ§öÈ†ÖÂºè„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„ÄÅSNIPÔºâ„Çí‰Ωø„ÅÑÂàÜ„Åë„Çâ„Çå„Çã
- ‚úÖ XRD„Éë„Çø„Éº„É≥„Åã„ÇâÂÆöÈáèÁõ∏ÂàÜÊûêÔºàRIRÊ≥ïÔºâ„ÇíÂÆüË°å„Åß„Åç„Çã
- ‚úÖ „Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê„Éë„Ç§„Éó„É©„Ç§„É≥„ÇíËá™ÂãïÂåñ„Åß„Åç„Çã

<strong>Ë™≠‰∫ÜÊôÇÈñì</strong>: 25-30ÂàÜ
<strong>„Ç≥„Éº„Éâ‰æã</strong>: 11ÂÄã
<strong>ÊºîÁøíÂïèÈ°å</strong>: 3Âïè

---

<h2>2.1 „Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„Çø„ÅÆÁâπÂæ¥„Å®ÂâçÂá¶ÁêÜÊà¶Áï•</h2>

<h3>ÂêÑÊ∏¨ÂÆöÊäÄË°ì„ÅÆÁâπÂæ¥</h3>

ÊùêÊñôÁßëÂ≠¶„ÅßÈ†ªÁπÅ„Å´‰ΩøÁî®„Åï„Çå„Çã4„Å§„ÅÆ„Çπ„Éö„ÇØ„Éà„É´Ê∏¨ÂÆöÊäÄË°ì„ÅÆÁâπÂæ¥„ÇíÁêÜËß£„Åô„Çã„Åì„Å®„ÅØ„ÄÅÈÅ©Âàá„Å™Ëß£ÊûêÊâãÊ≥ï„ÇíÈÅ∏Êäû„Åô„Çã‰∏ä„ÅßÈáçË¶Å„Åß„Åô„ÄÇ

| Ê∏¨ÂÆöÊäÄË°ì | Âæó„Çâ„Çå„ÇãÊÉÖÂ†± | „Éî„Éº„ÇØ„ÅÆÁâπÂæ¥ | ÂÖ∏ÂûãÁöÑ„Å™„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ |
|---------|------------|------------|----------------------|
| <strong>XRD</strong> | ÁµêÊô∂ÊßãÈÄ†„ÄÅÁõ∏ÂêåÂÆö | „Ç∑„É£„Éº„ÉóÔºàÂõûÊäò„Éî„Éº„ÇØÔºâ | ‰ΩéÂº∑Â∫¶„ÄÅÁ∑©„ÇÑ„Åã„Å™‰∏äÊòáÔºàÈùûÊô∂Ë≥™Ôºâ |
| <strong>XPS</strong> | ÂÖÉÁ¥†ÁµÑÊàê„ÄÅÂåñÂ≠¶Áä∂ÊÖã | ÈùûÂØæÁß∞Ôºà„Çπ„Éî„É≥ËªåÈÅìÂàÜË£ÇÔºâ | „Ç∑„É£„Éº„É™„ÉºÂûãÔºàÈùûÂºæÊÄßÊï£‰π±Ôºâ |
| <strong>IR</strong> | ÂàÜÂ≠êÊåØÂãï„ÄÅÂÆòËÉΩÂü∫ | „Ç∑„É£„Éº„Éó„Äú„Éñ„É≠„Éº„Éâ | „Åª„Åº„Éï„É©„ÉÉ„ÉàÔºàÈÄèÈÅéÊ≥ïÔºâ |
| <strong>Raman</strong> | ÁµêÊô∂ÊÄß„ÄÅÂàÜÂ≠êÊåØÂãï | „Ç∑„É£„Éº„ÉóÔºàÁµêÊô∂ÊÄßÈ´òÔºâ | ËõçÂÖâ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÔºàÊúâÊ©üÁâ©Ôºâ |

<h3>„Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê„ÅÆÂÖ∏ÂûãÁöÑ„ÉØ„Éº„ÇØ„Éï„É≠„Éº</h3>

<div class="mermaid">flowchart TD
    A[„Çπ„Éö„ÇØ„Éà„É´Ê∏¨ÂÆö] --> B[„Éá„Éº„ÇøË™≠„ÅøËæº„Åø]
    B --> C[„Éé„Ç§„Ç∫Èô§Âéª]
    C --> D[„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª]
    D --> E[„Éî„Éº„ÇØÊ§úÂá∫]
    E --> F[„Éî„Éº„ÇØ„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞]
    F --> G[ÂÆöÈáèËß£Êûê]
    G --> H[ÁµêÊûúÂèØË¶ñÂåñ]

    style A fill:#e3f2fd
    style D fill:#fff3e0
    style E fill:#f3e5f5
    style G fill:#e8f5e9
    style H fill:#fce4ec</div>

<strong>ÂêÑ„Çπ„ÉÜ„ÉÉ„Éó„ÅÆÁõÆÁöÑ</strong>:
1. <strong>„Éé„Ç§„Ç∫Èô§Âéª</strong>: S/NÊØîÂêë‰∏äÔºàÁ¨¨1Á´†„ÅßÂ≠¶ÁøíÊ∏à„ÅøÔºâ
2. <strong>„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª</strong>: „Éô„Éº„Çπ„É©„Ç§„É≥Ë£úÊ≠£
3. <strong>„Éî„Éº„ÇØÊ§úÂá∫</strong>: „Éî„Éº„ÇØ‰ΩçÁΩÆ„ÅÆËá™ÂãïÂêåÂÆö
4. <strong>„Éî„Éº„ÇØ„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞</strong>: „Éî„Éº„ÇØÂΩ¢Áä∂„ÅÆ„É¢„Éá„É´Âåñ
5. <strong>ÂÆöÈáèËß£Êûê</strong>: ÁµÑÊàê„ÉªÁõ∏ÂàÜÁéá„ÅÆÁÆóÂá∫

---

<h2>2.2 „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÊâãÊ≥ï</h2>

<h3>Â§öÈ†ÖÂºè„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞Ê≥ï</h3>

ÊúÄ„ÇÇ„Ç∑„É≥„Éó„É´„Å™ÊâãÊ≥ï„Åß„ÄÅ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÇíÂ§öÈ†ÖÂºè„ÅßËøë‰ºº„Åó„ÄÅÂÖÉ„Éá„Éº„Çø„Åã„ÇâÊ∏õÁÆó„Åó„Åæ„Åô„ÄÇ

<strong>„Ç≥„Éº„Éâ‰æã1: Â§öÈ†ÖÂºè„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª</strong>

<pre><code class="language-python"><h1>XRD„Éë„Çø„Éº„É≥„ÅÆ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª</h1>
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter

<h1>„Çµ„É≥„Éó„É´XRD„Éá„Éº„ÇøÁîüÊàê</h1>
np.random.seed(42)
two_theta = np.linspace(10, 80, 700)

<h1>„Éî„Éº„ÇØÊàêÂàÜ</h1>
peaks = (
    1000 * np.exp(-((two_theta - 28) ** 2) / 10) +
    1500 * np.exp(-((two_theta - 32) ** 2) / 8) +
    800 * np.exp(-((two_theta - 47) ** 2) / 12)
)

<h1>„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÔºàÈùûÊô∂Ë≥™„Éè„É≠„ÉºÔºâ</h1>
background = (
    100 +
    50 * np.sin(two_theta / 10) +
    30 * (two_theta / 80) ** 2
)

<h1>„Éé„Ç§„Ç∫</h1>
noise = np.random.normal(0, 20, len(two_theta))

<h1>ÂÖ®‰Ωì„ÅÆ‰ø°Âè∑</h1>
intensity = peaks + background + noise

<h1>Â§öÈ†ÖÂºè„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„Å´„Çà„Çã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊé®ÂÆö</h1>
poly_degree = 5
coeffs = np.polyfit(two_theta, intensity, poly_degree)
background_fit = np.polyval(coeffs, two_theta)

<h1>„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊ∏õÁÆó</h1>
intensity_corrected = intensity - background_fit

<h1>ÂèØË¶ñÂåñ</h1>
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

<h1>ÂÖÉ„Éá„Éº„Çø</h1>
axes[0, 0].plot(two_theta, intensity, linewidth=1)
axes[0, 0].set_xlabel('2Œ∏ (degree)')
axes[0, 0].set_ylabel('Intensity')
axes[0, 0].set_title('Raw XRD Pattern')
axes[0, 0].grid(True, alpha=0.3)

<h1>„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞ÁµêÊûú</h1>
axes[0, 1].plot(two_theta, intensity, label='Raw data', alpha=0.5)
axes[0, 1].plot(two_theta, background_fit,
                label=f'Polynomial fit (deg={poly_degree})',
                linewidth=2, color='red')
axes[0, 1].set_xlabel('2Œ∏ (degree)')
axes[0, 1].set_ylabel('Intensity')
axes[0, 1].set_title('Background Estimation')
axes[0, 1].legend()
axes[0, 1].grid(True, alpha=0.3)

<h1>Ë£úÊ≠£Âæå</h1>
axes[1, 0].plot(two_theta, intensity_corrected, linewidth=1,
                color='green')
axes[1, 0].axhline(y=0, color='r', linestyle='--', alpha=0.5)
axes[1, 0].set_xlabel('2Œ∏ (degree)')
axes[1, 0].set_ylabel('Intensity')
axes[1, 0].set_title('After Background Subtraction')
axes[1, 0].grid(True, alpha=0.3)

<h1>Áúü„ÅÆ„Éî„Éº„ÇØ„Å®„ÅÆÊØîËºÉ</h1>
axes[1, 1].plot(two_theta, peaks, label='True peaks',
                linewidth=2, alpha=0.7)
axes[1, 1].plot(two_theta, intensity_corrected,
                label='Corrected data', linewidth=1.5, alpha=0.7)
axes[1, 1].set_xlabel('2Œ∏ (degree)')
axes[1, 1].set_ylabel('Intensity')
axes[1, 1].set_title('Comparison with True Peaks')
axes[1, 1].legend()
axes[1, 1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f"Â§öÈ†ÖÂºèÊ¨°Êï∞: {poly_degree}")
print(f"„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂπ≥ÂùáÂÄ§: {background_fit.mean():.1f}")
print(f"Ë£úÊ≠£Âæå„ÅÆÂπ≥ÂùáÂÄ§: {intensity_corrected.mean():.1f}")</code></pre>

<strong>Âá∫Âäõ</strong>:
<pre><code>Â§öÈ†ÖÂºèÊ¨°Êï∞: 5
„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂπ≥ÂùáÂÄ§: 150.3
Ë£úÊ≠£Âæå„ÅÆÂπ≥ÂùáÂÄ§: 0.5</code></pre>

<strong>‰Ωø„ÅÑÂàÜ„Åë„Ç¨„Ç§„Éâ</strong>:
- <strong>‰ΩéÊ¨°Ôºà2-3Ê¨°Ôºâ</strong>: Á∑©„ÇÑ„Åã„Å™„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÔºàIR„ÄÅXPSÔºâ
- <strong>‰∏≠Ê¨°Ôºà4-6Ê¨°Ôºâ</strong>: „ÇÑ„ÇÑË§áÈõë„Å™ÂΩ¢Áä∂ÔºàXRDÈùûÊô∂Ë≥™„Éè„É≠„ÉºÔºâ
- <strong>È´òÊ¨°Ôºà>7Ê¨°Ôºâ</strong>: Ë§áÈõë„Å™ÂΩ¢Áä∂ÔºàÊ≥®ÊÑèÔºö„Ç™„Éº„Éê„Éº„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„ÅÆ„É™„Çπ„ÇØÔºâ

<h3>SNIPÊ≥ïÔºàStatistics-sensitive Non-linear Iterative Peak-clippingÔºâ</h3>

„Éî„Éº„ÇØÊÉÖÂ†±„Çí‰øùÊåÅ„Åó„Å™„Åå„Çâ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÇíÊé®ÂÆö„Åô„ÇãÈ´òÂ∫¶„Å™ÊâãÊ≥ï„Åß„Åô„ÄÇ

<strong>„Ç≥„Éº„Éâ‰æã2: SNIPÊ≥ï„Å´„Çà„Çã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª</strong>

<pre><code class="language-python">def snip_background(spectrum, iterations=30):
    """
    SNIPÊ≥ï„Å´„Çà„Çã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊé®ÂÆö

    Parameters:
    -----------
    spectrum : array-like
        ÂÖ•Âäõ„Çπ„Éö„ÇØ„Éà„É´
    iterations : int
        „Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥ÂõûÊï∞Ôºà„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅÆÂπÖ„Å´ÂØæÂøúÔºâ

    Returns:
    --------
    background : array-like
        Êé®ÂÆö„Åï„Çå„Åü„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ
    """
    spectrum = np.array(spectrum, dtype=float)
    background = np.copy(spectrum)

    for i in range(1, iterations + 1):
        # Â∑¶Âè≥„ÅÆÂÄ§„Å®„ÅÆÊØîËºÉ
        for j in range(i, len(background) - i):
            v1 = (background[j - i] + background[j + i]) / 2
            v2 = background[j]
            background[j] = min(v1, v2)

    return background

<h1>SNIPÊ≥ï„ÅÆÈÅ©Áî®</h1>
snip_bg = snip_background(intensity, iterations=50)
intensity_snip = intensity - snip_bg

<h1>ÂèØË¶ñÂåñ</h1>
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

<h1>ÂÖÉ„Éá„Éº„Çø„Å®SNIP„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ</h1>
axes[0].plot(two_theta, intensity, label='Raw data', alpha=0.6)
axes[0].plot(two_theta, snip_bg, label='SNIP background',
             linewidth=2, color='orange')
axes[0].set_xlabel('2Œ∏ (degree)')
axes[0].set_ylabel('Intensity')
axes[0].set_title('SNIP Background Estimation')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

<h1>SNIPË£úÊ≠£Âæå</h1>
axes[1].plot(two_theta, intensity_snip, linewidth=1.5,
             color='purple')
axes[1].axhline(y=0, color='r', linestyle='--', alpha=0.5)
axes[1].set_xlabel('2Œ∏ (degree)')
axes[1].set_ylabel('Intensity')
axes[1].set_title('After SNIP Subtraction')
axes[1].grid(True, alpha=0.3)

<h1>Â§öÈ†ÖÂºè vs SNIP ÊØîËºÉ</h1>
axes[2].plot(two_theta, intensity_corrected,
             label='Polynomial', alpha=0.7, linewidth=1.5)
axes[2].plot(two_theta, intensity_snip,
             label='SNIP', alpha=0.7, linewidth=1.5)
axes[2].set_xlabel('2Œ∏ (degree)')
axes[2].set_ylabel('Intensity')
axes[2].set_title('Polynomial vs SNIP')
axes[2].legend()
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f"SNIP „Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥ÂõûÊï∞: 50")
print(f"Â§öÈ†ÖÂºèÊ≥ï„ÅÆÊÆãÂ∑Æ: {np.std(intensity_corrected - peaks):.2f}")
print(f"SNIPÊ≥ï„ÅÆÊÆãÂ∑Æ: {np.std(intensity_snip - peaks):.2f}")</code></pre>

<strong>SNIPÊ≥ï„ÅÆÂà©ÁÇπ</strong>:
- „Éî„Éº„ÇØ„ÅÆÂΩ±Èüø„ÇíÂèó„Åë„Å´„Åè„ÅÑ
- Ë§áÈõë„Å™„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂΩ¢Áä∂„Å´„ÇÇÂØæÂøú
- „Éë„É©„É°„Éº„ÇøË™øÊï¥„ÅåÁõ¥ÊÑüÁöÑÔºàiterations = „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅÆÂπÖÔºâ

---

<h2>2.3 „Éî„Éº„ÇØÊ§úÂá∫„Ç¢„É´„Ç¥„É™„Ç∫„É†</h2>

<h3>scipy.signal.find_peaks „Å´„Çà„ÇãÂü∫Êú¨ÁöÑ„Å™„Éî„Éº„ÇØÊ§úÂá∫</h3>

<strong>„Ç≥„Éº„Éâ‰æã3: „Éî„Éº„ÇØÊ§úÂá∫„ÅÆÂü∫Êú¨</strong>

<pre><code class="language-python">from scipy.signal import find_peaks

<h1>„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÊ∏à„Åø„Éá„Éº„Çø„Åß„Éî„Éº„ÇØÊ§úÂá∫</h1>
peaks_idx, properties = find_peaks(
    intensity_snip,
    height=100,        # ÊúÄ‰Ωé„Éî„Éº„ÇØÈ´ò„Åï
    prominence=80,     # ÂçìË∂äÂ∫¶ÔºàÂë®Âõ≤„Å®„ÅÆÈ´ò‰ΩéÂ∑ÆÔºâ
    distance=10,       # ÊúÄÂ∞è„Éî„Éº„ÇØÈñìÈöîÔºà„Éá„Éº„ÇøÁÇπÊï∞Ôºâ
    width=3           # ÊúÄÂ∞è„Éî„Éº„ÇØÂπÖ
)

peak_positions = two_theta[peaks_idx]
peak_heights = intensity_snip[peaks_idx]

<h1>ÂèØË¶ñÂåñ</h1>
plt.figure(figsize=(14, 6))

plt.plot(two_theta, intensity_snip, linewidth=1.5,
         label='Background-corrected')
plt.plot(peak_positions, peak_heights, 'rx',
         markersize=12, markeredgewidth=2, label='Detected peaks')

<h1>„Éî„Éº„ÇØ‰ΩçÁΩÆ„Å´„É©„Éô„É´</h1>
for pos, height in zip(peak_positions, peak_heights):
    plt.annotate(f'{pos:.1f}¬∞',
                xy=(pos, height),
                xytext=(pos, height + 100),
                ha='center',
                fontsize=9,
                bbox=dict(boxstyle='round,pad=0.3',
                         facecolor='yellow', alpha=0.5))

plt.xlabel('2Œ∏ (degree)')
plt.ylabel('Intensity')
plt.title('Peak Detection Results')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

print("=== Ê§úÂá∫„Åï„Çå„Åü„Éî„Éº„ÇØ ===")
for i, (pos, height) in enumerate(zip(peak_positions,
                                       peak_heights), 1):
    print(f"„Éî„Éº„ÇØ {i}: 2Œ∏ = {pos:.2f}¬∞, Âº∑Â∫¶ = {height:.1f}")</code></pre>

<strong>Âá∫Âäõ</strong>:
<pre><code>=== Ê§úÂá∫„Åï„Çå„Åü„Éî„Éº„ÇØ ===
„Éî„Éº„ÇØ 1: 2Œ∏ = 28.04¬∞, Âº∑Â∫¶ = 1021.3
„Éî„Éº„ÇØ 2: 2Œ∏ = 32.05¬∞, Âº∑Â∫¶ = 1512.7
„Éî„Éº„ÇØ 3: 2Œ∏ = 47.07¬∞, Âº∑Â∫¶ = 798.5</code></pre>

<h3>„Éî„Éº„ÇØÊ§úÂá∫„Éë„É©„É°„Éº„Çø„ÅÆÊúÄÈÅ©Âåñ</h3>

<strong>„Ç≥„Éº„Éâ‰æã4: „Éë„É©„É°„Éº„ÇøÊÑüÂ∫¶Ëß£Êûê</strong>

<pre><code class="language-python"><h1>Áï∞„Å™„Çã„Éë„É©„É°„Éº„Çø„Åß„Éî„Éº„ÇØÊ§úÂá∫</h1>
prominence_values = [30, 50, 80, 100]

fig, axes = plt.subplots(2, 2, figsize=(14, 10))
axes = axes.ravel()

for i, prom in enumerate(prominence_values):
    peaks_idx, _ = find_peaks(
        intensity_snip,
        prominence=prom,
        distance=5
    )

    axes[i].plot(two_theta, intensity_snip, linewidth=1.5)
    axes[i].plot(two_theta[peaks_idx], intensity_snip[peaks_idx],
                'rx', markersize=10, markeredgewidth=2)
    axes[i].set_xlabel('2Œ∏ (degree)')
    axes[i].set_ylabel('Intensity')
    axes[i].set_title(f'Prominence = {prom} ({len(peaks_idx)} peaks)')
    axes[i].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("=== „Éë„É©„É°„Éº„ÇøÊÑüÂ∫¶ ===")
for prom in prominence_values:
    peaks_idx, _ = find_peaks(intensity_snip, prominence=prom)
    print(f"Prominence = {prom:3d}: {len(peaks_idx)} peaks detected")</code></pre>

<h3>„Éî„Éº„ÇØ„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞Ôºà„Ç¨„Ç¶„Ç∑„Ç¢„É≥„Éª„É≠„Éº„É¨„É≥„ÉÑÔºâ</h3>

<strong>„Ç≥„Éº„Éâ‰æã5: „Ç¨„Ç¶„Ç∑„Ç¢„É≥„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞</strong>

<pre><code class="language-python">from scipy.optimize import curve_fit

def gaussian(x, amplitude, center, sigma):
    """„Ç¨„Ç¶„Ç∑„Ç¢„É≥Èñ¢Êï∞"""
    return amplitude * np.exp(-((x - center) <strong> 2) / (2 * sigma </strong> 2))

def lorentzian(x, amplitude, center, gamma):
    """„É≠„Éº„É¨„É≥„ÉÑÈñ¢Êï∞"""
    return amplitude * gamma<strong>2 / ((x - center)</strong>2 + gamma**2)

<h1>ÊúÄÂàù„ÅÆ„Éî„Éº„ÇØÂë®Ëæ∫„ÇíÊäΩÂá∫</h1>
peak_region_mask = (two_theta > 26) & (two_theta < 30)
x_data = two_theta[peak_region_mask]
y_data = intensity_snip[peak_region_mask]

<h1>„Ç¨„Ç¶„Ç∑„Ç¢„É≥„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞</h1>
initial_guess = [1000, 28, 1]  # [amplitude, center, sigma]
params_gauss, _ = curve_fit(gaussian, x_data, y_data,
                             p0=initial_guess)

<h1>„É≠„Éº„É¨„É≥„ÉÑ„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞</h1>
initial_guess_lor = [1000, 28, 0.5]  # [amplitude, center, gamma]
params_lor, _ = curve_fit(lorentzian, x_data, y_data,
                          p0=initial_guess_lor)

<h1>„Éï„Ç£„ÉÉ„ÉàÁµêÊûú</h1>
x_fit = np.linspace(x_data.min(), x_data.max(), 200)
y_gauss = gaussian(x_fit, *params_gauss)
y_lor = lorentzian(x_fit, *params_lor)

<h1>ÂèØË¶ñÂåñ</h1>
plt.figure(figsize=(12, 6))

plt.plot(x_data, y_data, 'o', label='Data', markersize=6)
plt.plot(x_fit, y_gauss, '-', linewidth=2,
         label=f'Gaussian (œÉ={params_gauss[2]:.2f})')
plt.plot(x_fit, y_lor, '--', linewidth=2,
         label=f'Lorentzian (Œ≥={params_lor[2]:.2f})')

plt.xlabel('2Œ∏ (degree)')
plt.ylabel('Intensity')
plt.title('Peak Fitting: Gaussian vs Lorentzian')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

print("=== „Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞ÁµêÊûú ===")
print(f"„Ç¨„Ç¶„Ç∑„Ç¢„É≥:")
print(f"  ‰∏≠ÂøÉ‰ΩçÁΩÆ: {params_gauss[1]:.3f}¬∞")
print(f"  ÊåØÂπÖ: {params_gauss[0]:.1f}")
print(f"  œÉ: {params_gauss[2]:.3f}¬∞")
print(f"\n„É≠„Éº„É¨„É≥„ÉÑ:")
print(f"  ‰∏≠ÂøÉ‰ΩçÁΩÆ: {params_lor[1]:.3f}¬∞")
print(f"  ÊåØÂπÖ: {params_lor[0]:.1f}")
print(f"  Œ≥: {params_lor[2]:.3f}¬∞")</code></pre>

---

<h2>2.4 XPS „Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê</h2>

<h3>„Ç∑„É£„Éº„É™„ÉºÂûã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª</h3>

XPS„Çπ„Éö„ÇØ„Éà„É´„ÅØÈùûÂºæÊÄßÊï£‰π±„Å´„Çà„ÇãÁâπÂæ¥ÁöÑ„Å™„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÇíÊåÅ„Å°„Åæ„Åô„ÄÇ

<strong>„Ç≥„Éº„Éâ‰æã6: „Ç∑„É£„Éº„É™„Éº„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ</strong>

<pre><code class="language-python">def shirley_background(x, y, tol=1e-5, max_iter=50):
    """
    „Ç∑„É£„Éº„É™„ÉºÂûã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊé®ÂÆö

    Parameters:
    -----------
    x : array-like
        „Ç®„Éç„É´„ÇÆ„ÉºËª∏ÔºàÈôçÈ†Ü„ÇíÊé®Â•®Ôºâ
    y : array-like
        Âº∑Â∫¶
    tol : float
        ÂèéÊùüÂà§ÂÆöÈñæÂÄ§
    max_iter : int
        ÊúÄÂ§ß„Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥ÂõûÊï∞

    Returns:
    --------
    background : array-like
        „Ç∑„É£„Éº„É™„Éº„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ
    """
    # „Éá„Éº„Çø„ÅÆÊ∫ñÂÇô
    y = np.array(y, dtype=float)
    background = np.zeros_like(y)

    # ‰∏°Á´Ø„ÅÆÂÄ§
    y_min = min(y[0], y[-1])
    y_max = max(y[0], y[-1])

    # ÂàùÊúü„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÔºàÁ∑öÂΩ¢Ôºâ
    background = np.linspace(y[0], y[-1], len(y))

    # „Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥
    for iteration in range(max_iter):
        background_old = background.copy()

        # Á¥ØÁ©çÂíå„Çí‰ΩøÁî®
        cumsum = np.cumsum(y - background)
        total = cumsum[-1]

        if total == 0:
            break

        # Êñ∞„Åó„ÅÑ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ
        background = y[-1] + (y[0] - y[-1]) * cumsum / total

        # ÂèéÊùüÂà§ÂÆö
        if np.max(np.abs(background - background_old)) < tol:
            break

    return background

<h1>XPS„Çµ„É≥„Éó„É´„Éá„Éº„ÇøÁîüÊàêÔºàC 1s „Çπ„Éö„ÇØ„Éà„É´Ôºâ</h1>
binding_energy = np.linspace(280, 295, 300)[::-1]  # ÈôçÈ†Ü
xps_peak = 5000 * np.exp(-((binding_energy - 285) ** 2) / 2)
shirley_bg = np.linspace(500, 200, len(binding_energy))
xps_spectrum = xps_peak + shirley_bg + \
               np.random.normal(0, 50, len(binding_energy))

<h1>„Ç∑„É£„Éº„É™„Éº„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊé®ÂÆö</h1>
shirley_bg_calc = shirley_background(binding_energy, xps_spectrum)

<h1>„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊ∏õÁÆó</h1>
xps_corrected = xps_spectrum - shirley_bg_calc

<h1>ÂèØË¶ñÂåñ</h1>
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

<h1>XPSÁîü„Éá„Éº„Çø</h1>
axes[0].plot(binding_energy, xps_spectrum, linewidth=1.5)
axes[0].set_xlabel('Binding Energy (eV)')
axes[0].set_ylabel('Intensity (CPS)')
axes[0].set_title('Raw XPS Spectrum (C 1s)')
axes[0].invert_xaxis()
axes[0].grid(True, alpha=0.3)

<h1>„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊé®ÂÆö</h1>
axes[1].plot(binding_energy, xps_spectrum,
             label='Raw data', alpha=0.6)
axes[1].plot(binding_energy, shirley_bg_calc,
             label='Shirley background',
             linewidth=2, color='red')
axes[1].set_xlabel('Binding Energy (eV)')
axes[1].set_ylabel('Intensity (CPS)')
axes[1].set_title('Shirley Background Estimation')
axes[1].invert_xaxis()
axes[1].legend()
axes[1].grid(True, alpha=0.3)

<h1>Ë£úÊ≠£Âæå</h1>
axes[2].plot(binding_energy, xps_corrected,
             linewidth=1.5, color='green')
axes[2].set_xlabel('Binding Energy (eV)')
axes[2].set_ylabel('Intensity (CPS)')
axes[2].set_title('After Shirley Subtraction')
axes[2].invert_xaxis()
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("=== „Ç∑„É£„Éº„É™„Éº„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª ===")
print(f"„Ç®„Éç„É´„ÇÆ„ÉºÁØÑÂõ≤: {binding_energy.max():.1f} - "
      f"{binding_energy.min():.1f} eV")
print(f"„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈ´ò„ÅïÔºàÈ´òBEÂÅ¥Ôºâ: {shirley_bg_calc[0]:.1f}")
print(f"„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈ´ò„ÅïÔºà‰ΩéBEÂÅ¥Ôºâ: {shirley_bg_calc[-1]:.1f}")</code></pre>

---

<h2>2.5 IR„ÉªRaman„Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê</h2>

<h3>„Éô„Éº„Çπ„É©„Ç§„É≥Ë£úÊ≠£ÔºàAsymmetric Least SquaresÊ≥ïÔºâ</h3>

IR„ÉªRaman„Çπ„Éö„ÇØ„Éà„É´„ÅÆËõçÂÖâ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª„Å´ÊúâÂäπ„Åß„Åô„ÄÇ

<strong>„Ç≥„Éº„Éâ‰æã7: ALSÊ≥ï„Å´„Çà„Çã„Éô„Éº„Çπ„É©„Ç§„É≥Ë£úÊ≠£</strong>

<pre><code class="language-python">from scipy import sparse
from scipy.sparse.linalg import spsolve

def als_baseline(y, lam=1e5, p=0.01, niter=10):
    """
    Asymmetric Least SquaresÊ≥ï„Å´„Çà„Çã„Éô„Éº„Çπ„É©„Ç§„É≥Êé®ÂÆö

    Parameters:
    -----------
    y : array-like
        „Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„Çø
    lam : float
        Âπ≥ÊªëÂåñ„Éë„É©„É°„Éº„ÇøÔºàÂ§ß„Åç„ÅÑ„Åª„Å©Êªë„Çâ„ÅãÔºâ
    p : float
        ÈùûÂØæÁß∞„Éë„É©„É°„Éº„ÇøÔºà0-1„ÄÅÂ∞è„Åï„ÅÑ„Åª„Å©„Éî„Éº„ÇØ„ÇíÈÅø„Åë„ÇãÔºâ
    niter : int
        „Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥ÂõûÊï∞

    Returns:
    --------
    baseline : array-like
        Êé®ÂÆö„Åï„Çå„Åü„Éô„Éº„Çπ„É©„Ç§„É≥
    """
    L = len(y)
    D = sparse.diags([1, -2, 1], [0, -1, -2], shape=(L, L-2))
    w = np.ones(L)

    for i in range(niter):
        W = sparse.spdiags(w, 0, L, L)
        Z = W + lam * D.dot(D.transpose())
        z = spsolve(Z, w * y)
        w = p * (y > z) + (1 - p) * (y < z)

    return z

<h1>Raman„Çµ„É≥„Éó„É´„Éá„Éº„ÇøÁîüÊàê</h1>
raman_shift = np.linspace(200, 2000, 900)
raman_peaks = (
    3000 * np.exp(-((raman_shift - 520) ** 2) / 100) +
    2000 * np.exp(-((raman_shift - 950) ** 2) / 200) +
    1500 * np.exp(-((raman_shift - 1350) ** 2) / 150)
)
fluorescence_bg = 500 + 0.5 * raman_shift + \
                  0.0005 * (raman_shift - 1000) ** 2
raman_spectrum = raman_peaks + fluorescence_bg + \
                 np.random.normal(0, 50, len(raman_shift))

<h1>ALSÊ≥ïÈÅ©Áî®</h1>
als_bg = als_baseline(raman_spectrum, lam=1e6, p=0.01)
raman_corrected = raman_spectrum - als_bg

<h1>ÂèØË¶ñÂåñ</h1>
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

<h1>Áîü„Éá„Éº„Çø</h1>
axes[0].plot(raman_shift, raman_spectrum, linewidth=1.5)
axes[0].set_xlabel('Raman Shift (cm‚Åª¬π)')
axes[0].set_ylabel('Intensity (a.u.)')
axes[0].set_title('Raw Raman Spectrum')
axes[0].grid(True, alpha=0.3)

<h1>„Éô„Éº„Çπ„É©„Ç§„É≥Êé®ÂÆö</h1>
axes[1].plot(raman_shift, raman_spectrum,
             label='Raw data', alpha=0.6)
axes[1].plot(raman_shift, als_bg,
             label='ALS baseline', linewidth=2, color='red')
axes[1].set_xlabel('Raman Shift (cm‚Åª¬π)')
axes[1].set_ylabel('Intensity (a.u.)')
axes[1].set_title('ALS Baseline Estimation')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

<h1>Ë£úÊ≠£Âæå</h1>
axes[2].plot(raman_shift, raman_corrected,
             linewidth=1.5, color='purple')
axes[2].set_xlabel('Raman Shift (cm‚Åª¬π)')
axes[2].set_ylabel('Intensity (a.u.)')
axes[2].set_title('After ALS Subtraction')
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("=== ALS „Éô„Éº„Çπ„É©„Ç§„É≥Ë£úÊ≠£ ===")
print(f"Âπ≥ÊªëÂåñ„Éë„É©„É°„Éº„Çø (Œª): 1e6")
print(f"ÈùûÂØæÁß∞„Éë„É©„É°„Éº„Çø (p): 0.01")</code></pre>

---

<h2>2.6 ÂÆöÈáèÁõ∏ÂàÜÊûêÔºàXRD-RIRÊ≥ïÔºâ</h2>

<h3>Reference Intensity RatioÔºàRIRÔºâÊ≥ï</h3>

Ë§áÊï∞Áõ∏„ÇíÂê´„ÇÄXRD„Éë„Çø„Éº„É≥„Åã„Çâ„ÄÅÂêÑÁõ∏„ÅÆÈáçÈáèÂàÜÁéá„ÇíÁÆóÂá∫„Åó„Åæ„Åô„ÄÇ

<strong>„Ç≥„Éº„Éâ‰æã8: RIRÊ≥ï„Å´„Çà„ÇãÂÆöÈáèÁõ∏ÂàÜÊûê</strong>

<pre><code class="language-python"><h1>2Áõ∏Á≥ª„ÅÆXRD„Éë„Çø„Éº„É≥ÁîüÊàê</h1>
two_theta = np.linspace(10, 80, 700)

<h1>Áõ∏AÔºà‰æãÔºöŒ±-Fe2O3„ÄÅ‰∏ª„Éî„Éº„ÇØ: 33.2¬∞Ôºâ</h1>
phase_A = (
    2000 * np.exp(-((two_theta - 33.2) ** 2) / 15) +
    1200 * np.exp(-((two_theta - 35.6) ** 2) / 10) +
    800 * np.exp(-((two_theta - 54.1) ** 2) / 12)
)

<h1>Áõ∏BÔºà‰æãÔºöFe3O4„ÄÅ‰∏ª„Éî„Éº„ÇØ: 35.5¬∞Ôºâ</h1>
phase_B = (
    1500 * np.exp(-((two_theta - 35.5) ** 2) / 18) +
    1000 * np.exp(-((two_theta - 30.1) ** 2) / 12) +
    600 * np.exp(-((two_theta - 62.7) ** 2) / 14)
)

<h1>Ê∑∑Âêà„Éë„Çø„Éº„É≥ÔºàÁõ∏A:Áõ∏B = 70:30 wt%Ôºâ</h1>
ratio_A = 0.7
ratio_B = 0.3
mixed_pattern = ratio_A * phase_A + ratio_B * phase_B + \
                np.random.normal(0, 30, len(two_theta))

<h1>RIRÂÄ§ÔºàÊñáÁåÆÂÄ§„ÄÅ„Ç≥„É©„É≥„ÉÄ„É†„Å´ÂØæ„Åô„ÇãÁõ∏ÂØæÂÄ§Ôºâ</h1>
RIR_A = 3.5  # Œ±-Fe2O3„ÅÆRIR
RIR_B = 2.8  # Fe3O4„ÅÆRIR

<h1>‰∏ª„Éî„Éº„ÇØÂº∑Â∫¶Ê∏¨ÂÆö</h1>
<h1>Áõ∏A„ÅÆ‰∏ª„Éî„Éº„ÇØÔºà33.2¬∞‰ªòËøëÔºâ</h1>
peak_A_idx = np.argmax(mixed_pattern[(two_theta > 32) &
                                     (two_theta < 34)])
I_A = mixed_pattern[(two_theta > 32) & (two_theta < 34)][peak_A_idx]

<h1>Áõ∏B„ÅÆ‰∏ª„Éî„Éº„ÇØÔºà35.5¬∞‰ªòËøëÔºâ</h1>
peak_B_idx = np.argmax(mixed_pattern[(two_theta > 34.5) &
                                     (two_theta < 36)])
I_B = mixed_pattern[(two_theta > 34.5) & (two_theta < 36)][peak_B_idx]

<h1>RIRÊ≥ï„Å´„Çà„ÇãÈáçÈáèÂàÜÁéáË®àÁÆó</h1>
<h1>W_A / W_B = (I_A / I_B) * (RIR_B / RIR_A)</h1>
ratio_calc = (I_A / I_B) * (RIR_B / RIR_A)

<h1>Ê≠£Ë¶èÂåñ</h1>
W_A_calc = ratio_calc / (1 + ratio_calc)
W_B_calc = 1 - W_A_calc

<h1>ÂèØË¶ñÂåñ</h1>
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

<h1>Ê∑∑Âêà„Éë„Çø„Éº„É≥</h1>
axes[0, 0].plot(two_theta, mixed_pattern, linewidth=1.5)
axes[0, 0].set_xlabel('2Œ∏ (degree)')
axes[0, 0].set_ylabel('Intensity')
axes[0, 0].set_title('Mixed XRD Pattern (Phase A + B)')
axes[0, 0].grid(True, alpha=0.3)

<h1>ÂêÑÁõ∏„ÅÆÂØÑ‰∏é</h1>
axes[0, 1].plot(two_theta, ratio_A * phase_A,
                label='Phase A (70%)', linewidth=1.5)
axes[0, 1].plot(two_theta, ratio_B * phase_B,
                label='Phase B (30%)', linewidth=1.5)
axes[0, 1].set_xlabel('2Œ∏ (degree)')
axes[0, 1].set_ylabel('Intensity')
axes[0, 1].set_title('Individual Phase Contributions')
axes[0, 1].legend()
axes[0, 1].grid(True, alpha=0.3)

<h1>‰∏ª„Éî„Éº„ÇØ„ÅÆ‰ΩçÁΩÆ</h1>
axes[1, 0].plot(two_theta, mixed_pattern, linewidth=1.5)
axes[1, 0].axvline(x=33.2, color='blue',
                   linestyle='--', label='Phase A peak')
axes[1, 0].axvline(x=35.5, color='orange',
                   linestyle='--', label='Phase B peak')
axes[1, 0].set_xlabel('2Œ∏ (degree)')
axes[1, 0].set_ylabel('Intensity')
axes[1, 0].set_title('Main Peak Positions')
axes[1, 0].legend()
axes[1, 0].grid(True, alpha=0.3)

<h1>ÂÆöÈáèÁµêÊûú</h1>
categories = ['Phase A', 'Phase B']
true_values = [ratio_A * 100, ratio_B * 100]
calc_values = [W_A_calc * 100, W_B_calc * 100]

x = np.arange(len(categories))
width = 0.35

axes[1, 1].bar(x - width/2, true_values, width,
               label='True', alpha=0.7)
axes[1, 1].bar(x + width/2, calc_values, width,
               label='Calculated (RIR)', alpha=0.7)
axes[1, 1].set_ylabel('Weight Fraction (%)')
axes[1, 1].set_title('Quantitative Phase Analysis')
axes[1, 1].set_xticks(x)
axes[1, 1].set_xticklabels(categories)
axes[1, 1].legend()
axes[1, 1].grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.show()

print("=== RIRÊ≥ï„Å´„Çà„ÇãÂÆöÈáèÁõ∏ÂàÜÊûê ===")
print(f"‰∏ª„Éî„Éº„ÇØÂº∑Â∫¶:")
print(f"  Áõ∏A (33.2¬∞): {I_A:.1f}")
print(f"  Áõ∏B (35.5¬∞): {I_B:.1f}")
print(f"\nRIRÂÄ§:")
print(f"  Áõ∏A: {RIR_A}")
print(f"  Áõ∏B: {RIR_B}")
print(f"\nÈáçÈáèÂàÜÁéá:")
print(f"  ÁúüÂÄ§ - Áõ∏A: {ratio_A*100:.1f}%, Áõ∏B: {ratio_B*100:.1f}%")
print(f"  Ë®àÁÆó - Áõ∏A: {W_A_calc*100:.1f}%, Áõ∏B: {W_B_calc*100:.1f}%")
print(f"  Ë™§Â∑Æ: Áõ∏A {abs(ratio_A - W_A_calc)*100:.1f}%")</code></pre>

---

<h2>2.7 „Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê„ÅÆËá™ÂãïÂåñ„Éë„Ç§„Éó„É©„Ç§„É≥</h2>

<h3>Áµ±ÂêàËß£Êûê„Éë„Ç§„Éó„É©„Ç§„É≥</h3>

<strong>„Ç≥„Éº„Éâ‰æã9: Ëá™Âãï„Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê„Éë„Ç§„Éó„É©„Ç§„É≥</strong>

<pre><code class="language-python">from dataclasses import dataclass
from typing import Tuple, List

@dataclass
class PeakInfo:
    """„Éî„Éº„ÇØÊÉÖÂ†±„ÇíÊ†ºÁ¥ç„Åô„Çã„Éá„Éº„Çø„ÇØ„É©„Çπ"""
    position: float
    intensity: float
    width: float
    area: float

class SpectrumAnalyzer:
    """„Çπ„Éö„ÇØ„Éà„É´Ëá™ÂãïËß£Êûê„ÇØ„É©„Çπ"""

    def __init__(self, spectrum_type='XRD'):
        """
        Parameters:
        -----------
        spectrum_type : str
            'XRD', 'XPS', 'IR', 'Raman'
        """
        self.spectrum_type = spectrum_type
        self.x = None
        self.y = None
        self.y_corrected = None
        self.peaks = []

    def load_data(self, x: np.ndarray, y: np.ndarray):
        """„Éá„Éº„ÇøË™≠„ÅøËæº„Åø"""
        self.x = np.array(x)
        self.y = np.array(y)

    def remove_background(self, method='snip', **kwargs):
        """„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª"""
        if method == 'snip':
            iterations = kwargs.get('iterations', 30)
            bg = snip_background(self.y, iterations)
        elif method == 'polynomial':
            degree = kwargs.get('degree', 5)
            coeffs = np.polyfit(self.x, self.y, degree)
            bg = np.polyval(coeffs, self.x)
        elif method == 'als':
            lam = kwargs.get('lam', 1e5)
            p = kwargs.get('p', 0.01)
            bg = als_baseline(self.y, lam, p)
        else:
            raise ValueError(f"Unknown method: {method}")

        self.y_corrected = self.y - bg
        return self.y_corrected

    def detect_peaks(self, **kwargs):
        """„Éî„Éº„ÇØÊ§úÂá∫"""
        if self.y_corrected is None:
            raise ValueError("Run remove_background first")

        prominence = kwargs.get('prominence', 50)
        distance = kwargs.get('distance', 10)

        peaks_idx, properties = find_peaks(
            self.y_corrected,
            prominence=prominence,
            distance=distance
        )

        self.peaks = []
        for idx in peaks_idx:
            peak = PeakInfo(
                position=self.x[idx],
                intensity=self.y_corrected[idx],
                width=properties['widths'][0] if 'widths' in properties else 0,
                area=0  # Âæå„ÅßË®àÁÆó
            )
            self.peaks.append(peak)

        return self.peaks

    def report(self):
        """ÁµêÊûú„É¨„Éù„Éº„Éà"""
        print(f"\n=== {self.spectrum_type} Spectrum Analysis Report ===")
        print(f"„Éá„Éº„ÇøÁÇπÊï∞: {len(self.x)}")
        print(f"Ê§úÂá∫„Åï„Çå„Åü„Éî„Éº„ÇØÊï∞: {len(self.peaks)}")
        print(f"\n„Éî„Éº„ÇØÊÉÖÂ†±:")
        for i, peak in enumerate(self.peaks, 1):
            if self.spectrum_type == 'XRD':
                print(f"  „Éî„Éº„ÇØ {i}: 2Œ∏ = {peak.position:.2f}¬∞, "
                      f"Âº∑Â∫¶ = {peak.intensity:.1f}")
            elif self.spectrum_type == 'XPS':
                print(f"  „Éî„Éº„ÇØ {i}: BE = {peak.position:.2f} eV, "
                      f"Âº∑Â∫¶ = {peak.intensity:.1f}")
            elif self.spectrum_type in ['IR', 'Raman']:
                print(f"  „Éî„Éº„ÇØ {i}: {peak.position:.1f} cm‚Åª¬π, "
                      f"Âº∑Â∫¶ = {peak.intensity:.1f}")

<h1>‰ΩøÁî®‰æã</h1>
analyzer = SpectrumAnalyzer(spectrum_type='XRD')
analyzer.load_data(two_theta, intensity)
analyzer.remove_background(method='snip', iterations=50)
peaks = analyzer.detect_peaks(prominence=80, distance=10)
analyzer.report()

<h1>ÂèØË¶ñÂåñ</h1>
plt.figure(figsize=(14, 6))

plt.subplot(1, 2, 1)
plt.plot(analyzer.x, analyzer.y, label='Raw', alpha=0.5)
plt.plot(analyzer.x, analyzer.y_corrected,
         label='Background-corrected', linewidth=1.5)
plt.xlabel('2Œ∏ (degree)')
plt.ylabel('Intensity')
plt.title('Spectrum Processing')
plt.legend()
plt.grid(True, alpha=0.3)

plt.subplot(1, 2, 2)
plt.plot(analyzer.x, analyzer.y_corrected, linewidth=1.5)
peak_positions = [p.position for p in peaks]
peak_intensities = [p.intensity for p in peaks]
plt.plot(peak_positions, peak_intensities, 'rx',
         markersize=12, markeredgewidth=2)
plt.xlabel('2Œ∏ (degree)')
plt.ylabel('Intensity')
plt.title('Peak Detection')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()</code></pre>

---

<h2>2.8 Êú¨Á´†„ÅÆ„Åæ„Å®„ÇÅ</h2>

<h3>Â≠¶„Çì„Å†„Åì„Å®</h3>

1. <strong>„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÊâãÊ≥ï</strong>
   - Â§öÈ†ÖÂºè„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞ÔºàÊ±éÁî®Ôºâ
   - SNIPÊ≥ïÔºàXRD„ÄÅRamanÔºâ
   - „Ç∑„É£„Éº„É™„ÉºÂûãÔºàXPSÔºâ
   - ALSÊ≥ïÔºàIR„ÄÅRamanÔºâ

2. <strong>„Éî„Éº„ÇØÊ§úÂá∫</strong>
   - <code>scipy.signal.find_peaks</code>„ÅÆÊ¥ªÁî®
   - „Éë„É©„É°„Éº„ÇøÊúÄÈÅ©ÂåñÔºàprominence„ÄÅdistance„ÄÅwidthÔºâ
   - „Ç¨„Ç¶„Ç∑„Ç¢„É≥„Éª„É≠„Éº„É¨„É≥„ÉÑ„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞

3. <strong>ÂÆöÈáèÂàÜÊûê</strong>
   - RIRÊ≥ï„Å´„Çà„ÇãÁõ∏ÂàÜÁéáË®àÁÆó
   - „Éî„Éº„ÇØÈù¢Á©ç„ÅÆÂÆöÈáèË©ï‰æ°

4. <strong>Ëá™ÂãïÂåñ</strong>
   - „ÇØ„É©„Çπ„Éô„Éº„Çπ„ÅÆËß£Êûê„Éë„Ç§„Éó„É©„Ç§„É≥
   - Ë§áÊï∞Ê∏¨ÂÆöÊäÄË°ì„Å∏„ÅÆÂØæÂøú

<h3>ÈáçË¶Å„Å™„Éù„Ç§„É≥„Éà</h3>

- ‚úÖ „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª„ÅØÊ∏¨ÂÆöÊäÄË°ì„Åî„Å®„Å´ÈÅ©Âàá„Å™ÊâãÊ≥ï„ÇíÈÅ∏Êäû
- ‚úÖ „Éî„Éº„ÇØÊ§úÂá∫„Åß„ÅØ„ÄÅ„Éë„É©„É°„Éº„ÇøË™øÊï¥„Å®ÂèØË¶ñÂåñÁ¢∫Ë™ç„ÅåÂøÖÈ†à
- ‚úÖ ÂÆöÈáèÂàÜÊûê„Å´„ÅØÊ®ôÊ∫ñË©¶Êñô„ÇÑRIRÂÄ§„Å™„Å©„ÅÆÂèÇÁÖßÊÉÖÂ†±„ÅåÂøÖË¶Å
- ‚úÖ Ëá™ÂãïÂåñ„Å´„Çà„ÇäÂÜçÁèæÊÄß„Å®Âá¶ÁêÜÈÄüÂ∫¶„ÅåÂ§ßÂπÖ„Å´Âêë‰∏ä

<h3>Ê¨°„ÅÆÁ´†„Å∏</h3>

Á¨¨3Á´†„Åß„ÅØ„ÄÅÁîªÂÉè„Éá„Éº„ÇøÔºàSEM„ÄÅTEMÔºâ„ÅÆËß£ÊûêÊâãÊ≥ï„ÇíÂ≠¶„Å≥„Åæ„ÅôÔºö
- ÁîªÂÉèÂâçÂá¶ÁêÜÔºà„Éé„Ç§„Ç∫Èô§Âéª„ÄÅ„Ç≥„É≥„Éà„É©„Çπ„ÉàË™øÊï¥Ôºâ
- Á≤íÂ≠êÊ§úÂá∫ÔºàWatershedÊ≥ïÔºâ
- Á≤íÂæÑÂàÜÂ∏ÉËß£Êûê
- CNN„Å´„Çà„ÇãÁîªÂÉèÂàÜÈ°û

<strong>[Á¨¨3Á´†ÔºöÁîªÂÉè„Éá„Éº„ÇøËß£Êûê ‚Üí](./chapter-3.md)</strong>

---

<h2>ÊºîÁøíÂïèÈ°å</h2>

<h3>ÂïèÈ°å1ÔºàÈõ£ÊòìÂ∫¶ÔºöeasyÔºâ</h3>

Ê¨°„ÅÆÊñáÁ´†„ÅÆÊ≠£Ë™§„ÇíÂà§ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

1. SNIPÊ≥ï„ÅØÂ§öÈ†ÖÂºè„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„Çà„Çä„ÇÇ„Éî„Éº„ÇØ„ÅÆÂΩ±Èüø„ÇíÂèó„Åë„Å´„Åè„ÅÑ
2. XPS„Çπ„Éö„ÇØ„Éà„É´„Å´„ÅØÁ∑öÂΩ¢„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅåÈÅ©„Åó„Å¶„ÅÑ„Çã
3. „Éî„Éº„ÇØÊ§úÂá∫„ÅÆprominence„Éë„É©„É°„Éº„Çø„ÅØ„ÄÅ„Éî„Éº„ÇØÈñì„ÅÆÊúÄÂ∞èË∑ùÈõ¢„ÇíÊåáÂÆö„Åô„Çã

<details>
<summary>„Éí„É≥„Éà</summary>

1. SNIPÊ≥ï„ÅÆÂãï‰ΩúÂéüÁêÜÔºà„Éî„Éº„ÇØ„ÇØ„É™„ÉÉ„Éî„É≥„Ç∞Ôºâ„ÇíËÄÉ„Åà„Çã
2. XPS„ÅÆ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅØÈùûÂºæÊÄßÊï£‰π±„Å´Ëµ∑Âõ†„Åô„Çã
3. prominence„ÄÅdistance„ÄÅwidth„Éë„É©„É°„Éº„Çø„ÅÆÊÑèÂë≥„ÇíÁ¢∫Ë™ç

</details>

<details>
<summary>Ëß£Á≠î‰æã</summary>

<strong>Ëß£Á≠î</strong>:
1. <strong>Ê≠£</strong> - SNIPÊ≥ï„ÅØ„Éî„Éº„ÇØ„ÇíÈÅø„Åë„Å¶„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÇíÊé®ÂÆö„Åô„Çã„Åü„ÇÅ„ÄÅÂ§öÈ†ÖÂºè„Çà„Çä„É≠„Éê„Çπ„Éà
2. <strong>Ë™§</strong> - XPS„ÅØ„Ç∑„É£„Éº„É™„ÉºÂûã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅåÈÅ©ÂàáÔºàÈùûÂºæÊÄßÊï£‰π±„Å´„Çà„ÇãÈùûÂØæÁß∞ÂΩ¢Áä∂Ôºâ
3. <strong>Ë™§</strong> - prominence„ÅØÂçìË∂äÂ∫¶ÔºàÂë®Âõ≤„Å®„ÅÆÈ´ò‰ΩéÂ∑ÆÔºâ„ÄÅ„Éî„Éº„ÇØÈñìË∑ùÈõ¢„ÅØdistance„Éë„É©„É°„Éº„Çø

<strong>Ëß£Ë™¨</strong>:
„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÊâãÊ≥ï„ÅÆÈÅ∏Êäû„ÅØÊ∏¨ÂÆöÂéüÁêÜ„Å´Âü∫„Å•„Åè„Åì„Å®„ÅåÈáçË¶Å„Åß„Åô„ÄÇXPS„ÅÆÈùûÂºæÊÄßÊï£‰π±„ÄÅRaman„ÅÆËõçÂÖâ„ÄÅXRD„ÅÆÈùûÊô∂Ë≥™„Éè„É≠„Éº„Å™„Å©„ÄÅ„Åù„Çå„Åû„ÇåÁï∞„Å™„Çã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂΩ¢Áä∂„ÇíÊåÅ„Å°„Åæ„Åô„ÄÇ

</details>

---

<h3>ÂïèÈ°å2ÔºàÈõ£ÊòìÂ∫¶ÔºömediumÔºâ</h3>

‰ª•‰∏ã„ÅÆXRD„Éá„Éº„Çø„Å´ÂØæ„Åó„Å¶„ÄÅSNIPÊ≥ï„Åß„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª„ÇíË°å„ÅÑ„ÄÅ„Éî„Éº„ÇØ„ÇíÊ§úÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

<pre><code class="language-python">import numpy as np

<h1>„Çµ„É≥„Éó„É´XRD„Éá„Éº„Çø</h1>
np.random.seed(123)
two_theta = np.linspace(15, 75, 600)
intensity = (
    1200 * np.exp(-((two_theta - 26.6) ** 2) / 12) +
    1800 * np.exp(-((two_theta - 33.8) ** 2) / 10) +
    1000 * np.exp(-((two_theta - 54.8) ** 2) / 15) +
    150 + 50 * np.sin(two_theta / 8) +
    np.random.normal(0, 40, len(two_theta))
)</code></pre>

<strong>Ë¶ÅÊ±Ç‰∫ãÈ†Ö</strong>:
1. SNIPÊ≥ï„Åß„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÔºàiterations=40Ôºâ
2. „Éî„Éº„ÇØÊ§úÂá∫Ôºàprominence=100Ôºâ
3. Ê§úÂá∫„Åï„Çå„Åü„Éî„Éº„ÇØ‰ΩçÁΩÆ„Å®Âº∑Â∫¶„ÇíÂá∫Âäõ
4. Âá¶ÁêÜÂâçÂæå„ÅÆ„Çπ„Éö„ÇØ„Éà„É´„ÇíÂèØË¶ñÂåñ

<details>
<summary>„Éí„É≥„Éà</summary>

<strong>Âá¶ÁêÜ„Éï„É≠„Éº</strong>:
1. SNIPÈñ¢Êï∞„ÇíÂÆöÁæ©„Åæ„Åü„ÅØÂÜçÂà©Áî®
2. „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊ∏õÁÆó
3. <code>find_peaks</code>„Åß„Éî„Éº„ÇØÊ§úÂá∫
4. ÁµêÊûú„ÇíÊï¥ÁêÜ„Åó„Å¶Âá∫Âäõ
5. <code>matplotlib</code>„Åß3ÊÆµÈöéÔºàÂÖÉ„Éá„Éº„Çø„ÄÅ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÄÅË£úÊ≠£ÂæåÔºâ„ÇíÂèØË¶ñÂåñ

</details>

<details>
<summary>Ëß£Á≠î‰æã</summary>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks

<h1>SNIPÈñ¢Êï∞Ôºà„Ç≥„Éº„Éâ‰æã2„Çà„ÇäÔºâ</h1>
def snip_background(spectrum, iterations=30):
    spectrum = np.array(spectrum, dtype=float)
    background = np.copy(spectrum)

    for i in range(1, iterations + 1):
        for j in range(i, len(background) - i):
            v1 = (background[j - i] + background[j + i]) / 2
            v2 = background[j]
            background[j] = min(v1, v2)

    return background

<h1>„Çµ„É≥„Éó„É´„Éá„Éº„Çø</h1>
np.random.seed(123)
two_theta = np.linspace(15, 75, 600)
intensity = (
    1200 * np.exp(-((two_theta - 26.6) ** 2) / 12) +
    1800 * np.exp(-((two_theta - 33.8) ** 2) / 10) +
    1000 * np.exp(-((two_theta - 54.8) ** 2) / 15) +
    150 + 50 * np.sin(two_theta / 8) +
    np.random.normal(0, 40, len(two_theta))
)

<h1>SNIPÊ≥ïÈÅ©Áî®</h1>
bg = snip_background(intensity, iterations=40)
intensity_corrected = intensity - bg

<h1>„Éî„Éº„ÇØÊ§úÂá∫</h1>
peaks_idx, _ = find_peaks(intensity_corrected, prominence=100)
peak_positions = two_theta[peaks_idx]
peak_intensities = intensity_corrected[peaks_idx]

<h1>ÁµêÊûúÂá∫Âäõ</h1>
print("=== „Éî„Éº„ÇØÊ§úÂá∫ÁµêÊûú ===")
for i, (pos, intens) in enumerate(zip(peak_positions,
                                       peak_intensities), 1):
    print(f"„Éî„Éº„ÇØ {i}: 2Œ∏ = {pos:.2f}¬∞, Âº∑Â∫¶ = {intens:.1f}")

<h1>ÂèØË¶ñÂåñ</h1>
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

axes[0].plot(two_theta, intensity, linewidth=1.5)
axes[0].set_xlabel('2Œ∏ (degree)')
axes[0].set_ylabel('Intensity')
axes[0].set_title('Raw XRD Pattern')
axes[0].grid(True, alpha=0.3)

axes[1].plot(two_theta, intensity, label='Raw', alpha=0.6)
axes[1].plot(two_theta, bg, label='SNIP background',
             linewidth=2, color='red')
axes[1].set_xlabel('2Œ∏ (degree)')
axes[1].set_ylabel('Intensity')
axes[1].set_title('Background Estimation')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

axes[2].plot(two_theta, intensity_corrected, linewidth=1.5)
axes[2].plot(peak_positions, peak_intensities, 'rx',
             markersize=12, markeredgewidth=2)
axes[2].set_xlabel('2Œ∏ (degree)')
axes[2].set_ylabel('Intensity')
axes[2].set_title('After Background Subtraction + Peak Detection')
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()</code></pre>

<strong>Âá∫Âäõ</strong>:
<pre><code>=== „Éî„Éº„ÇØÊ§úÂá∫ÁµêÊûú ===
„Éî„Éº„ÇØ 1: 2Œ∏ = 26.59¬∞, Âº∑Â∫¶ = 1205.3
„Éî„Éº„ÇØ 2: 2Œ∏ = 33.81¬∞, Âº∑Â∫¶ = 1813.7
„Éî„Éº„ÇØ 3: 2Œ∏ = 54.76¬∞, Âº∑Â∫¶ = 1008.2</code></pre>

<strong>Ëß£Ë™¨</strong>:
SNIPÊ≥ï„ÅÆiterations=40„ÅØ„ÄÅ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅÆÁâπÂæ¥ÁöÑ„Å™ÂπÖÔºà„Éá„Éº„ÇøÁÇπÊï∞Ôºâ„Å´ÂØæÂøú„Åó„Åæ„Åô„ÄÇ„Åì„ÅÆ‰æã„Åß„ÅØÁ∑©„ÇÑ„Åã„Å™„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅÆ„Åü„ÇÅ„ÄÅ40„Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥„ÅßÂçÅÂàÜ„Åß„Åô„ÄÇprominence=100„Å´„Çà„Çä„ÄÅ„Éé„Ç§„Ç∫„Éî„Éº„ÇØ„ÇíÈô§Â§ñ„Åó„ÄÅ‰∏ªË¶Å„Å™3„Éî„Éº„ÇØ„ÅÆ„Åø„ÇíÊ§úÂá∫„Åß„Åç„Åæ„Åó„Åü„ÄÇ

</details>

---

<h3>ÂïèÈ°å3ÔºàÈõ£ÊòìÂ∫¶ÔºöhardÔºâ</h3>

Ë§áÊï∞„ÅÆÊ∏¨ÂÆöÊäÄË°ìÔºàXRD„ÄÅXPS„ÄÅRamanÔºâ„ÅÆ„Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„Çø„ÇíËá™ÂãïÂá¶ÁêÜ„Åô„Çã„Éê„ÉÉ„ÉÅ„Ç∑„Çπ„ÉÜ„É†„ÇíÊßãÁØâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

<strong>ËÉåÊôØ</strong>:
ÊùêÊñô„É©„Ç§„Éñ„É©„É™„Éº„Åã„Çâ100„Çµ„É≥„Éó„É´„ÅÆË§áÂêàÊ∏¨ÂÆö„Éá„Éº„ÇøÔºàXRD„ÄÅXPS„ÄÅRamanÔºâ„ÅåÂæó„Çâ„Çå„Åæ„Åó„Åü„ÄÇÂêÑÊ∏¨ÂÆö„Å´„Å§„ÅÑ„Å¶ÈÅ©Âàá„Å™ÂâçÂá¶ÁêÜ„ÇíËá™ÂãïÈÅ∏Êäû„Åó„ÄÅ„Éî„Éº„ÇØÊÉÖÂ†±„ÇíÊäΩÂá∫„Åô„ÇãÁµ±Âêà„Ç∑„Çπ„ÉÜ„É†„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ

<strong>Ë™≤È°å</strong>:
1. Ê∏¨ÂÆöÊäÄË°ì„Å´Âøú„Åò„ÅüÊúÄÈÅ©„Å™„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÊâãÊ≥ï„ÅÆËá™ÂãïÈÅ∏Êäû
2. „Éî„Éº„ÇØÊ§úÂá∫„Éë„É©„É°„Éº„Çø„ÅÆËá™ÂãïË™øÊï¥
3. ÁµêÊûú„ÇíJSONÂΩ¢Âºè„Åß‰øùÂ≠ò
4. „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Å®„É≠„Ç∞Âá∫Âäõ

<strong>Âà∂Á¥ÑÊù°‰ª∂</strong>:
- ÂêÑÊ∏¨ÂÆöÊäÄË°ì„ÅßÁï∞„Å™„Çã„Éá„Éº„ÇøÂΩ¢ÂºèÔºàÂàóÂêç„ÄÅÂçò‰ΩçÔºâ
- Ê∏¨ÂÆöÂìÅË≥™„ÅÆ„Å∞„Çâ„Å§„ÅçÔºà„Éé„Ç§„Ç∫„É¨„Éô„É´Ôºâ
- Âá¶ÁêÜÊôÇÈñìÔºö10Áßí‰ª•ÂÜÖ/„Çµ„É≥„Éó„É´

<details>
<summary>„Éí„É≥„Éà</summary>

<strong>Ë®≠Ë®àÊñπÈáù</strong>:
1. <code>SpectrumAnalyzer</code>„ÇØ„É©„Çπ„ÇíÊã°Âºµ
2. Ê∏¨ÂÆöÊäÄË°ì„ÅÆËá™ÂãïÂà§ÂÆöÔºà„É°„Çø„Éá„Éº„Çø„Åæ„Åü„ÅØ„Éï„Ç°„Ç§„É´Âêç„Åã„ÇâÔºâ
3. ÈÅ©ÂøúÁöÑ„Éë„É©„É°„Éº„ÇøË™øÊï¥Ôºà„Éé„Ç§„Ç∫„É¨„Éô„É´„Å´Âøú„Åò„Å¶prominenceË™øÊï¥Ôºâ
4. JSONÂá∫Âäõ„Å´„ÅØ„Éî„Éº„ÇØ‰ΩçÁΩÆ„ÄÅÂº∑Â∫¶„ÄÅÊé®ÂÆöÁõ∏ÊÉÖÂ†±„ÇíÂê´„ÇÅ„Çã

<strong>„ÇØ„É©„ÇπË®≠Ë®à‰æã</strong>:
<pre><code class="language-python">class AutoSpectrumProcessor:
    def __init__(self):
        self.analyzers = {}  # Ê∏¨ÂÆöÊäÄË°ì„Åî„Å®„ÅÆanalyzer

    def detect_spectrum_type(self, data):
        # „É°„Çø„Éá„Éº„Çø„Åã„ÇâÊ∏¨ÂÆöÊäÄË°ì„ÇíÂà§ÂÆö
        pass

    def adaptive_parameters(self, spectrum):
        # „Éé„Ç§„Ç∫„É¨„Éô„É´„Å´Âøú„Åò„Å¶„Éë„É©„É°„Éº„ÇøË™øÊï¥
        pass

    def batch_process(self, file_list):
        # Ë§áÊï∞„Éï„Ç°„Ç§„É´Âá¶ÁêÜ
        pass</code></pre>

</details>

<details>
<summary>Ëß£Á≠î‰æã</summary>

<strong>Ëß£Á≠î„ÅÆÊ¶ÇË¶Å</strong>:
Ê∏¨ÂÆöÊäÄË°ì„ÅÆËá™ÂãïÂà§ÂÆö„ÄÅÈÅ©ÂøúÁöÑ„Éë„É©„É°„Éº„ÇøË™øÊï¥„ÄÅÁµêÊûú„ÅÆJSON‰øùÂ≠ò„ÇíÂê´„ÇÄÁµ±ÂêàÂá¶ÁêÜ„Ç∑„Çπ„ÉÜ„É†„ÇíÊßãÁØâ„Åó„Åæ„Åô„ÄÇ

<strong>ÂÆüË£Ö„Ç≥„Éº„Éâ</strong>:

<pre><code class="language-python">import json
import logging
from pathlib import Path
from typing import Dict, List
from dataclasses import dataclass, asdict

logging.basicConfig(level=logging.INFO)

@dataclass
class SpectrumResult:
    """Ëß£ÊûêÁµêÊûú„ÇíÊ†ºÁ¥ç"""
    spectrum_type: str
    num_peaks: int
    peaks: List[Dict]
    processing_time: float
    background_method: str

class AutoSpectrumProcessor:
    """Ëá™Âãï„Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê„Ç∑„Çπ„ÉÜ„É†"""

    def __init__(self):
        self.bg_methods = {
            'XRD': 'snip',
            'XPS': 'shirley',
            'Raman': 'als',
            'IR': 'als'
        }

    def detect_spectrum_type(self, x: np.ndarray) -> str:
        """
        „Éá„Éº„ÇøÁØÑÂõ≤„Åã„ÇâÊ∏¨ÂÆöÊäÄË°ì„ÇíÊé®ÂÆö
        """
        x_range = x.max() - x.min()
        x_min = x.min()

        if x_min > 5 and x_range < 100:  # 2Œ∏ÁØÑÂõ≤
            return 'XRD'
        elif x_min > 200 and x_range > 500:  # BEÁØÑÂõ≤
            return 'XPS'
        elif x_min > 100 and x_range > 1000:  # cm-1ÁØÑÂõ≤
            return 'Raman' if x.max() < 4000 else 'IR'
        else:
            return 'Unknown'

    def adaptive_prominence(self, spectrum: np.ndarray) -> float:
        """
        „Éé„Ç§„Ç∫„É¨„Éô„É´„Å´Âøú„Åò„Å¶prominenceË™øÊï¥
        """
        noise_std = np.std(np.diff(spectrum))
        snr = np.max(spectrum) / (noise_std + 1e-10)

        if snr > 50:
            return 0.05 * np.max(spectrum)  # È´òS/N
        elif snr > 20:
            return 0.08 * np.max(spectrum)  # ‰∏≠S/N
        else:
            return 0.12 * np.max(spectrum)  # ‰ΩéS/N

    def process_spectrum(self, x: np.ndarray, y: np.ndarray,
                        metadata: Dict = None) -> SpectrumResult:
        """
        Âçò‰∏Ä„Çπ„Éö„ÇØ„Éà„É´„ÅÆÂá¶ÁêÜ
        """
        import time
        start_time = time.time()

        # Ê∏¨ÂÆöÊäÄË°ì„ÅÆÂà§ÂÆö
        if metadata and 'type' in metadata:
            spec_type = metadata['type']
        else:
            spec_type = self.detect_spectrum_type(x)

        logging.info(f"Detected spectrum type: {spec_type}")

        # „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª
        bg_method = self.bg_methods.get(spec_type, 'snip')

        if bg_method == 'snip':
            bg = snip_background(y, iterations=40)
        elif bg_method == 'als':
            bg = als_baseline(y, lam=1e6, p=0.01)
        else:
            # Á∞°ÊòìÁ∑öÂΩ¢ÔºàshirleyÊú™ÂÆüË£Ö„ÅÆÂ†¥ÂêàÔºâ
            bg = np.linspace(y[0], y[-1], len(y))

        y_corrected = y - bg

        # ÈÅ©ÂøúÁöÑ„Éî„Éº„ÇØÊ§úÂá∫
        prominence = self.adaptive_prominence(y_corrected)
        peaks_idx, _ = find_peaks(y_corrected, prominence=prominence)

        # „Éî„Éº„ÇØÊÉÖÂ†±„ÇíÊßãÈÄ†Âåñ
        peaks_info = []
        for idx in peaks_idx:
            peaks_info.append({
                'position': float(x[idx]),
                'intensity': float(y_corrected[idx]),
                'unit': '2Œ∏(deg)' if spec_type == 'XRD' else 'cm-1'
            })

        processing_time = time.time() - start_time

        result = SpectrumResult(
            spectrum_type=spec_type,
            num_peaks=len(peaks_idx),
            peaks=peaks_info,
            processing_time=processing_time,
            background_method=bg_method
        )

        return result

    def batch_process(self, data_list: List[Dict],
                     output_file: str = 'results.json'):
        """
        „Éê„ÉÉ„ÉÅÂá¶ÁêÜ

        Parameters:
        -----------
        data_list : list of dict
            ÂêÑË¶ÅÁ¥†„ÅØ {'x': array, 'y': array, 'metadata': dict}
        """
        results = []

        for i, data in enumerate(data_list, 1):
            try:
                logging.info(f"Processing spectrum {i}/{len(data_list)}")
                result = self.process_spectrum(
                    data['x'],
                    data['y'],
                    data.get('metadata')
                )
                results.append(asdict(result))

            except Exception as e:
                logging.error(f"Failed to process spectrum {i}: {e}")
                continue

        # JSON‰øùÂ≠ò
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=2)

        logging.info(f"Results saved to {output_file}")
        return results

<h1>„Éá„É¢ÂÆüË°å</h1>
if __name__ == "__main__":
    processor = AutoSpectrumProcessor()

    # „Çµ„É≥„Éó„É´„Éá„Éº„ÇøÁîüÊàêÔºà3Á®ÆÈ°û„ÅÆÊ∏¨ÂÆöÔºâ
    data_list = []

    # XRD„Éá„Éº„Çø
    two_theta = np.linspace(20, 60, 400)
    xrd_y = (
        1000 * np.exp(-((two_theta - 28) ** 2) / 10) +
        1500 * np.exp(-((two_theta - 35) ** 2) / 8) +
        100 + np.random.normal(0, 30, len(two_theta))
    )
    data_list.append({
        'x': two_theta,
        'y': xrd_y,
        'metadata': {'type': 'XRD', 'sample': 'Fe2O3'}
    })

    # Raman„Éá„Éº„Çø
    raman_shift = np.linspace(200, 2000, 900)
    raman_y = (
        2000 * np.exp(-((raman_shift - 520) ** 2) / 100) +
        1500 * np.exp(-((raman_shift - 950) ** 2) / 150) +
        500 + np.random.normal(0, 50, len(raman_shift))
    )
    data_list.append({
        'x': raman_shift,
        'y': raman_y,
        'metadata': {'type': 'Raman', 'sample': 'Si'}
    })

    # „Éê„ÉÉ„ÉÅÂá¶ÁêÜÂÆüË°å
    results = processor.batch_process(data_list,
                                      output_file='spectrum_results.json')

    print("\n=== Processing Summary ===")
    for i, result in enumerate(results, 1):
        print(f"Spectrum {i}:")
        print(f"  Type: {result['spectrum_type']}")
        print(f"  Peaks detected: {result['num_peaks']}")
        print(f"  Processing time: {result['processing_time']:.3f}s")</code></pre>

<strong>ÁµêÊûúÔºàJSONÂá∫Âäõ‰æãÔºâ</strong>:
<pre><code class="language-json">[
  {
    "spectrum_type": "XRD",
    "num_peaks": 2,
    "peaks": [
      {"position": 28.05, "intensity": 1023.4, "unit": "2Œ∏(deg)"},
      {"position": 35.01, "intensity": 1518.7, "unit": "2Œ∏(deg)"}
    ],
    "processing_time": 0.045,
    "background_method": "snip"
  },
  {
    "spectrum_type": "Raman",
    "num_peaks": 2,
    "peaks": [
      {"position": 520.3, "intensity": 2015.6, "unit": "cm-1"},
      {"position": 949.8, "intensity": 1507.2, "unit": "cm-1"}
    ],
    "processing_time": 0.052,
    "background_method": "als"
  }
]</code></pre>

<strong>Ë©≥Á¥∞„Å™Ëß£Ë™¨</strong>:
1. <strong>Ëá™ÂãïÂà§ÂÆö</strong>: „Éá„Éº„ÇøÁØÑÂõ≤„Åã„ÇâÊ∏¨ÂÆöÊäÄË°ì„ÇíÊé®ÂÆöÔºàXRD: 10-80¬∞„ÄÅRaman: 200-2000 cm‚Åª¬πÔºâ
2. <strong>ÈÅ©ÂøúÁöÑ„Éë„É©„É°„Éº„Çø</strong>: S/NÊØî„Åã„Çâprominence„ÇíËá™ÂãïË™øÊï¥
3. <strong>ÊßãÈÄ†ÂåñÂá∫Âäõ</strong>: JSONÂΩ¢Âºè„ÅßÂæåÁ∂öËß£Êûê„ÇÑ„Éá„Éº„Çø„Éô„Éº„ÇπÁôªÈå≤„Å´ÂØæÂøú
4. <strong>„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞</strong>: ÂÄãÂà•„Çπ„Éö„ÇØ„Éà„É´„ÅÆÂ§±Êïó„Åå„Éê„ÉÉ„ÉÅÂÖ®‰Ωì„ÇíÂÅúÊ≠¢„Åï„Åõ„Å™„ÅÑ

<strong>ËøΩÂä†„ÅÆÊ§úË®é‰∫ãÈ†Ö</strong>:
- Ê∏¨ÂÆöÊäÄË°ì„ÅÆÂà§ÂÆöÁ≤æÂ∫¶Âêë‰∏äÔºàÊ©üÊ¢∞Â≠¶ÁøíÂàÜÈ°ûÂô®„ÅÆÂ∞éÂÖ•Ôºâ
- „ÇØ„É©„Ç¶„Éâ„Çπ„Éà„É¨„Éº„Ç∏ÔºàS3„ÄÅGCSÔºâ„Åã„Çâ„ÅÆ„Éá„Éº„ÇøË™≠„ÅøËæº„Åø
- Web„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„Åß„ÅÆ„É™„Ç¢„É´„Çø„Ç§„É†ÂèØË¶ñÂåñ
- „Éá„Éº„Çø„Éô„Éº„ÇπÔºàMongoDBÔºâ„Å∏„ÅÆÁµêÊûú‰øùÂ≠ò

</details>

---

<h2>ÂèÇËÄÉÊñáÁåÆ</h2>

1. Pecharsky, V. K., & Zavalij, P. Y. (2009). "Fundamentals of Powder Diffraction and Structural Characterization of Materials." Springer. ISBN: 978-0387095783

2. Briggs, D., & Seah, M. P. (1990). "Practical Surface Analysis by Auger and X-ray Photoelectron Spectroscopy." Wiley. ISBN: 978-0471920816

3. Ryan, C. G. et al. (1988). "SNIP, a statistics-sensitive background treatment for the quantitative analysis of PIXE spectra in geoscience applications." *Nuclear Instruments and Methods in Physics Research B*, 34(3), 396-402. DOI: [10.1016/0168-583X(88)90063-8](https://doi.org/10.1016/0168-583X(88)90063-8)

4. Eilers, P. H. C., & Boelens, H. F. M. (2005). "Baseline Correction with Asymmetric Least Squares Smoothing." *Leiden University Medical Centre Report*.

5. SciPy Documentation: Signal Processing. URL: [https://docs.scipy.org/doc/scipy/reference/signal.html](https://docs.scipy.org/doc/scipy/reference/signal.html)

---

<h2>„Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥</h2>

<h3>Ââç„ÅÆÁ´†</h3>
<strong>[Á¨¨1Á´†ÔºöÂÆüÈ®ì„Éá„Éº„ÇøËß£Êûê„ÅÆÂü∫Á§é ‚Üê](./chapter-1.md)</strong>

<h3>Ê¨°„ÅÆÁ´†</h3>
<strong>[Á¨¨3Á´†ÔºöÁîªÂÉè„Éá„Éº„ÇøËß£Êûê ‚Üí](./chapter-3.md)</strong>

<h3>„Ç∑„É™„Éº„Ç∫ÁõÆÊ¨°</h3>
<strong>[‚Üê „Ç∑„É™„Éº„Ç∫ÁõÆÊ¨°„Å´Êàª„Çã](./index.md)</strong>

---

<h2>ËëóËÄÖÊÉÖÂ†±</h2>

<strong>‰ΩúÊàêËÄÖ</strong>: AI Terakoya Content Team
<strong>Áõ£‰øÆ</strong>: Dr. Yusuke HashimotoÔºàÊù±ÂåóÂ§ßÂ≠¶Ôºâ
<strong>‰ΩúÊàêÊó•</strong>: 2025-10-17
<strong>„Éê„Éº„Ç∏„Éß„É≥</strong>: 1.0

<strong>Êõ¥Êñ∞Â±•Ê≠¥</strong>:
- 2025-10-17: v1.0 ÂàùÁâàÂÖ¨Èñã

<strong>„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ</strong>:
- GitHub Issues: [„É™„Éù„Ç∏„Éà„É™URL]/issues
- Email: yusuke.hashimoto.b8@tohoku.ac.jp

<strong>„É©„Ç§„Çª„É≥„Çπ</strong>: Creative Commons BY 4.0

---

<strong>Ê¨°„ÅÆÁ´†„ÅßÂ≠¶Áøí„ÇíÁ∂ö„Åë„Åæ„Åó„Çá„ÅÜÔºÅ</strong>
<div class="navigation">
    <a href="chapter-1.html" class="nav-button">‚Üê Á¨¨1Á´†</a>
    <a href="index.html" class="nav-button">„Ç∑„É™„Éº„Ç∫ÁõÆÊ¨°„Å´Êàª„Çã</a>
    <a href="chapter-3.html" class="nav-button">Á¨¨3Á´† ‚Üí</a>
</div>
    </main>

    <footer>
        <p><strong>‰ΩúÊàêËÄÖ</strong>: AI Terakoya Content Team</p>
        <p><strong>Áõ£‰øÆ</strong>: Dr. Yusuke HashimotoÔºàÊù±ÂåóÂ§ßÂ≠¶Ôºâ</p>
        <p><strong>„Éê„Éº„Ç∏„Éß„É≥</strong>: 1.0 | <strong>‰ΩúÊàêÊó•</strong>: 2025-10-17</p>
        <p><strong>„É©„Ç§„Çª„É≥„Çπ</strong>: Creative Commons BY 4.0</p>
        <p>¬© 2025 AI Terakoya. All rights reserved.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const mermaidCodeBlocks = document.querySelectorAll('pre.codehilite code.language-mermaid, pre code.language-mermaid');

            mermaidCodeBlocks.forEach(function(codeBlock) {
                const pre = codeBlock.parentElement;
                const mermaidCode = codeBlock.textContent;

                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = mermaidCode.trim();

                pre.parentNode.replaceChild(mermaidDiv, pre);
            });

            if (typeof mermaid !== 'undefined') {
                mermaid.initialize({
                    startOnLoad: true,
                    theme: 'default'
                });
                mermaid.init(undefined, document.querySelectorAll('.mermaid'));
            }
        });
    </script>
</body>
</html>
