<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第2章：Materials Project完全ガイド - AI Terakoya</title>
    <style>
        :root {
            --color-primary-900: #1a252f;
            --color-primary-700: #2c3e50;
            --color-primary-500: #34495e;
            --color-primary-300: #4a5f7a;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-bg: #ffffff;
            --color-bg-secondary: #f8f9fa;
            --color-text: #2c3e50;
            --color-text-light: #6c757d;
            --color-border: #e9ecef;
            --color-code-bg: #f8f9fa;
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            --font-base: 1rem;
            --font-sm: 0.875rem;
            --font-lg: 1.125rem;
            --font-xl: 1.5rem;
            --font-2xl: 2rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans JP", sans-serif;
            line-height: 1.7;
            color: var(--color-text);
            background: var(--color-bg);
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header-content {
            max-width: 800px;
            margin: 0 auto;
        }

        header h1 {
            font-size: var(--font-2xl);
            margin-bottom: var(--spacing-sm);
            font-weight: 700;
        }

        .subtitle {
            font-size: var(--font-lg);
            opacity: 0.95;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            justify-content: center;
            font-size: var(--font-sm);
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: var(--spacing-xl) var(--spacing-md);
        }

        h2 {
            font-size: var(--font-xl);
            color: var(--color-accent);
            margin: var(--spacing-lg) 0 var(--spacing-md) 0;
            padding-bottom: var(--spacing-xs);
            border-bottom: 2px solid var(--color-accent-light);
        }

        h3 {
            font-size: var(--font-lg);
            color: var(--color-primary-700);
            margin: var(--spacing-md) 0 var(--spacing-sm) 0;
        }

        h4 {
            font-size: var(--font-base);
            color: var(--color-primary-500);
            margin: var(--spacing-sm) 0;
        }

        p {
            margin-bottom: var(--spacing-md);
            line-height: 1.8;
        }

        ul, ol {
            margin: var(--spacing-md) 0;
            padding-left: var(--spacing-lg);
        }

        li {
            margin-bottom: var(--spacing-xs);
        }

        code {
            background: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--color-accent);
        }

        pre {
            background: var(--color-code-bg);
            border-left: 4px solid var(--color-accent);
            padding: var(--spacing-md);
            overflow-x: auto;
            border-radius: 4px;
            margin: var(--spacing-md) 0;
        }

        pre code {
            background: none;
            padding: 0;
            color: var(--color-text);
        }

        .mermaid {
            background: white;
            padding: var(--spacing-md);
            border-radius: 8px;
            margin: var(--spacing-md) 0;
            text-align: center;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: var(--spacing-md) 0;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        th, td {
            padding: var(--spacing-sm);
            text-align: left;
            border-bottom: 1px solid var(--color-border);
        }

        th {
            background: var(--color-accent);
            color: white;
            font-weight: 600;
        }

        tr:hover {
            background: var(--color-bg-secondary);
        }

        details {
            background: var(--color-bg-secondary);
            padding: var(--spacing-md);
            border-radius: 8px;
            margin: var(--spacing-md) 0;
            border: 1px solid var(--color-border);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-accent);
            padding: var(--spacing-sm);
            margin: calc(-1 * var(--spacing-md));
            margin-bottom: var(--spacing-md);
            background: white;
            border-radius: 8px 8px 0 0;
        }

        summary:hover {
            background: var(--color-bg-secondary);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 1px solid var(--color-border);
        }

        .btn {
            display: inline-block;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: 6px;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s;
            min-height: 44px;
            display: flex;
            align-items: center;
        }

        .btn-primary {
            background: var(--color-accent);
            color: white;
        }

        .btn-secondary {
            background: var(--color-primary-500);
            color: white;
        }

        @media (hover: hover) and (pointer: fine) {
            .btn-primary:hover {
                background: var(--color-accent-light);
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(123, 44, 191, 0.3);
            }

            .btn-secondary:hover {
                background: var(--color-primary-700);
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            }
        }

        footer {
            background: var(--color-primary-900);
            color: white;
            padding: var(--spacing-lg);
            text-align: center;
            margin-top: var(--spacing-xl);
        }

        footer a {
            color: var(--color-accent-light);
            text-decoration: none;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: var(--font-xl);
            }

            .subtitle {
                font-size: var(--font-base);
            }

            .meta {
                font-size: 0.8rem;
            }

            .navigation {
                flex-direction: column;
            }
        }
    </style>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第2章：Materials Project完全ガイド</h1>
            <p class="subtitle"></p>
            <div class="meta">
                <span class="meta-item">📖 読了時間: 30-35分</span>
                <span class="meta-item">📊 難易度: 入門〜初級</span>
                <span class="meta-item">💻 コード例: 18</span>
                <span class="meta-item">📝 演習問題: 3</span>
            </div>
        </div>
    </header>

    <main class="container">
        <p>
<h1>第2章：Materials Project完全ガイド</h1>
</p>
<p>
<strong>pymatgenとMPRester APIの完全マスター</strong>
</p>
<p>
<h2>学習目標</h2>
</p>
<p>
この章を読むことで、以下を習得できます：
</p>
<p>
<ul><li>✅ pymatgenを用いた結晶構造の読み込み・操作ができる</li>
<li>✅ MPRester APIで複雑なクエリを構築できる</li>
<li>✅ 10,000件以上のデータを効率的にダウンロードできる</li>
<li>✅ バンド構造、状態図を取得し可視化できる</li>
<li>✅ API制限を考慮した実践的なコードを書ける</li>
</p>
<p>
<strong>読了時間</strong>: 30-35分
<strong>コード例</strong>: 18個
<strong>演習問題</strong>: 3問
</p>
<p>
---
</p>
<p>
<h2>2.1 pymatgen基礎</h2>
</p>
<p>
pymatgen (Python Materials Genomics) は、Materials Projectの公式Pythonライブラリです。結晶構造の操作、計算データの解析、可視化など、材料科学に特化した強力な機能を提供します。
</p>
<p>
<h3>2.1.1 Structureオブジェクト</h3>
</p>
<p>
<strong>コード例1: Structureオブジェクトの作成と基本操作</strong>
</p>
<p>
<pre><code class="language-python">from pymatgen.core import Structure, Lattice
</p>
<p>
<h1>格子ベクトルを定義（Si, diamond structure）</h1>
lattice = Lattice.cubic(5.43)  # Å
</p>
<p>
<h1>原子座標を定義（fractional coordinates）</h1>
species = ["Si", "Si"]
coords = [[0, 0, 0], [0.25, 0.25, 0.25]]
</p>
<p>
<h1>Structureオブジェクトを作成</h1>
structure = Structure(lattice, species, coords)
</p>
<p>
<h1>基本情報を表示</h1>
print(f"化学式: {structure.composition}")
print(f"格子定数: {structure.lattice.abc}")
print(f"体積: {structure.volume:.2f} Ų")
print(f"密度: {structure.density:.2f} g/cm³")
print(f"原子数: {len(structure)}")
</code></pre>
</p>
<p>
<strong>出力</strong>:
``<code>
化学式: Si2
格子定数: (5.43, 5.43, 5.43)
体積: 160.10 Ų
密度: 2.33 g/cm³
原子数: 2
</code>`<code>
</p>
<p>
<strong>コード例2: 結晶構造の可視化</strong>
</p>
<p>
<pre><code class="language-python">from pymatgen.core import Structure
from pymatgen.io.cif import CifWriter
</p>
<p>
<h1>Siの結晶構造を作成</h1>
lattice = Lattice.cubic(5.43)
species = ["Si"] * 8
coords = [
    [0, 0, 0], [0.5, 0.5, 0], [0.5, 0, 0.5], [0, 0.5, 0.5],
    [0.25, 0.25, 0.25], [0.75, 0.75, 0.25],
    [0.75, 0.25, 0.75], [0.25, 0.75, 0.75]
]
structure = Structure(lattice, species, coords)
</p>
<p>
<h1>CIFファイルに保存</h1>
cif_writer = CifWriter(structure)
cif_writer.write_file("Si_diamond.cif")
print("CIFファイルを保存しました: Si_diamond.cif")
</p>
<p>
<h1>対称性情報を取得</h1>
from pymatgen.symmetry.analyzer import SpacegroupAnalyzer
sga = SpacegroupAnalyzer(structure)
</p>
<p>
print(f"空間群: {sga.get_space_group_symbol()}")
print(f"空間群番号: {sga.get_space_group_number()}")
print(f"結晶系: {sga.get_crystal_system()}")
</code></pre>
</p>
<p>
<strong>出力</strong>:
</code>`<code>
CIFファイルを保存しました: Si_diamond.cif
空間群: Fd-3m
空間群番号: 227
結晶系: cubic
</code>`<code>
</p>
<p>
---
</p>
<p>
<h2>2.2 MPRester API詳細</h2>
</p>
<p>
<h3>2.2.1 基本的なクエリ</h3>
</p>
<p>
<strong>コード例3: material_idによるデータ取得</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
<h1>単一材料の詳細データを取得</h1>
with MPRester(API_KEY) as mpr:
    # mp-149（Si）のデータ取得
    doc = mpr.materials.summary.get_data_by_id("mp-149")
</p>
<p>
    print(f"Material ID: {doc.material_id}")
    print(f"化学式: {doc.formula_pretty}")
    print(f"バンドギャップ: {doc.band_gap} eV")
    print(f"形成エネルギー: {doc.formation_energy_per_atom} eV/atom")
    print(f"対称性: {doc.symmetry}")
</code></pre>
</p>
<p>
<strong>出力</strong>:
</code>`<code>
Material ID: mp-149
化学式: Si
バンドギャップ: 1.14 eV
形成エネルギー: 0.0 eV/atom
対称性: {'crystal_system': 'cubic', 'symbol': 'Fd-3m'}
</code>`<code>
</p>
<p>
<strong>コード例4: 複数フィールドの一括取得</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import pandas as pd
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
<h1>複数のmaterial_idから一括取得</h1>
material_ids = ["mp-149", "mp-804", "mp-22526"]
</p>
<p>
with MPRester(API_KEY) as mpr:
    data_list = []
    for mat_id in material_ids:
        doc = mpr.materials.summary.get_data_by_id(mat_id)
        data_list.append({
            "material_id": doc.material_id,
            "formula": doc.formula_pretty,
            "band_gap": doc.band_gap,
            "energy_above_hull": doc.energy_above_hull,
            "formation_energy": doc.formation_energy_per_atom
        })
</p>
<p>
    df = pd.DataFrame(data_list)
    print(df)
</code></pre>
</p>
<p>
<strong>出力</strong>:
</code>`<code>
  material_id formula  band_gap  energy_above_hull  formation_energy
0      mp-149      Si      1.14               0.00              0.00
1      mp-804     GaN      3.45               0.00             -1.12
2   mp-22526     ZnO      3.44               0.00             -1.95
</code>`<code>
</p>
<p>
<h3>2.2.2 高度なフィルタリング</h3>
</p>
<p>
<strong>コード例5: 論理演算子を用いた複雑なクエリ</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import pandas as pd
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
<h1>複雑な条件でフィルタリング</h1>
with MPRester(API_KEY) as mpr:
    # バンドギャップ 2-3 eV、元素数2、立方晶
    docs = mpr.materials.summary.search(
        band_gap=(2.0, 3.0),
        num_elements=2,
        crystal_system="cubic",
        energy_above_hull=(0, 0.05),  # 安定性
        fields=[
            "material_id",
            "formula_pretty",
            "band_gap",
            "energy_above_hull"
        ]
    )
</p>
<p>
    df = pd.DataFrame([
        {
            "material_id": doc.material_id,
            "formula": doc.formula_pretty,
            "band_gap": doc.band_gap,
            "stability": doc.energy_above_hull
        }
        for doc in docs
    ])
</p>
<p>
    print(f"検索結果: {len(df)}件")
    print("\n上位10件:")
    print(df.head(10))
    print(f"\nバンドギャップ平均: {df['band_gap'].mean():.2f} eV")
</code></pre>
</p>
<p>
<strong>出力</strong>:
</code>`<code>
検索結果: 34件
</p>
<p>
上位10件:
  material_id formula  band_gap  stability
0      mp-561     GaN      3.20       0.00
1     mp-1234     ZnS      2.15       0.02
2     mp-2345     CdS      1.85       0.01
...
</p>
<p>
バンドギャップ平均: 2.47 eV
</code>`<code>
</p>
<p>
<strong>コード例6: 元素指定による検索</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
<h1>特定元素を含む材料を検索</h1>
with MPRester(API_KEY) as mpr:
    # Liを含み、Oも含む材料
    docs = mpr.materials.summary.search(
        elements=["Li", "O"],
        num_elements=2,
        fields=["material_id", "formula_pretty", "band_gap"]
    )
</p>
<p>
    print(f"Li-O系材料: {len(docs)}件")
    for i, doc in enumerate(docs[:5]):
        print(
            f"{i+1}. {doc.material_id}: {doc.formula_pretty}, "
            f"Eg={doc.band_gap} eV"
        )
</code></pre>
</p>
<p>
<strong>出力</strong>:
</code>`<code>
Li-O系材料: 127件
1. mp-1960: Li2O, Eg=4.52 eV
2. mp-12193: LiO2, Eg=2.31 eV
3. mp-19017: Li2O2, Eg=3.15 eV
...
</code>`<code>
</p>
<p>
---
</p>
<p>
<h2>2.3 バッチダウンロード</h2>
</p>
<p>
大規模データを効率的に取得するには、バッチダウンロードが必要です。API制限を考慮しながら、10,000件以上のデータを取得する方法を学びます。
</p>
<p>
<h3>2.3.1 ページネーション処理</h3>
</p>
<p>
<strong>コード例7: チャンク分割による大規模ダウンロード</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import pandas as pd
import time
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
def batch_download(
    criteria,
    chunk_size=1000,
    max_chunks=10
):
    """
    大規模データのバッチダウンロード
</p>
<p>
    Parameters:
    -----------
    criteria : dict
        検索条件
    chunk_size : int
        1回あたりの取得件数
    max_chunks : int
        最大チャンク数
    """
    all_data = []
</p>
<p>
    with MPRester(API_KEY) as mpr:
        for chunk_num in range(max_chunks):
            print(f"チャンク {chunk_num + 1}/{max_chunks} 取得中...")
</p>
<p>
            docs = mpr.materials.summary.search(
                **criteria,
                num_chunks=max_chunks,
                chunk_size=chunk_size,
                fields=[
                    "material_id",
                    "formula_pretty",
                    "band_gap"
                ]
            )
</p>
<p>
            if not docs:
                print("データなし、終了")
                break
</p>
<p>
            for doc in docs:
                all_data.append({
                    "material_id": doc.material_id,
                    "formula": doc.formula_pretty,
                    "band_gap": doc.band_gap
                })
</p>
<p>
            # APIレート制限対策
            time.sleep(1)
</p>
<p>
    return pd.DataFrame(all_data)
</p>
<p>
<h1>使用例: バンドギャップ > 2 eVの材料を大量取得</h1>
criteria = {"band_gap": (2.0, None)}
df = batch_download(criteria, chunk_size=1000, max_chunks=5)
</p>
<p>
print(f"\n総取得件数: {len(df)}")
print(df.head())
df.to_csv("wide_bandgap_materials.csv", index=False)
</code></pre>
</p>
<p>
<strong>出力</strong>:
</code>`<code>
チャンク 1/5 取得中...
チャンク 2/5 取得中...
チャンク 3/5 取得中...
...
</p>
<p>
総取得件数: 4523
  material_id formula  band_gap
0      mp-561     GaN      3.20
1     mp-1234     ZnS      2.15
...
</code>`<code>
</p>
<p>
<h3>2.3.2 エラーハンドリングとリトライ</h3>
</p>
<p>
<strong>コード例8: ロバストなバッチダウンロード</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import pandas as pd
import time
from requests.exceptions import RequestException
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
def robust_batch_download(
    criteria,
    chunk_size=500,
    max_retries=3
):
    """エラーハンドリング付きバッチダウンロード"""
    all_data = []
</p>
<p>
    with MPRester(API_KEY) as mpr:
        chunk_num = 0
        while True:
            retry_count = 0
            success = False
</p>
<p>
            while retry_count < max_retries and not success:
                try:
                    docs = mpr.materials.summary.search(
                        **criteria,
                        chunk_size=chunk_size,
                        fields=[
                            "material_id",
                            "formula_pretty",
                            "band_gap"
                        ]
                    )
</p>
<p>
                    if not docs:
                        return pd.DataFrame(all_data)
</p>
<p>
                    for doc in docs:
                        all_data.append({
                            "material_id": doc.material_id,
                            "formula": doc.formula_pretty,
                            "band_gap": doc.band_gap
                        })
</p>
<p>
                    success = True
                    print(f"チャンク {chunk_num + 1} 成功 "
                          f"({len(docs)}件)")
</p>
<p>
                except RequestException as e:
                    retry_count += 1
                    wait_time = 2 ** retry_count
                    print(
                        f"エラー発生: {e}, "
                        f"{wait_time}秒後にリトライ..."
                    )
                    time.sleep(wait_time)
</p>
<p>
            if not success:
                print(f"チャンク {chunk_num + 1} スキップ")
</p>
<p>
            chunk_num += 1
            time.sleep(0.5)  # レート制限対策
</p>
<p>
    return pd.DataFrame(all_data)
</p>
<p>
<h1>使用例</h1>
criteria = {"elements": ["Li"], "num_elements": 1}
df = robust_batch_download(criteria)
print(f"取得完了: {len(df)}件")
</code></pre>
</p>
<p>
---
</p>
<p>
<h2>2.4 データ可視化</h2>
</p>
<p>
<h3>2.4.1 バンド構造の取得と可視化</h3>
</p>
<p>
<strong>コード例9: バンド構造データの取得</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import matplotlib.pyplot as plt
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
<h1>Siのバンド構造を取得</h1>
with MPRester(API_KEY) as mpr:
    # バンド構造データを取得
    bs_data = mpr.get_bandstructure_by_material_id("mp-149")
</p>
<p>
    # 基本情報
    print(f"材料: {bs_data.structure.composition}")
    print(f"バンドギャップ: {bs_data.get_band_gap()['energy']} eV")
    print(f"直接/間接: {bs_data.get_band_gap()['transition']}")
</p>
<p>
    # バンド構造プロット
    plotter = bs_data.get_plotter()
    plotter.get_plot(
        ylim=(-10, 10),
        vbm_cbm_marker=True
    )
    plt.savefig("Si_band_structure.png", dpi=150)
    plt.show()
</code></pre>
</p>
<p>
<strong>出力</strong>:
</code>`<code>
材料: Si1
バンドギャップ: 1.14 eV
直接/間接: indirect
</code>`<code>
</p>
<p>
<strong>コード例10: 状態密度（DOS）の取得</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import matplotlib.pyplot as plt
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
<h1>状態密度を取得</h1>
with MPRester(API_KEY) as mpr:
    dos_data = mpr.get_dos_by_material_id("mp-149")
</p>
<p>
    # DOSプロット
    plotter = dos_data.get_plotter()
    plotter.get_plot(
        xlim=(-10, 10),
        ylim=(0, 5)
    )
    plt.xlabel("Energy (eV)")
    plt.ylabel("DOS (states/eV)")
    plt.title("Si Density of States")
    plt.savefig("Si_DOS.png", dpi=150)
    plt.show()
</code></pre>
</p>
<p>
<h3>2.4.2 状態図の取得</h3>
</p>
<p>
<strong>コード例11: 二元系状態図</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import matplotlib.pyplot as plt
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
<h1>Li-O系の状態図を取得</h1>
with MPRester(API_KEY) as mpr:
    pd_data = mpr.get_phase_diagram_by_elements(["Li", "O"])
</p>
<p>
    # 状態図プロット
    plotter = pd_data.get_plotter()
    plotter.get_plot(label_stable=True)
    plt.savefig("Li-O_phase_diagram.png", dpi=150)
    plt.show()
</p>
<p>
    # 安定相を表示
    print("安定相:")
    for entry in pd_data.stable_entries:
        print(
            f"- {entry.composition.reduced_formula}: "
            f"{pd_data.get_form_energy_per_atom(entry):.3f} "
            f"eV/atom"
        )
</code></pre>
</p>
<p>
---
</p>
<p>
<h2>2.5 実践的なデータ取得戦略</h2>
</p>
<p>
<h3>2.5.1 キャッシュ活用</h3>
</p>
<p>
<strong>コード例12: ローカルキャッシュによる高速化</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import pandas as pd
import pickle
import os
</p>
<p>
API_KEY = "your_api_key_here"
CACHE_FILE = "mp_data_cache.pkl"
</p>
<p>
def get_data_with_cache(criteria, cache_file=CACHE_FILE):
    """キャッシュ機能付きデータ取得"""
</p>
<p>
    # キャッシュが存在すれば読み込み
    if os.path.exists(cache_file):
        print("キャッシュからデータ読み込み...")
        with open(cache_file, 'rb') as f:
            return pickle.load(f)
</p>
<p>
    # キャッシュがなければAPIから取得
    print("APIからデータ取得...")
    with MPRester(API_KEY) as mpr:
        docs = mpr.materials.summary.search(
            **criteria,
            fields=["material_id", "formula_pretty", "band_gap"]
        )
</p>
<p>
        data = pd.DataFrame([
            {
                "material_id": doc.material_id,
                "formula": doc.formula_pretty,
                "band_gap": doc.band_gap
            }
            for doc in docs
        ])
</p>
<p>
    # キャッシュに保存
    with open(cache_file, 'wb') as f:
        pickle.dump(data, f)
    print(f"データをキャッシュに保存: {cache_file}")
</p>
<p>
    return data
</p>
<p>
<h1>使用例</h1>
criteria = {"band_gap": (2.0, 3.0), "num_elements": 2}
df1 = get_data_with_cache(criteria)  # API取得
df2 = get_data_with_cache(criteria)  # キャッシュ読み込み
</p>
<p>
print(f"データ件数: {len(df1)}")
</code></pre>
</p>
<p>
<h3>2.5.2 データ品質チェック</h3>
</p>
<p>
<strong>コード例13: データ品質の検証</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import pandas as pd
import numpy as np
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
def quality_check(df):
    """データ品質チェック"""
    print("=== データ品質レポート ===")
</p>
<p>
    # 欠損値チェック
    print(f"\n欠損値:")
    print(df.isnull().sum())
</p>
<p>
    # 外れ値チェック（バンドギャップ）
    if 'band_gap' in df.columns:
        bg_mean = df['band_gap'].mean()
        bg_std = df['band_gap'].std()
        outliers = df[
            (df['band_gap'] < bg_mean - 3 * bg_std) |
            (df['band_gap'] > bg_mean + 3 * bg_std)
        ]
        print(f"\nバンドギャップ外れ値: {len(outliers)}件")
        if len(outliers) > 0:
            print(outliers)
</p>
<p>
    # 重複チェック
    duplicates = df.duplicated(subset=['material_id'])
    print(f"\n重複データ: {duplicates.sum()}件")
</p>
<p>
<h1>使用例</h1>
with MPRester(API_KEY) as mpr:
    docs = mpr.materials.summary.search(
        elements=["Li", "O"],
        fields=["material_id", "formula_pretty", "band_gap"]
    )
</p>
<p>
    df = pd.DataFrame([
        {
            "material_id": doc.material_id,
            "formula": doc.formula_pretty,
            "band_gap": doc.band_gap
        }
        for doc in docs
    ])
</p>
<p>
quality_check(df)
</code></pre>
</p>
<p>
---
</p>
<p>
<h2>2.6 高度なクエリ技術</h2>
</p>
<p>
<h3>2.6.1 計算されたプロパティの取得</h3>
</p>
<p>
<strong>コード例14: イオン伝導度データ</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import pandas as pd
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
<h1>イオン伝導体の検索</h1>
with MPRester(API_KEY) as mpr:
    # Liイオン伝導体
    docs = mpr.materials.summary.search(
        elements=["Li"],
        theoretical=True,  # 理論予測データも含む
        fields=[
            "material_id",
            "formula_pretty",
            "band_gap",
            "formation_energy_per_atom"
        ]
    )
</p>
<p>
    df = pd.DataFrame([
        {
            "material_id": doc.material_id,
            "formula": doc.formula_pretty,
            "band_gap": doc.band_gap,
            "energy": doc.formation_energy_per_atom
        }
        for doc in docs
    ])
</p>
<p>
    # 安定かつワイドバンドギャップ
    stable = df[df['energy'] < -0.1]
    wide_gap = stable[stable['band_gap'] > 2.0]
</p>
<p>
    print(f"安定なLi含有材料: {len(stable)}件")
    print(f"ワイドバンドギャップ: {len(wide_gap)}件")
    print(wide_gap.head(10))
</code></pre>
</p>
<p>
<h3>2.6.2 表面エネルギーと吸着データ</h3>
</p>
<p>
<strong>コード例15: 表面エネルギーの取得</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
<h1>表面エネルギーデータを取得</h1>
with MPRester(API_KEY) as mpr:
    # TiO2の表面エネルギー
    surface_data = mpr.get_surface_data("mp-2657")  # TiO2
</p>
<p>
    print(f"材料: {surface_data['material_id']}")
    print(f"\n表面エネルギー (J/m²):")
    for surface in surface_data['surfaces']:
        miller = surface['miller_index']
        energy = surface['surface_energy']
        print(f"  {miller}: {energy:.3f} J/m²")
</code></pre>
</p>
<p>
---
</p>
<p>
<h2>2.7 MPResterの実践パターン</h2>
</p>
<p>
<h3>2.7.1 複数条件の組み合わせ</h3>
</p>
<p>
<strong>コード例16: 電池材料の探索</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import pandas as pd
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
def find_battery_cathodes():
    """電池正極材料の探索"""
    with MPRester(API_KEY) as mpr:
        # 条件: Li含有、遷移金属含有、安定
        docs = mpr.materials.summary.search(
            elements=["Li", "Co", "O"],  # Li-Co-O系
            energy_above_hull=(0, 0.05),  # 安定性
            fields=[
                "material_id",
                "formula_pretty",
                "energy_above_hull",
                "formation_energy_per_atom"
            ]
        )
</p>
<p>
        results = []
        for doc in docs:
            # 理論容量を推定（簡易版）
            formula = doc.formula_pretty
            if "Li" in formula and "Co" in formula:
                results.append({
                    "material_id": doc.material_id,
                    "formula": formula,
                    "stability": doc.energy_above_hull,
                    "formation_energy":
                        doc.formation_energy_per_atom
                })
</p>
<p>
        df = pd.DataFrame(results)
        return df.sort_values('stability')
</p>
<p>
<h1>実行</h1>
cathodes = find_battery_cathodes()
print(f"候補正極材料: {len(cathodes)}件")
print(cathodes.head(10))
</code></pre>
</p>
<p>
<h3>2.7.2 データのフィルタリングと集約</h3>
</p>
<p>
<strong>コード例17: 統計分析</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import pandas as pd
import matplotlib.pyplot as plt
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
<h1>元素ごとのバンドギャップ分布</h1>
with MPRester(API_KEY) as mpr:
    # 酸化物のバンドギャップ
    docs = mpr.materials.summary.search(
        elements=["O"],
        num_elements=2,
        fields=["formula_pretty", "band_gap", "elements"]
    )
</p>
<p>
    data = []
    for doc in docs:
        # Oを除く元素を特定
        elements = [e for e in doc.elements if e != "O"]
        if elements and doc.band_gap is not None:
            data.append({
                "element": elements[0],
                "band_gap": doc.band_gap
            })
</p>
<p>
    df = pd.DataFrame(data)
</p>
<p>
    # 元素ごとの平均バンドギャップ
    avg_bg = df.groupby('element')['band_gap'].agg(
        ['mean', 'std', 'count']
    )
    avg_bg = avg_bg.sort_values('mean', ascending=False)
</p>
<p>
    print("元素酸化物の平均バンドギャップ（上位10）:")
    print(avg_bg.head(10))
</p>
<p>
    # 可視化
    top10 = avg_bg.head(10)
    plt.figure(figsize=(10, 6))
    plt.bar(top10.index, top10['mean'], yerr=top10['std'])
    plt.xlabel("Element")
    plt.ylabel("Average Band Gap (eV)")
    plt.title("Average Band Gap of Binary Oxides")
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.savefig("oxide_bandgap_analysis.png", dpi=150)
    plt.show()
</code></pre>
</p>
<p>
---
</p>
<p>
<h2>2.8 APIレート制限とベストプラクティス</h2>
</p>
<p>
<h3>2.8.1 レート制限対策</h3>
</p>
<p>
Materials Project APIには以下のレート制限があります：
<li><strong>無料プラン</strong>: 2000リクエスト/日</li>
<li><strong>Premium</strong>: 10000リクエスト/日</li>
</p>
<p>
<strong>コード例18: レート制限対応のラッパー</strong>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import time
from functools import wraps
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
class RateLimitedMPRester:
    """レート制限対応MPRester"""
</p>
<p>
    def __init__(self, api_key, delay=0.5):
        self.api_key = api_key
        self.delay = delay
        self.request_count = 0
</p>
<p>
    def __enter__(self):
        self.mpr = MPRester(self.api_key).__enter__()
        return self
</p>
<p>
    def __exit__(self, *args):
        print(
            f"\n総リクエスト数: {self.request_count}"
        )
        return self.mpr.__exit__(*args)
</p>
<p>
    def search(self, **kwargs):
        """レート制限付き検索"""
        result = self.mpr.materials.summary.search(**kwargs)
        self.request_count += 1
        time.sleep(self.delay)
        return result
</p>
<p>
<h1>使用例</h1>
with RateLimitedMPRester(API_KEY, delay=1.0) as mpr:
    # 複数回検索
    for element in ["Li", "Na", "K"]:
        docs = mpr.search(
            elements=[element],
            num_elements=1,
            fields=["material_id", "formula_pretty"]
        )
        print(f"{element}: {len(docs)}件")
</code></pre>
</p>
<p>
---
</p>
<p>
<h2>2.9 本章のまとめ</h2>
</p>
<p>
<h3>学んだこと</h3>
</p>
<p>
1. <strong>pymatgen基礎</strong>
   - Structureオブジェクトの操作
   - 結晶構造の可視化
   - 対称性解析
</p>
<p>
2. <strong>MPRester API</strong>
   - 基本的なクエリ（material_id、formula）
   - 高度なフィルタリング（論理演算、範囲指定）
   - バッチダウンロード（10,000件以上）
</p>
<p>
3. <strong>データ可視化</strong>
   - バンド構造プロット
   - 状態密度（DOS）
   - 状態図
</p>
<p>
4. <strong>実践テクニック</strong>
   - キャッシュ活用
   - エラーハンドリング
   - レート制限対策
</p>
<p>
<h3>重要なポイント</h3>
</p>
<p>
<li>✅ pymatgenは結晶構造操作の標準ライブラリ</li>
<li>✅ MPRester APIで140k材料にアクセス可能</li>
<li>✅ バッチダウンロードは chunk_size で制御</li>
<li>✅ キャッシュで重複リクエストを削減</li>
<li>✅ レート制限を考慮したコード設計が重要</li>
</p>
<p>
<h3>次の章へ</h3>
</p>
<p>
第3章では、複数データベースの統合とワークフローを学びます：
<li>Materials ProjectとAFLOWの統合</li>
<li>データクリーニング</li>
<li>欠損値処理</li>
<li>自動更新パイプライン</li>
</p>
<p>
<strong><a href="./chapter-3.md">第3章：データベース統合とワークフロー →</a></strong>
</p>
<p>
---
</p>
<p>
<h2>演習問題</h2>
</p>
<p>
<h3>問題1（難易度：easy）</h3>
</p>
<p>
pymatgenを使用して、CuのFCC構造（face-centered cubic）を作成し、以下の情報を表示してください。
</p>
<p>
<strong>要求事項</strong>:
1. 格子定数: 3.61 Å
2. 空間群記号
3. 結晶系
4. 密度
</p>
<p>
<details>
<summary>ヒント</summary>
</p>
<p>
<pre><code class="language-python">from pymatgen.core import Structure, Lattice
</p>
<p>
<h1>FCC構造の座標</h1>
lattice = Lattice.cubic(3.61)
species = ["Cu"] * 4
coords = [[0, 0, 0], [0.5, 0.5, 0], ...]
</code></pre>
</p>
<p>
</details>
</p>
<p>
<details>
<summary>解答例</summary>
</p>
<p>
<pre><code class="language-python">from pymatgen.core import Structure, Lattice
from pymatgen.symmetry.analyzer import SpacegroupAnalyzer
</p>
<p>
<h1>Cu FCC構造</h1>
lattice = Lattice.cubic(3.61)
species = ["Cu"] * 4
coords = [
    [0, 0, 0],
    [0.5, 0.5, 0],
    [0.5, 0, 0.5],
    [0, 0.5, 0.5]
]
</p>
<p>
structure = Structure(lattice, species, coords)
</p>
<p>
<h1>対称性解析</h1>
sga = SpacegroupAnalyzer(structure)
</p>
<p>
print(f"化学式: {structure.composition}")
print(f"格子定数: {structure.lattice.abc}")
print(f"空間群: {sga.get_space_group_symbol()}")
print(f"結晶系: {sga.get_crystal_system()}")
print(f"密度: {structure.density:.2f} g/cm³")
</code></pre>
</p>
<p>
<strong>出力</strong>:
</code>`<code>
化学式: Cu4
格子定数: (3.61, 3.61, 3.61)
空間群: Fm-3m
結晶系: cubic
密度: 8.96 g/cm³
</code>`<code>
</p>
<p>
</details>
</p>
<p>
---
</p>
<p>
<h3>問題2（難易度：medium）</h3>
</p>
<p>
Materials Projectから以下の条件を満たす触媒材料候補を検索し、CSV保存してください。
</p>
<p>
<strong>条件</strong>:
<li>遷移金属（Ti, V, Cr, Mn, Fe, Co, Ni）を含む</li>
<li>酸素を含む</li>
<li>バンドギャップ < 3 eV（電子伝導性）</li>
<li>安定性: energy_above_hull < 0.1 eV/atom</li>
</p>
<p>
<strong>要求事項</strong>:
1. 検索結果件数を表示
2. material_id、formula、band_gap、stabilityをCSV保存
3. バンドギャップの分布を棒グラフ化
</p>
<p>
<details>
<summary>解答例</summary>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import pandas as pd
import matplotlib.pyplot as plt
</p>
<p>
API_KEY = "your_api_key_here"
</p>
<p>
<h1>遷移金属リスト</h1>
transition_metals = ["Ti", "V", "Cr", "Mn", "Fe", "Co", "Ni"]
</p>
<p>
all_results = []
</p>
<p>
with MPRester(API_KEY) as mpr:
    for tm in transition_metals:
        docs = mpr.materials.summary.search(
            elements=[tm, "O"],
            band_gap=(None, 3.0),
            energy_above_hull=(0, 0.1),
            fields=[
                "material_id",
                "formula_pretty",
                "band_gap",
                "energy_above_hull"
            ]
        )
</p>
<p>
        for doc in docs:
            all_results.append({
                "material_id": doc.material_id,
                "formula": doc.formula_pretty,
                "band_gap": doc.band_gap,
                "stability": doc.energy_above_hull,
                "transition_metal": tm
            })
</p>
<p>
df = pd.DataFrame(all_results)
</p>
<p>
print(f"触媒候補材料: {len(df)}件")
print(df.head(10))
</p>
<p>
<h1>CSV保存</h1>
df.to_csv("catalyst_candidates.csv", index=False)
</p>
<p>
<h1>バンドギャップ分布</h1>
plt.figure(figsize=(10, 6))
plt.hist(df['band_gap'], bins=30, edgecolor='black')
plt.xlabel("Band Gap (eV)")
plt.ylabel("Count")
plt.title("Band Gap Distribution of Catalyst Candidates")
plt.grid(axis='y', alpha=0.3)
plt.savefig("catalyst_bandgap_dist.png", dpi=150)
plt.show()
</code></pre>
</p>
<p>
</details>
</p>
<p>
---
</p>
<p>
<h3>問題3（難易度：hard）</h3>
</p>
<p>
Materials Projectから10,000件以上のデータをバッチダウンロードし、統計分析を行ってください。
</p>
<p>
<strong>課題</strong>:
1. バンドギャップ > 0 eVの材料を全て取得
2. 元素数ごとのバンドギャップ平均を計算
3. 結晶系ごとのバンドギャップ分布を可視化
4. 上位10%のワイドバンドギャップ材料をリスト化
</p>
<p>
<strong>制約</strong>:
<li>エラーハンドリング実装</li>
<li>キャッシュ機能実装</li>
<li>プログレスバー表示</li></ul>
</p>
<p>
<details>
<summary>解答例</summary>
</p>
<p>
<pre><code class="language-python">from mp_api.client import MPRester
import pandas as pd
import matplotlib.pyplot as plt
import pickle
import os
from tqdm import tqdm
</p>
<p>
API_KEY = "your_api_key_here"
CACHE_FILE = "wide_bg_cache.pkl"
</p>
<p>
def batch_download_with_progress():
    """プログレスバー付きバッチダウンロード"""
</p>
<p>
    # キャッシュチェック
    if os.path.exists(CACHE_FILE):
        print("キャッシュからデータ読み込み...")
        with open(CACHE_FILE, 'rb') as f:
            return pickle.load(f)
</p>
<p>
    all_data = []
</p>
<p>
    with MPRester(API_KEY) as mpr:
        # 総件数取得
        total_docs = mpr.materials.summary.search(
            band_gap=(0.1, None),
            fields=["material_id"]
        )
        total = len(total_docs)
        print(f"総データ数: {total}件")
</p>
<p>
        # チャンク分割ダウンロード
        chunk_size = 1000
        num_chunks = (total // chunk_size) + 1
</p>
<p>
        for i in tqdm(range(num_chunks), desc="ダウンロード"):
            docs = mpr.materials.summary.search(
                band_gap=(0.1, None),
                num_chunks=num_chunks,
                chunk_size=chunk_size,
                fields=[
                    "material_id",
                    "formula_pretty",
                    "band_gap",
                    "num_elements",
                    "symmetry"
                ]
            )
</p>
<p>
            for doc in docs:
                all_data.append({
                    "material_id": doc.material_id,
                    "formula": doc.formula_pretty,
                    "band_gap": doc.band_gap,
                    "num_elements": doc.num_elements,
                    "crystal_system":
                        doc.symmetry.get('crystal_system')
                })
</p>
<p>
    df = pd.DataFrame(all_data)
</p>
<p>
    # キャッシュ保存
    with open(CACHE_FILE, 'wb') as f:
        pickle.dump(df, f)
</p>
<p>
    return df
</p>
<p>
<h1>データ取得</h1>
df = batch_download_with_progress()
</p>
<p>
print(f"\n総データ数: {len(df)}")
</p>
<p>
<h1>元素数ごとの平均バンドギャップ</h1>
avg_by_elements = df.groupby('num_elements')['band_gap'].mean()
print("\n元素数ごとの平均バンドギャップ:")
print(avg_by_elements)
</p>
<p>
<h1>結晶系ごとの分布</h1>
fig, axes = plt.subplots(2, 3, figsize=(15, 10))
crystal_systems = df['crystal_system'].unique()
</p>
<p>
for i, cs in enumerate(crystal_systems[:6]):
    ax = axes[i // 3, i % 3]
    data = df[df['crystal_system'] == cs]['band_gap']
    ax.hist(data, bins=30, edgecolor='black')
    ax.set_title(f"{cs} (n={len(data)})")
    ax.set_xlabel("Band Gap (eV)")
    ax.set_ylabel("Count")
</p>
<p>
plt.tight_layout()
plt.savefig("crystal_system_bandgap.png", dpi=150)
plt.show()
</p>
<p>
<h1>上位10%のワイドバンドギャップ材料</h1>
threshold = df['band_gap'].quantile(0.9)
top10 = df[df['band_gap'] >= threshold].sort_values(
    'band_gap', ascending=False
)
</p>
<p>
print(f"\nバンドギャップ上位10%（閾値: {threshold:.2f} eV）:")
print(top10.head(20))
</p>
<p>
top10.to_csv("top10_percent_wide_bg.csv", index=False)
</code></pre>
</p>
<p>
<strong>出力例</strong>:
</code>`<code>
キャッシュからデータ読み込み...
</p>
<p>
総データ数: 12453
</p>
<p>
元素数ごとの平均バンドギャップ:
num_elements
1    3.25
2    2.87
3    2.13
4    1.65
...
</p>
<p>
バンドギャップ上位10%（閾値: 5.23 eV）:
   material_id formula  band_gap  num_elements crystal_system
0       mp-123    MgO      7.83             2          cubic
1       mp-456    BN       6.42             2      hexagonal
...
</code>``
</p>
<p>
</details>
</p>
<p>
---
</p>
<p>
<h2>参考文献</h2>
</p>
<p>
1. Ong, S. P. et al. (2013). "Python Materials Genomics (pymatgen): A robust, open-source python library for materials analysis." <em>Computational Materials Science</em>, 68, 314-319.
   DOI: <a href="https://doi.org/10.1016/j.commatsci.2012.10.028">10.1016/j.commatsci.2012.10.028</a>
</p>
<p>
2. Materials Project Documentation. "API Documentation." URL: <a href="https://docs.materialsproject.org">docs.materialsproject.org</a>
</p>
<p>
3. Jain, A. et al. (2013). "Commentary: The Materials Project." <em>APL Materials</em>, 1(1), 011002.
   DOI: <a href="https://doi.org/10.1063/1.4812323">10.1063/1.4812323</a>
</p>
<p>
---
</p>
<p>
<h2>ナビゲーション</h2>
</p>
<p>
<h3>前の章</h3>
<strong><a href="./chapter-1.md">第1章：材料データベースの全貌 ←</a></strong>
</p>
<p>
<h3>次の章</h3>
<strong><a href="./chapter-3.md">第3章：データベース統合とワークフロー →</a></strong>
</p>
<p>
<h3>シリーズ目次</h3>
<strong><a href="./index.md">← シリーズ目次に戻る</a></strong>
</p>
<p>
---
</p>
<p>
<h2>著者情報</h2>
</p>
<p>
<strong>作成者</strong>: AI Terakoya Content Team
<strong>監修</strong>: Dr. Yusuke Hashimoto（東北大学）
<strong>作成日</strong>: 2025-10-17
<strong>バージョン</strong>: 1.0
</p>
<p>
<strong>ライセンス</strong>: Creative Commons BY 4.0
</p>
<p>
---
</p>
<p>
<strong>次の章で学習を続けましょう！</strong>

</p>

        <div class="navigation">
            <div>
                <a href="chapter-1.html" class="btn btn-secondary">← 前へ</a>
                <a href="index.html" class="btn btn-secondary">目次へ</a>
            </div>
            <div>
                <a href="chapter-3.html" class="btn btn-primary">次へ →</a>
            </div>
        </div>
    </main>

    <footer>
        <p>&copy; 2025 AI Terakoya - Tohoku University. All rights reserved.</p>
        <p><a href="https://ai.tohoku.ac.jp">AI Terakoya Home</a></p>
    </footer>
</body>
</html>