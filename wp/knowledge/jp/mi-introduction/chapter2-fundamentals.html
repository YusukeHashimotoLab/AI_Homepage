<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="データ駆動型材料開発の理論と実践">
    <title>第2章：MIの基礎知識 - 概念・手法・エコシステム - MI Knowledge Hub</title>

    <!-- CSS Styling -->
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --bg-color: #ffffff;
            --text-color: #333333;
            --border-color: #e0e0e0;
            --code-bg: #f5f5f5;
            --link-color: #3498db;
            --link-hover: #2980b9;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Hiragino Sans", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem 1.5rem;
        }

        /* Header */
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header .container {
            padding: 0 1.5rem;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .meta {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
            font-size: 0.9rem;
            opacity: 0.95;
            margin-top: 1rem;
        }

        .meta span {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
        }

        /* Typography */
        h2 {
            font-size: 1.75rem;
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--secondary-color);
            color: var(--primary-color);
        }

        h3 {
            font-size: 1.4rem;
            margin-top: 2rem;
            margin-bottom: 0.8rem;
            color: var(--primary-color);
        }

        h4 {
            font-size: 1.2rem;
            margin-top: 1.5rem;
            margin-bottom: 0.6rem;
            color: var(--primary-color);
        }

        p {
            margin-bottom: 1.2rem;
        }

        a {
            color: var(--link-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--link-hover);
            text-decoration: underline;
        }

        /* Lists */
        ul, ol {
            margin-left: 2rem;
            margin-bottom: 1.2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        /* Code blocks */
        code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        pre {
            background: var(--code-bg);
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
        }

        pre code {
            background: none;
            padding: 0;
            font-size: 0.9rem;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
            overflow-x: auto;
            display: block;
        }

        thead {
            display: table;
            width: 100%;
            table-layout: fixed;
        }

        tbody {
            display: table;
            width: 100%;
            table-layout: fixed;
        }

        th, td {
            padding: 0.8rem;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background: var(--primary-color);
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--secondary-color);
            padding-left: 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: #666;
        }

        /* Images */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 1rem 0;
        }

        /* Mermaid diagrams */
        .mermaid {
            text-align: center;
            margin: 2rem 0;
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        /* Details/Summary (for exercises) */
        details {
            margin: 1rem 0;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--primary-color);
            padding: 0.5rem;
        }

        summary:hover {
            color: var(--secondary-color);
        }

        /* Footer */
        footer {
            margin-top: 4rem;
            padding: 2rem 0;
            border-top: 2px solid var(--border-color);
            text-align: center;
            color: #666;
            font-size: 0.9rem;
        }

        /* Navigation buttons */
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin: 3rem 0;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .nav-button {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            background: var(--secondary-color);
            color: white;
            border-radius: 6px;
            text-decoration: none;
            transition: all 0.3s;
            font-weight: 600;
        }

        .nav-button:hover {
            background: var(--link-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 1.6rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            pre {
                padding: 1rem;
                font-size: 0.85rem;
            }

            table {
                font-size: 0.9rem;
            }
        }
    </style>

    <!-- Mermaid for diagrams -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        // Mermaid.js Converter - Converts markdown-style mermaid code blocks to renderable divs
        document.addEventListener('DOMContentLoaded', function() {
            // Find all code blocks with class="language-mermaid"
            const mermaidCodeBlocks = document.querySelectorAll('pre.codehilite code.language-mermaid, pre code.language-mermaid');

            mermaidCodeBlocks.forEach(function(codeBlock) {
                const pre = codeBlock.parentElement;
                const mermaidCode = codeBlock.textContent;

                // Create a new div with mermaid class
                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = mermaidCode.trim();

                // Replace the pre element with the new div
                pre.parentNode.replaceChild(mermaidDiv, pre);
            });

            // Re-initialize mermaid after conversion
            if (typeof mermaid !== 'undefined') {
                mermaid.initialize({ startOnLoad: true, theme: 'default' });
                mermaid.init(undefined, document.querySelectorAll('.mermaid'));
            }
        });
    </script>
</head>
<body>
    <header>
        <div class="container">
            <h1>第2章：MIの基礎知識 - 概念・手法・エコシステム</h1>
            <div class="meta">
                <span>📖 読了時間: 不明</span>
                <span>📊 レベル: beginner-intermediate</span>
            </div>
        </div>
    </header>

    <main class="container">
        <h1 id="2mi-">第2章：MIの基礎知識 - 概念・手法・エコシステム</h1>
<h2 id="_1">学習目標</h2>
<p>この章を読むことで、以下を習得できます：<br />
- MIの定義と関連分野（計算材料科学、ケモインフォマティクス等）との違いを説明できる<br />
- 主要な材料データベース（Materials Project、AFLOW、OQMD、JARVIS）の特徴と使い分けを理解する<br />
- MIの基本ワークフロー5ステップ（問題定式化から検証まで）を詳細に説明できる<br />
- 材料記述子（組成、構造、物性ベース）の種類と重要性を理解する<br />
- MI領域で頻出する専門用語20語を正しく使用できる</p>
<hr />
<h2 id="21-mi">2.1 MIとは何か：定義と関連分野</h2>
<h3 id="211-materials-informatics">2.1.1 Materials Informaticsの語源と歴史</h3>
<p><strong>マテリアルズ・インフォマティクス（Materials Informatics, MI）</strong>という用語は、2000年代初頭から使われるようになりました。特に<strong>2011年の米国Materials Genome Initiative (MGI)</strong>の発足により、世界的に注目を集めるようになります [1]。</p>
<p><strong>MGIの目標:</strong><br />
- 新材料の開発期間を従来の半分に短縮<br />
- 開発コストを大幅に削減<br />
- 計算・実験・データの統合による加速</p>
<p>この取り組みは、ヒトゲノムプロジェクトが生物学を変革したように、材料科学を根本から変える可能性を秘めていると期待されました。</p>
<h3 id="212">2.1.2 定義</h3>
<p><strong>マテリアルズ・インフォマティクス（Materials Informatics, MI）</strong>とは、材料科学とデータサイエンスを融合させた学問分野です。大量の材料データと機械学習などの情報科学技術を活用して、新材料の発見や材料特性の予測を加速する手法です。</p>
<p><strong>簡潔な定義:</strong></p>
<blockquote>
<p>「データとAIの力で材料開発をスピードアップする科学」</p>
</blockquote>
<p><strong>コア要素:</strong><br />
1. <strong>データ</strong>: 実験データ、計算データ、論文からの知識<br />
2. <strong>計算</strong>: 第一原理計算、分子動力学シミュレーション<br />
3. <strong>機械学習</strong>: 予測モデル、最適化アルゴリズム<br />
4. <strong>実験検証</strong>: 予測結果の確認とデータ追加</p>
<h3 id="213">2.1.3 関連分野との比較</h3>
<p>MIは複数の分野と関連していますが、それぞれ異なる焦点を持っています。</p>
<table>
<thead>
<tr>
<th>分野</th>
<th>対象</th>
<th>主な手法</th>
<th>目的</th>
<th>MIとの関係</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>計算材料科学<br>(Computational Materials Science)</strong></td>
<td>材料の物理・化学現象</td>
<td>DFT、分子動力学</td>
<td>材料特性の理論予測</td>
<td>MIはこのデータを活用</td>
</tr>
<tr>
<td><strong>ケモインフォマティクス<br>(Cheminformatics)</strong></td>
<td>化合物・低分子</td>
<td>QSAR、分子記述子</td>
<td>薬物設計、分子特性予測</td>
<td>記述子の概念を共有</td>
</tr>
<tr>
<td><strong>バイオインフォマティクス<br>(Bioinformatics)</strong></td>
<td>生体分子、DNA/タンパク質</td>
<td>配列解析、構造予測</td>
<td>遺伝情報の解読</td>
<td>データ駆動型アプローチを共有</td>
</tr>
<tr>
<td><strong>マテリアルズ・インフォマティクス<br>(MI)</strong></td>
<td>固体材料全般</td>
<td>機械学習、ベイズ最適化</td>
<td>新材料の発見・設計</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong>MIの独自性:</strong><br />
- <strong>逆設計アプローチ</strong>: 目標特性から材料を設計（従来は材料から特性を計算）<br />
- <strong>多様な材料タイプ</strong>: 金属、セラミックス、半導体、ポリマーなど幅広い対象<br />
- <strong>実験との強い連携</strong>: 計算だけでなく、実験検証を重視</p>
<h3 id="214-forward-design-vs-inverse-design">2.1.4 Forward Design vs Inverse Design</h3>
<p><strong>従来の材料開発（Forward Design）:</strong></p>
<pre class="codehilite"><code>材料組成 → 構造・特性を計算/測定 → 結果を評価
</code></pre>

<ul>
<li>研究者が候補材料を提案</li>
<li>試行錯誤の繰り返し</li>
<li>時間がかかる</li>
</ul>
<p><strong>MIのアプローチ（Inverse Design）:</strong></p>
<pre class="codehilite"><code>目標特性 → 機械学習で候補材料を予測 → 上位候補を実験
</code></pre>

<ul>
<li>AIが最適な材料を提案</li>
<li>大量の候補を効率的にスクリーニング</li>
<li>大幅な時間短縮</li>
</ul>
<p><strong>逆設計の具体例:</strong><br />
「バンドギャップが2.0 eVの半導体材料が欲しい」<br />
→ MIシステムが候補材料リストを自動生成<br />
→ 研究者は上位10個だけを実験で検証</p>
<hr />
<h2 id="22-mi20">2.2 MI用語集：必須の20用語</h2>
<p>MIを学ぶ上で頻出する専門用語をまとめました。初学者の方は、これらの用語を正しく理解することが第一歩です。</p>
<h3 id="1-7">データ・モデル関連（1-7）</h3>
<table>
<thead>
<tr>
<th>用語（日本語）</th>
<th>用語（英語）</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 記述子</strong></td>
<td>Descriptor</td>
<td>材料の特徴を数値で表現したもの。例：電気陰性度、原子半径、格子定数。機械学習モデルへの入力として使用される。</td>
</tr>
<tr>
<td><strong>2. 特徴量エンジニアリング</strong></td>
<td>Feature Engineering</td>
<td>生データから機械学習に適した記述子を設計・選択するプロセス。モデルの性能を左右する重要なステップ。</td>
</tr>
<tr>
<td><strong>3. スクリーニング</strong></td>
<td>Screening</td>
<td>大量の候補材料の中から、目的の特性を持つものを効率的に選び出すこと。計算スクリーニングでは数千〜数万種類を短時間で評価可能。</td>
</tr>
<tr>
<td><strong>4. 過学習</strong></td>
<td>Overfitting</td>
<td>モデルが訓練データを「暗記」してしまい、未知のデータへの予測性能が低下する現象。データ数が少ない材料科学では特に注意が必要。</td>
</tr>
<tr>
<td><strong>5. 交差検証</strong></td>
<td>Cross-validation</td>
<td>モデルの汎化性能を評価する手法。データをK個に分割し、1つをテスト、残りを訓練に使う操作をK回繰り返す。</td>
</tr>
<tr>
<td><strong>6. アンサンブル法</strong></td>
<td>Ensemble Methods</td>
<td>複数のモデルの予測を組み合わせることで、より高精度な予測を実現する手法。例：ランダムフォレスト、勾配ブースティング。</td>
</tr>
<tr>
<td><strong>7. 検証</strong></td>
<td>Validation</td>
<td>予測結果が実際の材料特性と一致するか、実験または高精度計算で確認するプロセス。MIの信頼性を担保する重要なステップ。</td>
</tr>
</tbody>
</table>
<h3 id="8-13">計算手法関連（8-13）</h3>
<table>
<thead>
<tr>
<th>用語（日本語）</th>
<th>用語（英語）</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>8. DFT</strong></td>
<td>Density Functional Theory<br>（密度汎関数理論）</td>
<td>量子力学に基づいて材料の電子状態を計算する手法。材料特性（バンドギャップ、形成エネルギー等）を理論的に予測できる。</td>
</tr>
<tr>
<td><strong>9. 能動学習</strong></td>
<td>Active Learning</td>
<td>モデルが「次にどのデータを取得すべきか」を提案する学習方法。実験コストを最小化しながらモデルを改善できる。</td>
</tr>
<tr>
<td><strong>10. ベイズ最適化</strong></td>
<td>Bayesian Optimization</td>
<td>実験回数を最小限に抑えながら最適な材料を探索する手法。ガウス過程を用いて次の実験候補を決定する。</td>
</tr>
<tr>
<td><strong>11. 転移学習</strong></td>
<td>Transfer Learning</td>
<td>ある材料系で学習したモデルを、関連する別の材料系に応用する手法。データが少ない新規材料系でも高精度な予測が可能。</td>
</tr>
<tr>
<td><strong>12. グラフニューラルネットワーク</strong></td>
<td>Graph Neural Networks (GNN)</td>
<td>結晶構造をグラフ（原子=ノード、結合=エッジ）として扱い、構造情報を直接学習するニューラルネットワーク。近年注目の手法。</td>
</tr>
<tr>
<td><strong>13. ハイスループット計算</strong></td>
<td>High-throughput Computation</td>
<td>大量の材料について自動的に第一原理計算を実行する手法。Materials Projectは14万種類以上の材料をハイスループット計算で評価。</td>
</tr>
</tbody>
</table>
<h3 id="14-20">材料科学関連（14-20）</h3>
<table>
<thead>
<tr>
<th>用語（日本語）</th>
<th>用語（英語）</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>14. 結晶構造</strong></td>
<td>Crystal Structure</td>
<td>原子が規則的に配列した構造。FCC（面心立方）、BCC（体心立方）、HCP（六方最密）などの種類がある。</td>
</tr>
<tr>
<td><strong>15. 空間群</strong></td>
<td>Space Group</td>
<td>結晶構造の対称性を分類する230種類の数学的グループ。材料の物性と密接に関連。</td>
</tr>
<tr>
<td><strong>16. バンドギャップ</strong></td>
<td>Bandgap</td>
<td>半導体や絶縁体において、電子が占有する価電子帯と空の伝導帯の間のエネルギー差。太陽電池や半導体デバイスの設計に重要。</td>
</tr>
<tr>
<td><strong>17. 形成エネルギー</strong></td>
<td>Formation Energy</td>
<td>材料が元素から生成される際のエネルギー変化。負の値は安定な材料を示す。</td>
</tr>
<tr>
<td><strong>18. 状態図</strong></td>
<td>Phase Diagram</td>
<td>温度・圧力・組成の関数として、材料がどの相（固体、液体、気体）で存在するかを示す図。合金設計に不可欠。</td>
</tr>
<tr>
<td><strong>19. 多目的最適化</strong></td>
<td>Multi-objective Optimization</td>
<td>複数の特性（例：軽量性と強度）を同時に最適化する手法。通常、トレードオフの関係にある特性をバランス良く改善する。</td>
</tr>
<tr>
<td><strong>20. パレートフロント</strong></td>
<td>Pareto Front</td>
<td>多目的最適化において、すべての目的で最良ではないが、どの目的も改善できない解の集合。最適な材料の候補群を表す。</td>
</tr>
</tbody>
</table>
<p><strong>用語学習のポイント:</strong><br />
- まずは1-7（データ・モデル関連）を優先的に理解<br />
- 8-13（計算手法）は中級レベルで詳細を学習<br />
- 14-20（材料科学）は材料科学の基礎知識と合わせて復習</p>
<hr />
<h2 id="23">2.3 材料データベースの全体像</h2>
<p>MIの基盤となる材料データベースについて、主要な4つを詳しく比較します。</p>
<h3 id="231">2.3.1 主要データベースの詳細比較</h3>
<table>
<thead>
<tr>
<th>データベース名</th>
<th>材料数</th>
<th>データソース</th>
<th>主な特性データ</th>
<th>アクセス方法</th>
<th>利点</th>
<th>用途例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Materials Project</strong></td>
<td>140,000+</td>
<td>DFT計算（VASP）</td>
<td>バンドギャップ、形成エネルギー、弾性定数、相安定性</td>
<td>Web UI、API（Python: <code>pymatgen</code>）</td>
<td>最大規模、活発なコミュニティ、豊富なツール</td>
<td>電池材料、半導体、構造材料</td>
</tr>
<tr>
<td><strong>AFLOW</strong></td>
<td>3,500,000+</td>
<td>DFT計算（VASP）</td>
<td>結晶構造、電子構造、熱力学的安定性</td>
<td>Web UI、API（RESTful）</td>
<td>最多の結晶構造データ、標準化された命名規則</td>
<td>結晶構造探索、新規構造予測</td>
</tr>
<tr>
<td><strong>OQMD</strong></td>
<td>1,000,000+</td>
<td>DFT計算（VASP）</td>
<td>形成エネルギー、安定性、状態図</td>
<td>Web UI、API（Python: <code>qmpy</code>）</td>
<td>状態図計算に強い、合金データが豊富</td>
<td>合金設計、相安定性評価</td>
</tr>
<tr>
<td><strong>JARVIS</strong></td>
<td>70,000+</td>
<td>DFT計算（VASP）<br>機械学習予測</td>
<td>光学特性、機械特性、トポロジカル特性</td>
<td>Web UI、API（Python: <code>jarvis-tools</code>）</td>
<td>多様な物性、機械学習モデル提供</td>
<td>光学材料、トポロジカル材料</td>
</tr>
</tbody>
</table>
<h3 id="232">2.3.2 データベースの使い分け</h3>
<p><strong>1. Materials Project</strong><br />
- <strong>いつ使うか</strong>: 電池材料、半導体、一般的な無機材料の探索<br />
- <strong>強み</strong>:<br />
  - Web UIが直感的で初心者に優しい<br />
  - Pythonライブラリ（<code>pymatgen</code>）が充実<br />
  - コミュニティが活発で情報が豊富<br />
- <strong>弱み</strong>: 一部の構造タイプでは網羅性が低い</p>
<p><strong>2. AFLOW</strong><br />
- <strong>いつ使うか</strong>: 新規結晶構造の探索、構造類似性の検索<br />
- <strong>強み</strong>:<br />
  - 最も多くの結晶構造（350万種類）<br />
  - 標準化された結晶構造記述（AFLOW prototype）<br />
  - 構造類似性検索が高速<br />
- <strong>弱み</strong>: 物性データの種類がMaterials Projectより少ない</p>
<p><strong>3. OQMD</strong><br />
- <strong>いつ使うか</strong>: 合金の状態図計算、相安定性の詳細評価<br />
- <strong>強み</strong>:<br />
  - 状態図計算に特化<br />
  - 多元系合金のデータが充実<br />
  - 温度依存性の評価が可能<br />
- <strong>弱み</strong>: Web UIの使い勝手がやや劣る</p>
<p><strong>4. JARVIS</strong><br />
- <strong>いつ使うか</strong>: 光学材料、トポロジカル材料、機械学習モデルの利用<br />
- <strong>強み</strong>:<br />
  - 機械学習モデルが統合されている<br />
  - 光学特性（誘電率、屈折率）が充実<br />
  - トポロジカル特性の計算<br />
- <strong>弱み</strong>: データ数が他より少ない</p>
<h3 id="233">2.3.3 データベース活用の実践例</h3>
<p><strong>シナリオ1: リチウムイオン電池の新規正極材料を探したい</strong></p>
<ol>
<li>
<p><strong>Materials Projectで検索</strong>:<br />
   - 条件: Liを含み、電圧が3.5-4.5V、安定<br />
   - 候補: 100種類が見つかる</p>
</li>
<li>
<p><strong>上位10種類を選定</strong>:<br />
   - 容量、電圧、安定性のバランスで評価</p>
</li>
<li>
<p><strong>OQMDで相安定性を確認</strong>:<br />
   - 温度変化での分解の可能性をチェック</p>
</li>
<li>
<p><strong>実験で検証</strong>:<br />
   - 上位3種類を実際に合成</p>
</li>
</ol>
<p><strong>シナリオ2: 透明導電性材料（太陽電池用）を探したい</strong></p>
<ol>
<li>
<p><strong>JARVISで検索</strong>:<br />
   - 条件: バンドギャップ &gt; 3.0 eV（透明）、電気伝導性が高い<br />
   - 候補: 50種類</p>
</li>
<li>
<p><strong>Materials Projectで追加情報</strong>:<br />
   - 形成エネルギー、熱安定性を確認</p>
</li>
<li>
<p><strong>AFLOWで類似構造を探索</strong>:<br />
   - 見つかった有望材料と類似の構造を探す</p>
</li>
<li>
<p><strong>実験検証</strong></p>
</li>
</ol>
<h3 id="234">2.3.4 データベースアクセスの実例</h3>
<p><strong>Materials Project API (Python)の使用例:</strong></p>
<pre class="codehilite"><code class="language-python">from pymatgen.ext.matproj import MPRester

# APIキーを取得: https://materialsproject.org
with MPRester(&quot;YOUR_API_KEY&quot;) as mpr:
    # LiCoO2の情報を取得
    data = mpr.get_data(&quot;mp-1234&quot;)  # material_id

    print(f&quot;化学式: {data[0]['pretty_formula']}&quot;)
    print(f&quot;バンドギャップ: {data[0]['band_gap']} eV&quot;)
    print(f&quot;形成エネルギー: {data[0]['formation_energy_per_atom']} eV/atom&quot;)
</code></pre>

<p><strong>重要なポイント:</strong><br />
- 各データベースは相補的な関係<br />
- 1つのデータベースだけでなく、複数を併用することが推奨される<br />
- データの信頼性を確保するため、異なるデータベース間で結果を比較することが重要</p>
<hr />
<h2 id="24-mi">2.4 MIエコシステム：データの流れ</h2>
<p>MIは単独の技術ではなく、複数の要素が連携するエコシステムです。以下の図は、MIにおけるデータの流れを示しています。</p>
<pre class="codehilite"><code class="language-mermaid">graph TB
    subgraph &quot;データ生成&quot;
        A[実験データ] --&gt; D[材料データベース]
        B[第一原理計算&lt;br&gt;DFT] --&gt; D
        C[論文・特許] --&gt; D
    end

    subgraph &quot;データ処理&quot;
        D --&gt; E[データクリーニング&lt;br&gt;標準化]
        E --&gt; F[記述子生成&lt;br&gt;特徴量エンジニアリング]
    end

    subgraph &quot;機械学習&quot;
        F --&gt; G[モデル訓練&lt;br&gt;回帰・分類]
        G --&gt; H[予測・スクリーニング&lt;br&gt;数千〜数万候補]
    end

    subgraph &quot;実験検証&quot;
        H --&gt; I[候補材料の選定&lt;br&gt;上位10-100個]
        I --&gt; J[実験合成・測定]
        J --&gt; K{予測は&lt;br&gt;正確？}
    end

    subgraph &quot;継続的改善&quot;
        K --&gt;|Yes| L[新データとして追加]
        K --&gt;|No| M[モデル改善・再訓練]
        L --&gt; D
        M --&gt; G
    end

    style D fill:#e3f2fd
    style F fill:#fff3e0
    style G fill:#f3e5f5
    style J fill:#e8f5e9
    style L fill:#fce4ec
</code></pre>

<p><strong>図の読み方:</strong><br />
1. <strong>データ生成</strong>: 実験、計算、文献からデータを集める<br />
2. <strong>データ処理</strong>: 生データを機械学習に適した形式に変換<br />
3. <strong>機械学習</strong>: モデルを訓練し、大量の候補を予測<br />
4. <strong>実験検証</strong>: 有望な候補を実験で確認<br />
5. <strong>継続的改善</strong>: 結果をデータに追加し、モデルを改善</p>
<p><strong>フィードバックループの重要性:</strong><br />
- 予測が正確 → データを追加してモデルをさらに改善<br />
- 予測が不正確 → モデルを見直し、記述子や学習方法を変更<br />
- このサイクルを繰り返すことで、モデルの精度が向上</p>
<hr />
<h2 id="25-mi">2.5 MIの基本ワークフロー：詳細版</h2>
<p>第1章では4ステップのワークフローを紹介しましたが、ここではより実践的な<strong>5ステップ</strong>に拡張します。</p>
<h3 id="251">2.5.1 全体像</h3>
<pre class="codehilite"><code class="language-mermaid">graph LR
    A[Step 0:&lt;br&gt;問題定式化] --&gt; B[Step 1:&lt;br&gt;データ収集]
    B --&gt; C[Step 2:&lt;br&gt;モデル構築]
    C --&gt; D[Step 3:&lt;br&gt;予測・スクリーニング]
    D --&gt; E[Step 4:&lt;br&gt;実験検証]
    E --&gt; F[Step 5:&lt;br&gt;データ追加・改善]
    F -.継続的改善.-&gt; B

    style A fill:#ffebee
    style B fill:#e3f2fd
    style C fill:#fff3e0
    style D fill:#f3e5f5
    style E fill:#e8f5e9
    style F fill:#fce4ec
</code></pre>

<h3 id="252-step-0">2.5.2 Step 0: 問題定式化（最も重要、しばしば見落とされる）</h3>
<p><strong>何をするか:</strong><br />
- 解決したい問題を明確に定義する<br />
- 目標特性と制約条件を具体化する<br />
- 成功の基準を設定する</p>
<p><strong>具体例：電池材料の開発</strong></p>
<p><strong>悪い問題定式化:</strong></p>
<blockquote>
<p>「良い電池材料を探したい」</p>
</blockquote>
<p><strong>良い問題定式化:</strong></p>
<blockquote>
<p>「リチウムイオン電池の正極材料として、以下の特性を持つ材料を発見する：<br />
- 理論容量: ≥200 mAh/g<br />
- 作動電圧: 3.5-4.5 V vs. Li/Li+<br />
- サイクル寿命: 500サイクル後も容量維持率80%以上<br />
- コスト: ≤$50/kg（原材料ベース）<br />
- 安全性: 熱暴走温度 ≥200°C<br />
- 環境制約: Co使用量を最小化（理想的にはCo-free）」</p>
</blockquote>
<p><strong>問題定式化のチェックリスト:</strong><br />
- [ ] 目標特性が定量的に定義されているか？<br />
- [ ] 制約条件（コスト、環境、安全性）が明確か？<br />
- [ ] 成功の基準が測定可能か？<br />
- [ ] 実験的に検証可能な範囲か？</p>
<p><strong>時間の目安:</strong> 1〜2週間（文献調査と専門家との議論を含む）</p>
<p><strong>よくある失敗:</strong><br />
- 目標が曖昧で、後から何度も変更する<br />
- 制約条件を考慮せず、実現不可能な材料を探索してしまう<br />
- 成功基準がないため、いつまでも探索が終わらない</p>
<h3 id="253-step-1">2.5.3 Step 1: データ収集</h3>
<p><strong>何をするか:</strong><br />
- 既存の実験データや論文から材料情報を集める<br />
- 材料データベースから関連データをダウンロード<br />
- 必要に応じて第一原理計算でデータを追加</p>
<p><strong>データソースの優先順位:</strong><br />
1. <strong>既存のデータベース</strong>（最も効率的）<br />
   - Materials Project, AFLOW, OQMD<br />
   - 信頼性が高く、すぐに使える</p>
<ol start="2">
<li>
<p><strong>論文・特許</strong>（手作業が必要）<br />
   - Google Scholar, Web of Science<br />
   - 実験データが含まれる場合がある</p>
</li>
<li>
<p><strong>自分で計算/測定</strong>（時間がかかる）<br />
   - DFT計算で新規材料のデータを生成<br />
   - 実験室で測定</p>
</li>
</ol>
<p><strong>具体例：リチウムイオン電池正極材料</strong></p>
<pre class="codehilite"><code class="language-python">from pymatgen.ext.matproj import MPRester
import pandas as pd

# Materials Projectから Li含有酸化物を検索
with MPRester(&quot;YOUR_API_KEY&quot;) as mpr:
    # 検索条件
    criteria = {
        &quot;elements&quot;: {&quot;$all&quot;: [&quot;Li&quot;, &quot;O&quot;]},  # LiとOを必ず含む
        &quot;nelements&quot;: {&quot;$gte&quot;: 2, &quot;$lte&quot;: 4},  # 元素数2-4
        &quot;e_above_hull&quot;: {&quot;$lte&quot;: 0.05}  # 安定または準安定
    }

    # 取得する特性
    properties = [
        &quot;material_id&quot;,
        &quot;pretty_formula&quot;,
        &quot;formation_energy_per_atom&quot;,
        &quot;energy_above_hull&quot;,
        &quot;band_gap&quot;,
        &quot;density&quot;
    ]

    # データ取得
    results = mpr.query(criteria, properties)

    # DataFrameに変換
    df = pd.DataFrame(results)

    print(f&quot;取得した材料数: {len(df)}&quot;)
    print(df.head())
</code></pre>

<p><strong>期待される結果:</strong><br />
- 数百〜数千種類の候補材料データ<br />
- 各材料の基本特性（組成、形成エネルギー、バンドギャップ等）</p>
<p><strong>時間の目安:</strong><br />
- データベース利用: 数時間〜数日<br />
- 論文調査: 1〜2週間<br />
- DFT計算: 数週間〜数ヶ月（材料数に依存）</p>
<p><strong>よくある問題:</strong><br />
- データの欠損（特定の特性が一部の材料でのみ利用可能）<br />
- データの不一致（異なるデータベース間で値が異なる）<br />
- データのバイアス（特定の材料系に偏っている）</p>
<p><strong>解決策:</strong><br />
- 複数のデータベースを比較して信頼性を確認<br />
- 欠損値の補完方法を検討（平均値、機械学習による推定等）<br />
- データのバイアスを認識し、モデルの適用範囲を明確にする</p>
<h3 id="254-step-2">2.5.4 Step 2: モデル構築</h3>
<p><strong>何をするか:</strong><br />
- 収集したデータを使って機械学習モデルを訓練<br />
- 適切な記述子（特徴量）を選択<br />
- モデルの性能を評価し、最適化</p>
<p><strong>サブステップ:</strong></p>
<p><strong>2.1 記述子の設計</strong></p>
<p>材料を数値ベクトルに変換する必要があります。</p>
<p><strong>記述子の種類:</strong></p>
<table>
<thead>
<tr>
<th>タイプ</th>
<th>具体例</th>
<th>利点</th>
<th>欠点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>組成ベース</strong></td>
<td>元素の電気陰性度、原子半径、原子量</td>
<td>計算が簡単、解釈しやすい</td>
<td>構造情報を無視</td>
</tr>
<tr>
<td><strong>構造ベース</strong></td>
<td>格子定数、空間群、配位数</td>
<td>構造と物性の関係を捉える</td>
<td>結晶構造データが必要</td>
</tr>
<tr>
<td><strong>物性ベース</strong></td>
<td>融点、密度、バンドギャップ</td>
<td>物性同士の相関を利用</td>
<td>未知材料には適用困難</td>
</tr>
</tbody>
</table>
<p><strong>記述子の例: LiCoO2の数値化</strong></p>
<pre class="codehilite"><code class="language-python"># 簡単な例: 組成ベースの記述子
material = &quot;LiCoO2&quot;

# 各元素の割合
Li_fraction = 0.25  # 1/(1+1+2)
Co_fraction = 0.25
O_fraction = 0.50

# 元素の特性（周期表から）
electronegativity_Li = 0.98
electronegativity_Co = 1.88
electronegativity_O = 3.44

# 加重平均
avg_electronegativity = (
    Li_fraction * electronegativity_Li +
    Co_fraction * electronegativity_Co +
    O_fraction * electronegativity_O
)  # = 2.38

# ベクトル表現
descriptor_vector = [
    Li_fraction, Co_fraction, O_fraction,  # 組成
    avg_electronegativity,  # 電気陰性度
    # ... 他の特性も追加
]
</code></pre>

<p><strong>実際のプロジェクトでは、<code>matminer</code>ライブラリを使用:</strong></p>
<pre class="codehilite"><code class="language-python">from matminer.featurizers.composition import ElementProperty

# 自動的に多数の記述子を生成
featurizer = ElementProperty.from_preset(&quot;magpie&quot;)
features = featurizer.featurize_dataframe(df, col_id=&quot;composition&quot;)
</code></pre>

<p><strong>2.2 モデルの選択</strong></p>
<p><strong>初級者向けモデル:</strong><br />
- <strong>線形回帰</strong>: シンプル、解釈しやすい<br />
- <strong>決定木</strong>: 視覚化可能、非線形関係を捉える</p>
<p><strong>中級者向けモデル:</strong><br />
- <strong>ランダムフォレスト</strong>: 高精度、過学習に強い<br />
- <strong>勾配ブースティング（XGBoost, LightGBM）</strong>: 最も高精度</p>
<p><strong>上級者向けモデル:</strong><br />
- <strong>ニューラルネットワーク</strong>: 複雑な非線形関係を学習<br />
- <strong>グラフニューラルネットワーク（GNN）</strong>: 結晶構造を直接学習</p>
<p><strong>2.3 訓練と評価</strong></p>
<pre class="codehilite"><code class="language-python">from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, r2_score

# データ分割
X = features  # 記述子
y = df['target_property']  # 例: 電圧

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# モデル訓練
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# 予測
y_pred = model.predict(X_test)

# 評価
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f&quot;MAE: {mae:.3f}&quot;)
print(f&quot;R²: {r2:.3f}&quot;)

# 交差検証（より信頼性の高い評価）
cv_scores = cross_val_score(model, X, y, cv=5, scoring='neg_mean_absolute_error')
print(f&quot;CV MAE: {-cv_scores.mean():.3f} ± {cv_scores.std():.3f}&quot;)
</code></pre>

<p><strong>性能の目安:</strong><br />
- <strong>R² &gt; 0.8</strong>: 良好<br />
- <strong>R² &gt; 0.9</strong>: 優秀<br />
- <strong>R² &lt; 0.5</strong>: モデルの見直しが必要</p>
<p><strong>時間の目安:</strong><br />
- 記述子設計: 数日〜1週間<br />
- モデル訓練と最適化: 1〜2週間</p>
<p><strong>よくある問題:</strong><br />
- 過学習（訓練データでは高精度だがテストデータで低精度）<br />
- 記述子の選択ミス（重要な特徴を見落とす）</p>
<p><strong>解決策:</strong><br />
- 交差検証で汎化性能を確認<br />
- 特徴量の重要度を分析し、不要な記述子を削除<br />
- 正則化（L1/L2）を導入</p>
<h3 id="255-step-3">2.5.5 Step 3: 予測・スクリーニング</h3>
<p><strong>何をするか:</strong><br />
- 訓練したモデルを使って、未知の材料の特性を予測<br />
- 大量の候補材料（数千〜数万）を短時間で評価<br />
- 有望な上位候補を選定</p>
<p><strong>スクリーニングの流れ:</strong></p>
<pre class="codehilite"><code>候補材料: 10,000種類（計算で生成）
  ↓（機械学習で予測：数分）
予測値でランク付け
  ↓
上位1,000種類を選定（目標特性に近い）
  ↓（詳細な計算・評価：数時間〜数日）
上位100種類に絞り込み
  ↓
実験する材料: 上位10種類（最有望候補）
</code></pre>

<p><strong>具体的なコード例:</strong></p>
<pre class="codehilite"><code class="language-python">import numpy as np

# 候補材料のリストを生成（例: 組成を変えて候補を作る）
# 実際にはもっと体系的な方法を使用
candidate_compositions = [...]  # 10,000個

# 各候補の記述子を計算
candidate_features = compute_descriptors(candidate_compositions)

# モデルで予測
predicted_properties = model.predict(candidate_features)

# ランク付け（例: 電圧が高い順）
ranked_indices = np.argsort(predicted_properties)[::-1]

# 上位100個を選定
top_100 = [candidate_compositions[i] for i in ranked_indices[:100]]

print(&quot;Top 10 candidates:&quot;)
for i, comp in enumerate(top_100[:10]):
    pred_val = predicted_properties[ranked_indices[i]]
    print(f&quot;{i+1}. {comp}: 予測値 = {pred_val:.2f}&quot;)
</code></pre>

<p><strong>効率化の例:</strong><br />
- <strong>従来</strong>: 10,000種類を実験で評価 → 約30年（1日1個）<br />
- <strong>MI</strong>: 10種類を実験で評価 → 約2週間<br />
- <strong>時間削減率</strong>: 99.9%</p>
<p><strong>時間の目安:</strong><br />
- 予測計算: 数分〜数時間（候補材料数に依存）<br />
- 結果の分析: 数日</p>
<p><strong>注意点:</strong><br />
- 予測はあくまで予測。必ず実験で検証する<br />
- モデルの適用範囲外の材料（訓練データと大きく異なる材料）では予測精度が低い<br />
- 不確実性の評価（ベイズ的手法）を行うとより信頼性が高い</p>
<h3 id="256-step-4">2.5.6 Step 4: 実験検証</h3>
<p><strong>何をするか:</strong><br />
- 予測で絞り込んだ材料を実際に合成<br />
- 特性を測定し、予測が正しかったか確認<br />
- 予測と実測のズレを分析</p>
<p><strong>実験の優先順位:</strong><br />
1. <strong>予測値が最も高い材料</strong>（ベストケース）<br />
2. <strong>予測値は中程度だが、不確実性が低い材料</strong>（安全な選択）<br />
3. <strong>予測値は高いが、不確実性も高い材料</strong>（ハイリスク・ハイリターン）</p>
<p><strong>検証のチェックリスト:</strong><br />
- [ ] 合成条件が確立されているか？<br />
- [ ] 測定装置が利用可能か？<br />
- [ ] 測定精度は目標特性の要求を満たすか？<br />
- [ ] 再現性の確認（複数回の測定）</p>
<p><strong>時間の目安:</strong><br />
- 合成: 数日〜数週間（材料に依存）<br />
- 測定: 数日〜1週間<br />
- 合計: 上位10個で2〜3ヶ月</p>
<p><strong>成功と失敗の判断:</strong></p>
<table>
<thead>
<tr>
<th>結果</th>
<th>判断</th>
<th>次のアクション</th>
</tr>
</thead>
<tbody>
<tr>
<td>予測と実測が一致</td>
<td>成功</td>
<td>データに追加、さらに探索</td>
</tr>
<tr>
<td>予測より良い</td>
<td>大成功</td>
<td>モデルを分析し、なぜ過小評価したか調査</td>
</tr>
<tr>
<td>予測より悪い</td>
<td>部分的失敗</td>
<td>記述子やモデルを見直し</td>
</tr>
<tr>
<td>全く異なる</td>
<td>失敗</td>
<td>モデルの適用範囲外の可能性。データとモデルを再検討</td>
</tr>
</tbody>
</table>
<p><strong>重要なポイント:</strong><br />
- 失敗も貴重なデータ。必ずデータベースに追加する<br />
- 予測と実測のズレの原因を分析することで、モデルが改善される</p>
<h3 id="257-step-5">2.5.7 Step 5: データ追加・モデル改善</h3>
<p><strong>何をするか:</strong><br />
- 実験結果（成功・失敗両方）をデータベースに追加<br />
- 新しいデータでモデルを再訓練<br />
- 予測精度の向上を確認</p>
<p><strong>継続的改善のサイクル:</strong></p>
<pre class="codehilite"><code>初期モデル（R² = 0.75）
  ↓
10個の実験結果を追加
  ↓
モデル再訓練（R² = 0.82）
  ↓
さらに10個の実験
  ↓
モデル再訓練（R² = 0.88）
  ↓
最終的に最適な材料を発見
</code></pre>

<p><strong>能動学習の活用:</strong></p>
<p>通常のMIでは、予測値が高い材料を実験しますが、<strong>能動学習</strong>ではモデルが「不確実性が高い材料」を提案します。</p>
<pre class="codehilite"><code class="language-python"># ランダムフォレストで不確実性を推定
predictions = []
for tree in model.estimators_:
    pred = tree.predict(candidate_features)
    predictions.append(pred)

predictions = np.array(predictions)
uncertainty = predictions.std(axis=0)  # 標準偏差が大きい = 不確実性が高い

# 不確実性が高い材料を優先的に実験
high_uncertainty_indices = np.argsort(uncertainty)[::-1]
next_experiment = candidate_compositions[high_uncertainty_indices[0]]
</code></pre>

<p><strong>時間の目安:</strong> 1サイクルあたり1〜2週間</p>
<p><strong>終了条件:</strong><br />
- 目標特性を満たす材料が見つかった<br />
- 予測精度が十分に高くなった（R² &gt; 0.9）<br />
- 予算・時間の制約</p>
<hr />
<h2 id="26">2.6 材料記述子の詳細</h2>
<h3 id="261">2.6.1 記述子の種類と具体例</h3>
<p><strong>1. 組成ベース記述子（Composition-based Descriptors）</strong></p>
<p><strong>特徴:</strong><br />
- 化学式だけから計算可能<br />
- 結晶構造が不明でも使える<br />
- 計算コストが低い</p>
<p><strong>具体例:</strong></p>
<table>
<thead>
<tr>
<th>記述子</th>
<th>説明</th>
<th>例（LiCoO2）</th>
</tr>
</thead>
<tbody>
<tr>
<td>平均電気陰性度</td>
<td>各元素の電気陰性度の加重平均</td>
<td>2.38</td>
</tr>
<tr>
<td>平均原子半径</td>
<td>各元素の原子半径の加重平均</td>
<td>1.15 Å</td>
</tr>
<tr>
<td>元素の種類数</td>
<td>構成元素の数</td>
<td>3（Li, Co, O）</td>
</tr>
<tr>
<td>平均原子量</td>
<td>各元素の原子量の加重平均</td>
<td>30.8 g/mol</td>
</tr>
<tr>
<td>電気陰性度の差</td>
<td>最大と最小の電気陰性度の差</td>
<td>2.46（O - Li）</td>
</tr>
</tbody>
</table>
<p><strong>2. 構造ベース記述子（Structure-based Descriptors）</strong></p>
<p><strong>特徴:</strong><br />
- 結晶構造の情報を活用<br />
- 物性と構造の関係を捉える<br />
- 結晶構造データが必要</p>
<p><strong>具体例:</strong></p>
<table>
<thead>
<tr>
<th>記述子</th>
<th>説明</th>
<th>例（LiCoO2）</th>
</tr>
</thead>
<tbody>
<tr>
<td>格子定数</td>
<td>単位格子の長さ a, b, c</td>
<td>a=2.82 Å, c=14.05 Å（六方晶）</td>
</tr>
<tr>
<td>空間群</td>
<td>結晶の対称性</td>
<td>R-3m (166)</td>
</tr>
<tr>
<td>配位数</td>
<td>原子周囲の近接原子数</td>
<td>Co: 6配位（酸素に囲まれる）</td>
</tr>
<tr>
<td>結合距離</td>
<td>隣接原子間の距離</td>
<td>Co-O: 1.93 Å</td>
</tr>
<tr>
<td>密度</td>
<td>単位体積あたりの質量</td>
<td>5.06 g/cm³</td>
</tr>
</tbody>
</table>
<p><strong>3. 物性ベース記述子（Property-based Descriptors）</strong></p>
<p><strong>特徴:</strong><br />
- 既知の物性から未知の物性を予測<br />
- 物性間の相関を利用<br />
- 未知材料には適用困難</p>
<p><strong>具体例:</strong></p>
<table>
<thead>
<tr>
<th>記述子</th>
<th>説明</th>
<th>例（LiCoO2）</th>
</tr>
</thead>
<tbody>
<tr>
<td>融点</td>
<td>固体から液体への相転移温度</td>
<td>~1200 K</td>
</tr>
<tr>
<td>バンドギャップ</td>
<td>電子構造のエネルギーギャップ</td>
<td>~2.7 eV（絶縁体）</td>
</tr>
<tr>
<td>形成エネルギー</td>
<td>元素から生成される際のエネルギー</td>
<td>-2.5 eV/atom（安定）</td>
</tr>
<tr>
<td>弾性率</td>
<td>材料の硬さ・変形しにくさ</td>
<td>150 GPa</td>
</tr>
<tr>
<td>熱伝導率</td>
<td>熱の伝わりやすさ</td>
<td>5 W/(m·K)</td>
</tr>
</tbody>
</table>
<h3 id="262-matminer">2.6.2 記述子の自動生成（Matminerの活用）</h3>
<pre class="codehilite"><code class="language-python">from matminer.featurizers.composition import ElementProperty, Stoichiometry
from matminer.featurizers.structure import DensityFeatures
from pymatgen.core import Composition

# 組成ベース記述子の自動生成
comp = Composition(&quot;LiCoO2&quot;)

# 例1: 元素特性ベースの記述子（73種類）
element_featurizer = ElementProperty.from_preset(&quot;magpie&quot;)
element_features = element_featurizer.featurize(comp)

print(f&quot;生成された記述子の数: {len(element_features)}&quot;)
print(f&quot;記述子の例: {element_features[:5]}&quot;)

# 例2: 組成比ベースの記述子
stoich_featurizer = Stoichiometry()
stoich_features = stoich_featurizer.featurize(comp)

print(f&quot;組成比記述子: {stoich_features}&quot;)
</code></pre>

<p><strong>Matminerが生成する記述子（一部）:</strong><br />
- 平均電気陰性度、原子半径、原子量<br />
- 元素の周期表上の位置（族、周期）<br />
- 電子配置（s軌道電子数、p軌道電子数等）<br />
- 酸化状態の平均・分散<br />
- 元素の価電子数</p>
<h3 id="263-feature-engineering">2.6.3 記述子の選択とFeature Engineering</h3>
<p><strong>すべての記述子が有用とは限らない:</strong><br />
- 無関係な記述子 → ノイズとなりモデルの性能を低下させる<br />
- 冗長な記述子 → 計算コストの無駄</p>
<p><strong>記述子選択の手法:</strong></p>
<p><strong>1. 特徴量重要度（Feature Importance）</strong></p>
<pre class="codehilite"><code class="language-python">import matplotlib.pyplot as plt
import pandas as pd

# ランダムフォレストの特徴量重要度
importances = model.feature_importances_
feature_names = X.columns

# 重要度の高い順にソート
indices = np.argsort(importances)[::-1]

# 上位20個を可視化
plt.figure(figsize=(10, 6))
plt.bar(range(20), importances[indices[:20]])
plt.xticks(range(20), [feature_names[i] for i in indices[:20]], rotation=90)
plt.xlabel(&quot;特徴量&quot;)
plt.ylabel(&quot;重要度&quot;)
plt.title(&quot;特徴量重要度 Top 20&quot;)
plt.tight_layout()
plt.show()
</code></pre>

<p><strong>2. 相関分析</strong></p>
<pre class="codehilite"><code class="language-python"># 特徴量間の相関行列
correlation_matrix = X.corr()

# 相関が高い（&gt;0.9）特徴量のペアを削除
high_corr_pairs = []
for i in range(len(correlation_matrix.columns)):
    for j in range(i+1, len(correlation_matrix.columns)):
        if abs(correlation_matrix.iloc[i, j]) &gt; 0.9:
            high_corr_pairs.append((correlation_matrix.columns[i],
                                   correlation_matrix.columns[j]))

print(f&quot;高相関ペア: {len(high_corr_pairs)}個&quot;)
</code></pre>

<p><strong>3. 再帰的特徴量削除（RFE）</strong></p>
<pre class="codehilite"><code class="language-python">from sklearn.feature_selection import RFE

# 最良の50個の特徴量を選択
selector = RFE(model, n_features_to_select=50, step=1)
selector.fit(X_train, y_train)

selected_features = X.columns[selector.support_]
print(f&quot;選択された特徴量: {list(selected_features)}&quot;)
</code></pre>

<hr />
<h2 id="27">2.7 まとめ</h2>
<h3 id="_2">この章で学んだこと</h3>
<ol>
<li>
<p><strong>MIの定義と位置づけ</strong><br />
   - 材料科学とデータサイエンスの融合<br />
   - 逆設計アプローチによる効率化<br />
   - 計算材料科学、ケモインフォマティクスとの違い</p>
</li>
<li>
<p><strong>MI用語20語</strong><br />
   - データ・モデル関連（記述子、特徴量エンジニアリング、過学習等）<br />
   - 計算手法関連（DFT、ベイズ最適化、GNN等）<br />
   - 材料科学関連（結晶構造、バンドギャップ、状態図等）</p>
</li>
<li>
<p><strong>材料データベース</strong><br />
   - Materials Project: 最大規模、初心者に優しい<br />
   - AFLOW: 最多の結晶構造データ<br />
   - OQMD: 状態図計算に強い<br />
   - JARVIS: 機械学習モデル統合<br />
   - 複数データベースの併用が推奨される</p>
</li>
<li>
<p><strong>MIエコシステム</strong><br />
   - データ生成 → 処理 → 機械学習 → 実験検証 → 改善のサイクル<br />
   - フィードバックループが重要</p>
</li>
<li>
<p><strong>MIの5ステップワークフロー</strong><br />
   - Step 0: 問題定式化（最も重要）<br />
   - Step 1: データ収集（データベース、論文、計算）<br />
   - Step 2: モデル構築（記述子設計、訓練、評価）<br />
   - Step 3: 予測・スクリーニング（大量候補を効率的に評価）<br />
   - Step 4: 実験検証（上位候補の合成・測定）<br />
   - Step 5: データ追加・改善（継続的改善サイクル）</p>
</li>
<li>
<p><strong>材料記述子の詳細</strong><br />
   - 組成ベース、構造ベース、物性ベースの3種類<br />
   - Matminerによる自動生成<br />
   - 特徴量選択の重要性</p>
</li>
</ol>
<h3 id="_3">次の章へ</h3>
<p>第3章では、これらの知識を実践に移します。実際のPythonコードを使って、材料データベースからのデータ取得、記述子の生成、機械学習モデルの構築、予測まで、一連の流れを体験します。</p>
<hr />
<h2 id="_4">演習問題</h2>
<h3 id="1-easy">問題1（難易度: easy）</h3>
<p>MI用語集から5つの用語を選び、自分の言葉で説明してください。</p>
<details>
<summary>解答例</summary>

**1. 記述子（Descriptor）**
材料の特徴を機械学習モデルに入力できるように数値化したもの。例えば、元素の電気陰性度や原子半径などがある。

**2. スクリーニング（Screening）**
大量の候補材料の中から、目的の特性を持つものを効率的に絞り込むこと。MIでは計算で数千〜数万種類を短時間で評価できる。

**3. 過学習（Overfitting）**
機械学習モデルが訓練データを暗記してしまい、新しいデータへの予測性能が低下する現象。交差検証で検出できる。

**4. バンドギャップ（Bandgap）**
半導体において、電子が占有する価電子帯と空の伝導帯の間のエネルギー差。太陽電池の設計では重要な指標。

**5. ベイズ最適化（Bayesian Optimization）**
実験回数を最小限に抑えながら最適な材料を探索する手法。次にどの材料を実験すべきかをAIが提案する。

</details>

<h3 id="2-medium">問題2（難易度: medium）</h3>
<p>Materials ProjectとAFLOWの使い分けについて、以下のシナリオでどちらを使うべきか理由とともに答えてください。</p>
<p><strong>シナリオA</strong>: 新規リチウムイオン電池正極材料を探索したい。バンドギャップと形成エネルギーのデータが必要。</p>
<p><strong>シナリオB</strong>: 既存の材料と似た結晶構造を持つ新規材料を見つけたい。構造類似性検索が必要。</p>
<details>
<summary>解答例</summary>

**シナリオA: Materials Projectを使用**

**理由:**
- Materials Projectは14万種類以上の材料データを持ち、バンドギャップと形成エネルギーの両方が利用可能
- 電池材料の研究に特化したツールが豊富（電圧、容量の計算等）
- Pythonライブラリ（pymatgen）が充実しており、データ取得が容易
- Web UIが直感的で、初心者でも使いやすい

**シナリオB: AFLOWを使用**

**理由:**
- AFLOWは350万種類という最多の結晶構造データを持つ
- 構造類似性検索機能が高速かつ正確
- AFLOW prototypeによる標準化された構造記述により、類似構造の探索が容易
- 構造探索に特化したツールが充実

**まとめ:**
物性データを重視する場合はMaterials Project、構造探索を重視する場合はAFLOWが適しています。実際のプロジェクトでは両方を併用することも多いです。

</details>

<h3 id="3-medium">問題3（難易度: medium）</h3>
<p>MIワークフローのStep 0（問題定式化）がなぜ最も重要なのか、具体例を挙げて説明してください。</p>
<details>
<summary>ヒント</summary>

問題定式化が曖昧だと、後の全ステップに影響します。目標特性、制約条件、成功基準を明確にすることの重要性を考えてみましょう。

</details>

<details>
<summary>解答例</summary>

**問題定式化の重要性:**

問題定式化が不十分だと、以下のような問題が発生します。

**悪い例:**
> 「高性能な触媒材料を探したい」

**問題点:**
- 「高性能」が定義されていない（反応速度？選択性？耐久性？）
- 制約条件がない（コスト、毒性、入手性）
- 成功の基準が不明（いつまで探索を続けるか？）

**結果:**
1. データ収集で無駄な時間を費やす（関係ないデータまで集めてしまう）
2. モデルが間違った目的を最適化する
3. 実験段階で「実は別の特性が重要だった」と気づき、やり直し

**良い例:**
> 「水素製造用の触媒材料として、以下の特性を持つ材料を発見する：
> - 反応速度: ≥100 mol H2/(m²·h)
> - 選択性: ≥95%（水素以外の副生成物を抑制）
> - 耐久性: 1000時間連続運転後も活性が80%以上維持
> - コスト: ≤$100/kg
> - 制約: Pt, Pd等の貴金属使用量を最小化」

**効果:**
1. データ収集が明確（反応速度、選択性、耐久性のデータを優先）
2. モデルが正しい目的を最適化
3. 成功基準が明確で、プロジェクトの進捗を評価しやすい
4. 実験の優先順位を決めやすい

**時間投資の価値:**
問題定式化に1〜2週間を費やすことで、後の数ヶ月〜数年の作業を無駄にするリスクを大幅に減らせます。

</details>

<h3 id="4-hard">問題4（難易度: hard）</h3>
<p>材料記述子として、組成ベース、構造ベース、物性ベースの3種類があります。それぞれの利点と欠点を挙げ、どのような状況で使い分けるべきか説明してください。</p>
<details>
<summary>ヒント</summary>

各記述子の計算コスト、必要なデータ、予測精度のトレードオフを考えてみましょう。

</details>

<details>
<summary>解答例</summary>

**組成ベース記述子**

**利点:**
- 化学式だけから計算可能（結晶構造不要）
- 計算コストが低い（数秒）
- 未知材料にも適用可能

**欠点:**
- 構造情報を無視（同じ組成でも構造が異なれば物性が変わる）
- 予測精度が構造ベースより低い場合がある

**使用すべき状況:**
- 結晶構造が不明な材料が多い場合
- 高速なスクリーニングが必要な場合（数万種類）
- プロジェクトの初期段階（粗いスクリーニング）

**構造ベース記述子**

**利点:**
- 構造と物性の関係を捉える（より正確な予測）
- 同じ組成でも異なる構造を区別できる

**欠点:**
- 結晶構造データが必要（実験で決定、またはDFT計算）
- 計算コストが高い
- 未知材料では構造を予測する必要がある

**使用すべき状況:**
- 結晶構造データが利用可能な場合
- 高精度な予測が必要な場合（最終候補の絞り込み）
- 構造-物性相関を理解したい場合

**物性ベース記述子**

**利点:**
- 物性間の相関を利用（例：融点が高い材料は硬度も高い傾向）
- 既知材料では高精度

**欠点:**
- 未知材料では適用困難（目的の物性を予測するために別の物性が必要）
- 因果関係が不明確（なぜその物性が関連するのか）

**使用すべき状況:**
- 既知材料の物性を別の物性から推定する場合
- 実験データが豊富な材料系
- 物性間の相関を探索する研究

**実践的な使い分け戦略:**

1. **初期スクリーニング（数万種類）**: 組成ベース記述子
   - 高速に候補を1,000種類程度に絞り込む

2. **中間スクリーニング（1,000種類）**: 構造ベース記述子
   - より正確に100種類に絞り込む

3. **最終選定（100種類）**: 物性ベース記述子（可能であれば）
   - 既知の物性を活用し、最終的な10種類を決定

4. **実験検証（10種類）**

この段階的アプローチにより、計算コストと予測精度のバランスを取ることができます。

</details>

<hr />
<h2 id="_5">参考文献</h2>
<ol>
<li>
<p><strong>Materials Genome Initiative (MGI)</strong> - White House Office of Science and Technology Policy (2011)<br />
   URL: https://www.mgi.gov<br />
<em>米国が2011年に開始した材料開発加速プロジェクト。MIの世界的普及のきっかけとなった。</em></p>
</li>
<li>
<p>Ramprasad, R., Batra, R., Pilania, G., Mannodi-Kanakkithodi, A., &amp; Kim, C. (2017). "Machine learning in materials informatics: recent applications and prospects." <em>npj Computational Materials</em>, 3(1), 54.<br />
   DOI: <a href="https://doi.org/10.1038/s41524-017-0056-5">10.1038/s41524-017-0056-5</a></p>
</li>
<li>
<p>Jain, A., Ong, S. P., Hautier, G., Chen, W., Richards, W. D., et al. (2013). "Commentary: The Materials Project: A materials genome approach to accelerating materials innovation." <em>APL Materials</em>, 1(1), 011002.<br />
   DOI: <a href="https://doi.org/10.1063/1.4812323">10.1063/1.4812323</a><br />
   Materials Project: https://materialsproject.org</p>
</li>
<li>
<p>Curtarolo, S., Setyawan, W., Hart, G. L., Jahnatek, M., Chepulskii, R. V., et al. (2012). "AFLOW: An automatic framework for high-throughput materials discovery." <em>Computational Materials Science</em>, 58, 218-226.<br />
   DOI: <a href="https://doi.org/10.1016/j.commatsci.2012.02.005">10.1016/j.commatsci.2012.02.005</a><br />
   AFLOW: http://www.aflowlib.org</p>
</li>
<li>
<p>Saal, J. E., Kirklin, S., Aykol, M., Meredig, B., &amp; Wolverton, C. (2013). "Materials Design and Discovery with High-Throughput Density Functional Theory: The Open Quantum Materials Database (OQMD)." <em>JOM</em>, 65(11), 1501-1509.<br />
   DOI: <a href="https://doi.org/10.1007/s11837-013-0755-4">10.1007/s11837-013-0755-4</a><br />
   OQMD: http://oqmd.org</p>
</li>
<li>
<p>Choudhary, K., Garrity, K. F., Reid, A. C. E., DeCost, B., Biacchi, A. J., et al. (2020). "The joint automated repository for various integrated simulations (JARVIS) for data-driven materials design." <em>npj Computational Materials</em>, 6(1), 173.<br />
   DOI: <a href="https://doi.org/10.1038/s41524-020-00440-1">10.1038/s41524-020-00440-1</a><br />
   JARVIS: https://jarvis.nist.gov</p>
</li>
</ol>
<hr />
<p><strong>著者情報</strong></p>
<p>この記事は、東北大学 Dr. Yusuke Hashimotoのもと、MI Knowledge Hubプロジェクトの一環として作成されました。</p>
<p><strong>更新履歴</strong><br />
- 2025-10-16: v3.0 初版作成<br />
  - v2.1のSection 2（約2,000語）を4,000-5,000語に拡張<br />
  - 20用語の用語集を追加<br />
  - 材料データベース詳細比較表を追加<br />
  - MIエコシステム図（Mermaid）を追加<br />
  - 5ステップワークフローの詳細解説を追加<br />
  - 材料記述子の深掘りセクションを追加<br />
  - 演習問題4問を追加（難易度: easy 1問、medium 2問、hard 1問）</p>

        <div class="nav-buttons">
            <a href="index.html" class="nav-button">← シリーズ目次に戻る</a>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 MI Knowledge Hub - Dr. Yusuke Hashimoto, Tohoku University</p>
            <p>Licensed under CC BY 4.0</p>
        </div>
    </footer>
</body>
</html>
