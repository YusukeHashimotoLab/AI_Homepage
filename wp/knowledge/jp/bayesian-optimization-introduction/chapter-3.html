<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第3章：実践：材料探索への応用 - ベイズ最適化入門</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
        }

        pre code {
            background: none;
            padding: 0;
        }

        p code, li code {
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .info-box {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            color: var(--color-primary);
        }

        summary:hover {
            color: var(--color-accent);
        }

        details[open] summary {
            margin-bottom: var(--spacing-sm);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: var(--spacing-xl);
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            font-weight: 600;
            text-decoration: none;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--box-shadow);
            color: white;
            text-decoration: none;
        }

        .nav-button.secondary {
            background: var(--color-bg-alt);
            color: var(--color-primary);
            border: 1px solid var(--color-border);
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
                gap: var(--spacing-sm);
            }

            .nav-button {
                width: 100%;
                text-align: center;
            }
        }

        .math-display {
            overflow-x: auto;
            margin: var(--spacing-md) 0;
            padding: var(--spacing-sm);
            background-color: var(--color-bg-alt);
            border-left: 3px solid var(--color-accent);
        }

        strong {
            color: var(--color-primary-dark);
            font-weight: 600;
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第3章：実践：材料探索への応用</h1>
            <p class="subtitle">Python実装で学ぶ実世界の材料最適化</p>
            <div class="meta">
                <span class="meta-item">📖 読了時間: 25-30分</span>
                <span class="meta-item">📊 難易度: 中級</span>
                <span class="meta-item">💻 コード例: 12個</span>
                <span class="meta-item">📝 演習問題: 3問</span>
            </div>
        </div>
    </header>

    <main class="container">
        <h2>学習目標</h2>
        <p>この章を読むことで、以下を習得できます：</p>
        <ul>
            <li>✅ 材料物性予測MLモデルとベイズ最適化を統合できる</li>
            <li>✅ 制約付き最適化を実装し、材料の実現可能性を考慮できる</li>
            <li>✅ 多目的最適化でPareto最適解を計算できる</li>
            <li>✅ 実験コストを考慮したバッチベイズ最適化を実装できる</li>
            <li>✅ 実世界のLi-ion電池最適化問題を解決できる</li>
        </ul>

        <h2>3.1 材料物性予測MLモデルとの統合</h2>

        <h3>なぜMLモデルと統合するのか</h3>

        <p>材料探索では、ベイズ最適化を以下のように組み合わせます：</p>

        <ol>
            <li><strong>既存データからMLモデル構築</strong>
                <ul>
                    <li>Materials Projectなど公開データベース</li>
                    <li>過去の実験データ</li>
                    <li>DFT計算結果</li>
                </ul>
            </li>
            <li><strong>ベイズ最適化で新規材料探索</strong>
                <ul>
                    <li>MLモデルを目的関数として使用</li>
                    <li>実験回数を最小化</li>
                    <li>不確実性を活用</li>
                </ul>
            </li>
        </ol>

        <h3>Materials Project APIからデータ取得</h3>

        <p><strong>コード例1: Materials Projectからデータ取得</strong></p>

        <pre><code class="language-python"># Materials Projectからデータ取得
# 注: mp-api のインストールが必要: pip install mp-api
from mp_api.client import MPRester
import pandas as pd
import numpy as np

# Materials Project APIの使用（APIキー必要）
# 登録: https://materialsproject.org/api
API_KEY = "YOUR_API_KEY_HERE"  # 実際のAPIキーに置き換え

def fetch_battery_materials(api_key, max_materials=100):
    """Li-ion電池正極材料のデータを取得"""
    with MPRester(api_key) as mpr:
        # Li含有酸化物を検索
        docs = mpr.summary.search(
            elements=["Li", "O"],  # Li と O を含む
            num_elements=(3, 5),    # 3-5元素系
            fields=[
                "material_id",
                "formula_pretty",
                "formation_energy_per_atom",
                "band_gap",
                "density",
                "volume"
            ]
        )

        # DataFrameに変換
        data = []
        for doc in docs[:max_materials]:
            data.append({
                'material_id': doc.material_id,
                'formula': doc.formula_pretty,
                'formation_energy': doc.formation_energy_per_atom,
                'band_gap': doc.band_gap,
                'density': doc.density,
                'volume': doc.volume
            })

        df = pd.DataFrame(data)
        return df

# デモ用のダミーデータ（APIキーがない場合）
def generate_dummy_battery_data(n_samples=100):
    """ダミーのLi-ion電池材料データを生成"""
    np.random.seed(42)

    # 組成パラメータ（正規化）
    li_content = np.random.uniform(0.1, 0.5, n_samples)
    ni_content = np.random.uniform(0.1, 0.4, n_samples)
    co_content = np.random.uniform(0.1, 0.4, n_samples)
    mn_content = 1.0 - li_content - ni_content - co_content

    # 容量（mAh/g）: Li含量と相関
    capacity = (
        150 + 200 * li_content +
        50 * ni_content +
        30 * np.random.randn(n_samples)
    )

    # 電圧（V）: Co含量と相関
    voltage = (
        3.0 + 1.5 * co_content +
        0.2 * np.random.randn(n_samples)
    )

    # 安定性（formation energy）: 負が安定
    stability = (
        -2.0 - 0.5 * li_content -
        0.3 * ni_content +
        0.1 * np.random.randn(n_samples)
    )

    df = pd.DataFrame({
        'li_content': li_content,
        'ni_content': ni_content,
        'co_content': co_content,
        'mn_content': mn_content,
        'capacity': capacity,
        'voltage': voltage,
        'stability': stability
    })

    return df

# データ取得（ダミーデータ使用）
df_materials = generate_dummy_battery_data(n_samples=150)

print("材料データの統計:")
print(df_materials.describe())
print(f"\nデータシェイプ: {df_materials.shape}")</code></pre>

        <h3>機械学習モデルで物性予測</h3>

        <p><strong>コード例2: Random Forestで容量予測モデル構築</strong></p>

        <pre><code class="language-python"># Random Forestで容量予測
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt

# 特徴量とターゲット
X = df_materials[['li_content', 'ni_content',
                   'co_content', 'mn_content']].values
y_capacity = df_materials['capacity'].values

# データ分割
X_train, X_test, y_train, y_test = train_test_split(
    X, y_capacity, test_size=0.2, random_state=42
)

# Random Forestモデル
rf_model = RandomForestRegressor(
    n_estimators=100,
    max_depth=10,
    min_samples_split=5,
    random_state=42
)

# 訓練
rf_model.fit(X_train, y_train)

# 予測
y_pred_test = rf_model.predict(X_test)

# 評価
test_rmse = np.sqrt(mean_squared_error(y_test, y_pred_test))
test_r2 = r2_score(y_test, y_pred_test)

print("Random Forestモデルの性能:")
print(f"  テストRMSE: {test_rmse:.2f} mAh/g")
print(f"  テストR²: {test_r2:.3f}")

# 特徴量重要度
feature_names = ['Li', 'Ni', 'Co', 'Mn']
importances = rf_model.feature_importances_
indices = np.argsort(importances)[::-1]

print("\n特徴量重要度:")
for i in range(len(feature_names)):
    print(f"  {feature_names[indices[i]]}: {importances[indices[i]]:.3f}")</code></pre>

        <h3>MLモデルをベイズ最適化で活用</h3>

        <p><strong>コード例3: MLモデルとベイズ最適化の統合</strong></p>

        <pre><code class="language-python"># scikit-optimizeを使用したMLモデルベースの最適化
from skopt import gp_minimize
from skopt.space import Real
from skopt.plots import plot_convergence

def objective_function_ml(x):
    """
    MLモデルを目的関数として使用

    Parameters:
    -----------
    x : list
        [li_content, ni_content, co_content, mn_content]

    Returns:
    --------
    float : 負の容量（最小化問題に変換）
    """
    # 組成制約: 合計=1.0
    li, ni, co, mn = x
    total = li + ni + co + mn

    # 制約違反にペナルティ
    if not (0.98 <= total <= 1.02):
        return 1000.0  # 大きなペナルティ

    # MLモデルで容量予測
    X_pred = np.array([[li, ni, co, mn]])
    capacity_pred = rf_model.predict(X_pred)[0]

    # 最小化問題に変換（負の容量）
    return -capacity_pred

# 探索空間の定義
space = [
    Real(0.1, 0.5, name='li_content'),
    Real(0.1, 0.4, name='ni_content'),
    Real(0.1, 0.4, name='co_content'),
    Real(0.0, 0.5, name='mn_content')
]

# ベイズ最適化の実行
result = gp_minimize(
    objective_function_ml,
    space,
    n_calls=50,        # 50回の評価
    n_initial_points=10,  # 初期ランダムサンプリング
    random_state=42,
    verbose=False
)

# 結果
best_composition = result.x
best_capacity = -result.fun  # 負を元に戻す

print("ベイズ最適化の結果:")
print(f"  最適組成:")
print(f"    Li: {best_composition[0]:.3f}")
print(f"    Ni: {best_composition[1]:.3f}")
print(f"    Co: {best_composition[2]:.3f}")
print(f"    Mn: {best_composition[3]:.3f}")
print(f"    合計: {sum(best_composition):.3f}")
print(f"  予測容量: {best_capacity:.2f} mAh/g")</code></pre>

        <h2>3.2 制約付き最適化</h2>

        <h3>材料の実現可能性制約</h3>

        <p>実際の材料開発では、以下の制約があります：</p>

        <ol>
            <li><strong>組成制約</strong>: 合計100%、各元素の上下限</li>
            <li><strong>安定性制約</strong>: formation energy &lt; 閾値</li>
            <li><strong>実験的制約</strong>: 合成温度、圧力範囲</li>
            <li><strong>コスト制約</strong>: 高価な元素の使用制限</li>
        </ol>

        <div class="info-box">
            <p><strong>制約付きベイズ最適化のアプローチ</strong>:</p>
            <ol>
                <li><strong>制約関数もガウス過程でモデル化</strong></li>
                <li><strong>制約を満たす確率を獲得関数に組み込む</strong></li>
            </ol>
        </div>

        <h2>3.3 多目的最適化（Pareto最適化）</h2>

        <h3>なぜ多目的最適化が必要か</h3>

        <p>材料開発では、<strong>複数の特性を同時に最適化</strong>する必要があります：</p>

        <ul>
            <li><strong>Li-ion電池</strong>: 容量 ↑、電圧 ↑、安定性 ↑</li>
            <li><strong>熱電材料</strong>: ゼーベック係数 ↑、電気伝導度 ↑、熱伝導度 ↓</li>
            <li><strong>触媒</strong>: 活性 ↑、選択性 ↑、安定性 ↑、コスト ↓</li>
        </ul>

        <p>これらはトレードオフがあり、<strong>単一の最適解は存在しない</strong>。</p>

        <h3>Paretoフロンティアの概念</h3>

        <pre class="mermaid">
graph TB
    subgraph 目的空間
    A[目的1: 容量]
    B[目的2: 安定性]
    C[Paretoフロンティア<br/>トレードオフの境界]
    D[支配される解<br/>どちらも劣る]
    E[Pareto最適解<br/>改善にはトレードオフが必要]
    end

    A --> C
    B --> C
    C --> E
    D -.劣る.-> E

    style A fill:#e3f2fd
    style B fill:#fff3e0
    style C fill:#e8f5e9
    style E fill:#fce4ec
        </pre>

        <div class="info-box">
            <p><strong>Pareto最適の定義</strong>:</p>
            <blockquote>
                解 <em>x</em> が Pareto最適 ⇔ 全ての目的を同時に改善する解が存在しない
            </blockquote>
        </div>

        <h2>3.4 実験コストを考慮した最適化</h2>

        <h3>バッチベイズ最適化</h3>

        <p>実験装置が複数ある場合、<strong>並列実験</strong>が可能です：</p>

        <ul>
            <li><strong>従来</strong>: 逐次的（1回→結果→次の1回）</li>
            <li><strong>バッチBO</strong>: 一度に複数の候補を提案（q-EI）</li>
        </ul>

        <h3>ワークフロー</h3>

        <pre class="mermaid">
graph LR
    A[初期データ] --> B[ガウス過程モデル]
    B --> C[q-EI獲得関数<br/>q個の候補を提案]
    C --> D[並列実験<br/>q個同時実行]
    D --> E{終了?}
    E -->|No| B
    E -->|Yes| F[最良材料]

    style A fill:#e3f2fd
    style C fill:#fff3e0
    style D fill:#f3e5f5
    style F fill:#fce4ec
        </pre>

        <h2>3.5 本章のまとめ</h2>

        <h3>学んだこと</h3>

        <ol>
            <li><strong>MLモデルとの統合</strong>
                <ul>
                    <li>Materials Project APIでデータ取得</li>
                    <li>Random Forestで物性予測モデル構築</li>
                    <li>MLモデルを目的関数としてベイズ最適化</li>
                </ul>
            </li>
            <li><strong>制約付き最適化</strong>
                <ul>
                    <li>組成制約、安定性制約、コスト制約</li>
                    <li>制約を満たす確率を獲得関数に組み込む</li>
                    <li>実行可能領域に集中して探索</li>
                </ul>
            </li>
            <li><strong>多目的最適化</strong>
                <ul>
                    <li>Paretoフロンティアの計算</li>
                    <li>Expected Hypervolume Improvement（EHVI）</li>
                    <li>トレードオフの可視化と意思決定</li>
                </ul>
            </li>
            <li><strong>バッチ最適化</strong>
                <ul>
                    <li>並列実験による効率化</li>
                    <li>q-EI獲得関数</li>
                    <li>実験コストを考慮した最適化戦略</li>
                </ul>
            </li>
        </ol>

        <h3>重要なポイント</h3>

        <ul>
            <li>✅ <strong>実データとの統合</strong>が材料探索の鍵</li>
            <li>✅ <strong>制約を考慮</strong>しないと実行不可能な材料を提案</li>
            <li>✅ <strong>多目的最適化</strong>でトレードオフを明示的に扱う</li>
            <li>✅ <strong>バッチBO</strong>で並列実験の効率を最大化</li>
            <li>✅ <strong>ハイパーパラメータ調整</strong>が性能を左右</li>
        </ul>

        <h3>次の章へ</h3>

        <p>第4章では、アクティブラーニングと実験との連携を学びます：</p>
        <ul>
            <li>Uncertainty Sampling</li>
            <li>Query-by-Committee</li>
            <li>クローズドループ最適化</li>
            <li>自動実験装置との統合</li>
        </ul>

        <h2>演習問題</h2>

        <h3>問題1（難易度：easy）</h3>

        <p>Materials Projectのダミーデータを使用して、Random Forestモデルで容量予測を行ってください。</p>

        <p><strong>タスク</strong>:</p>
        <ol>
            <li><code>generate_dummy_battery_data()</code>で100サンプル生成</li>
            <li>Random Forestで訓練（80/20分割）</li>
            <li>テストデータでRMSEとR²を計算</li>
            <li>特徴量重要度をプロット</li>
        </ol>

        <details>
            <summary>ヒント</summary>
            <ul>
                <li><code>train_test_split()</code>でデータ分割</li>
                <li><code>RandomForestRegressor</code>のデフォルトパラメータで十分</li>
                <li><code>feature_importances_</code>属性で重要度取得</li>
            </ul>
        </details>

        <h3>問題2（難易度：medium）</h3>

        <p>制約付きベイズ最適化を実装し、制約なしの場合と比較してください。</p>

        <p><strong>問題設定</strong>:</p>
        <ul>
            <li>目的: 容量を最大化</li>
            <li>制約: Co含量 &lt; 0.25（コスト制約）</li>
        </ul>

        <p><strong>タスク</strong>:</p>
        <ol>
            <li>制約なしベイズ最適化を20回実行</li>
            <li>制約付きベイズ最適化を20回実行</li>
            <li>各イテレーションでの最良値をプロット</li>
            <li>最終的な最適組成を比較</li>
        </ol>

        <h3>問題3（難易度：hard）</h3>

        <p>多目的ベイズ最適化を実装し、容量と安定性のParetoフロンティアを計算してください。</p>

        <p><strong>問題設定</strong>:</p>
        <ul>
            <li>目的1: 容量を最大化</li>
            <li>目的2: 安定性を最大化（formation energyの絶対値を最小化）</li>
        </ul>

        <p><strong>タスク</strong>:</p>
        <ol>
            <li>初期ランダムサンプリング（15点）</li>
            <li>逐次最適化（30回）</li>
            <li>Pareto最適解を抽出</li>
            <li>Paretoフロンティアを可視化</li>
            <li>代表的な3つの解（容量重視、安定性重視、バランス型）を提示</li>
        </ol>

        <h2>参考文献</h2>

        <ol>
            <li>Frazier, P. I. & Wang, J. (2016). "Bayesian Optimization for Materials Design." <em>Information Science for Materials Discovery and Design</em>, 45-75. DOI: <a href="https://doi.org/10.1007/978-3-319-23871-5_3" target="_blank">10.1007/978-3-319-23871-5_3</a></li>
            <li>Lookman, T. et al. (2019). "Active learning in materials science with emphasis on adaptive sampling using uncertainties for targeted design." <em>npj Computational Materials</em>, 5(1), 21. DOI: <a href="https://doi.org/10.1038/s41524-019-0153-8" target="_blank">10.1038/s41524-019-0153-8</a></li>
            <li>Balandat, M. et al. (2020). "BoTorch: A Framework for Efficient Monte-Carlo Bayesian Optimization." <em>NeurIPS 2020</em>. <a href="https://arxiv.org/abs/1910.06403" target="_blank">arXiv:1910.06403</a></li>
            <li>Jain, A. et al. (2013). "Commentary: The Materials Project: A materials genome approach to accelerating materials innovation." <em>APL Materials</em>, 1(1), 011002. DOI: <a href="https://doi.org/10.1063/1.4812323" target="_blank">10.1063/1.4812323</a></li>
            <li>Pedregosa, F. et al. (2011). "Scikit-learn: Machine Learning in Python." <em>Journal of Machine Learning Research</em>, 12, 2825-2830.</li>
        </ol>

        <div class="navigation">
            <a href="./chapter-2.html" class="nav-button secondary">← 第2章：ベイズ最適化の理論</a>
            <a href="./index.html" class="nav-button secondary">シリーズ目次</a>
            <a href="./chapter-4.html" class="nav-button">第4章：アクティブラーニング戦略 →</a>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 MI Knowledge Hub - Dr. Yusuke Hashimoto, Tohoku University</p>
            <p>Licensed under CC BY 4.0</p>
        </div>
    </footer>
</body>
</html>
